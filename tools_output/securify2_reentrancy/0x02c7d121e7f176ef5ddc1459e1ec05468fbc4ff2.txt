[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        371
Source: 
>             transaction.executed = true;
>             (bool success, ) = transaction.destination.call.value(transaction.value)(transaction.data);
>                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             if (success)

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        495
Source: 
>     function depositAll0(address pair) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).depositAll0();
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        498
Source: 
>     function depositAll1(address pair) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).depositAll1();        
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        501
Source: 
>     function depositSome0(address pair, uint amount) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).depositSome0(amount);
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        504
Source: 
>     function depositSome1(address pair, uint amount) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).depositSome1(amount);        
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        507
Source: 
>     function setY0(address pair, address vault) external ownerExists(msg.sender) onlyWhiteListVault(vault) onlyUnisavePair(pair) {
>         IUnisavePair(pair).setY0(vault);     
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        510
Source: 
>     function setY1(address pair, address vault) external ownerExists(msg.sender) onlyWhiteListVault(vault) onlyUnisavePair(pair) {
>         IUnisavePair(pair).setY1(vault);     
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        513
Source: 
>     function setFee(address pair, uint16 _fee) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).setFee(_fee);     
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }    

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Gas-dependent Reentrancy
Description: Calls into external contracts that receive all remaining
             gas and are followed by state changes may be reentrant.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        371
Source: 
>             transaction.executed = true;
>             (bool success, ) = transaction.destination.call.value(transaction.value)(transaction.data);
>                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             if (success)

[0m
[0;31mSeverity:    INFO
Pattern:     Low Level Calls
Description: Usage of <address>.call should be avoided
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        371
Source: 
>             transaction.executed = true;
>             (bool success, ) = transaction.destination.call.value(transaction.value)(transaction.data);
>                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             if (success)

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        411
Source: 
>       */
>     function getConfirmationCount(uint256 transactionId)
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         external

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        428
Source: 
>       */
>     function getTransactionCount(bool pending, bool executed)
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         external

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        500
Source: 
>     }
>     function depositSome0(address pair, uint amount) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         IUnisavePair(pair).depositSome0(amount);

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        503
Source: 
>     }
>     function depositSome1(address pair, uint amount) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         IUnisavePair(pair).depositSome1(amount);        

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        512
Source: 
>     }
>     function setFee(address pair, uint16 _fee) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         IUnisavePair(pair).setFee(_fee);     

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        266
Source: 
>       */
>     function changeLockSeconds(uint256 _lockSeconds)
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         external

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        280
Source: 
>       */
>     function submitTransaction(address destination, uint256 value, bytes calldata data)
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         external

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        385
Source: 
>       */
>     function isConfirmed(uint256 transactionId)
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         public

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        455
Source: 
>       */
>     function getConfirmations(uint256 transactionId)
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         external

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        515
Source: 
>     }    
>     function addWhiteListVault(address vault) external onlyWallet {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         whiteListVault[vault] = true;

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        518
Source: 
>     }
>     function removeWhiteListVault(address vault) external onlyWallet {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         whiteListVault[vault] = false;

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        39
Source: 
>     uint256 constant public MAX_OWNER_COUNT = 50;
>     address constant public unisave_factory = address(0x32CE36F6eA8d97f9fC19Aab83b9c6D2F52D74470);
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     address constant public gainswap_factory = address(0x756627591715d0F1aA285c80E62675e949ED19F5);    

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        40
Source: 
>     address constant public unisave_factory = address(0x32CE36F6eA8d97f9fC19Aab83b9c6D2F52D74470);
>     address constant public gainswap_factory = address(0x756627591715d0F1aA285c80E62675e949ED19F5);    
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        371
Source: 
>             transaction.executed = true;
>             (bool success, ) = transaction.destination.call.value(transaction.value)(transaction.data);
>              ^^^^^^^^^^^^
>             if (success)

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        86
Source: 
> 
>     modifier ownerDoesNotExist(address owner) {
>                                ^^^^^^^^^^^^^
>         if (isOwner[owner])

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        92
Source: 
> 
>     modifier ownerExists(address owner) {
>                          ^^^^^^^^^^^^^
>         if (!isOwner[owner])

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        98
Source: 
> 
>     modifier transactionExists(uint256 transactionId) {
>                                ^^^^^^^^^^^^^^^^^^^^^
>         if (transactions[transactionId].destination == address(0))

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        104
Source: 
> 
>     modifier confirmed(uint256 transactionId, address owner) {
>                        ^^^^^^^^^^^^^^^^^^^^^
>         if (!confirmations[transactionId][owner])

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        104
Source: 
> 
>     modifier confirmed(uint256 transactionId, address owner) {
>                                               ^^^^^^^^^^^^^
>         if (!confirmations[transactionId][owner])

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        110
Source: 
> 
>     modifier notConfirmed(uint256 transactionId, address owner) {
>                           ^^^^^^^^^^^^^^^^^^^^^
>         if (confirmations[transactionId][owner])

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        110
Source: 
> 
>     modifier notConfirmed(uint256 transactionId, address owner) {
>                                                  ^^^^^^^^^^^^^
>         if (confirmations[transactionId][owner])

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        116
Source: 
> 
>     modifier notExecuted(uint256 transactionId) {
>                          ^^^^^^^^^^^^^^^^^^^^^
>         if (transactions[transactionId].executed)

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        122
Source: 
> 
>     modifier notNull(address _address) {
>                      ^^^^^^^^^^^^^^^^
>         if (_address == address(0))

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        128
Source: 
> 
>     modifier validRequirement(uint256 ownerCount, uint256 _required) {
>                               ^^^^^^^^^^^^^^^^^^
>         if (ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0)

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        128
Source: 
> 
>     modifier validRequirement(uint256 ownerCount, uint256 _required) {
>                                                   ^^^^^^^^^^^^^^^^^
>         if (ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0)

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        482
Source: 
>     
>     modifier onlyWhiteListVault(address vault) {
>                                 ^^^^^^^^^^^^^
>         require(whiteListVault[vault], 'only whitelist vault');

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        487
Source: 
>     
>     modifier onlyUnisavePair(address pair) {
>                              ^^^^^^^^^^^^
>         address token0 = IUnisavePair(pair).token0();

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>         ^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>         ^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Amount
Description: The amount of ether transferred must not be influenced by
             other transactions.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        371
Source: 
>             transaction.executed = true;
>             (bool success, ) = transaction.destination.call.value(transaction.value)(transaction.data);
>                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             if (success)

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        371
Source: 
>             transaction.executed = true;
>             (bool success, ) = transaction.destination.call.value(transaction.value)(transaction.data);
>                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             if (success)

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        371
Source: 
>             transaction.executed = true;
>             (bool success, ) = transaction.destination.call.value(transaction.value)(transaction.data);
>                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             if (success)

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        488
Source: 
>     modifier onlyUnisavePair(address pair) {
>         address token0 = IUnisavePair(pair).token0();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         address token1 = IUnisavePair(pair).token1();

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        489
Source: 
>         address token0 = IUnisavePair(pair).token0();
>         address token1 = IUnisavePair(pair).token1();
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MultiSigWalletWithTimelock
Line:        490
Source: 
>         address token1 = IUnisavePair(pair).token1();
>         require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, "only unisave pair");
>                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _;

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        495
Source: 
>     function depositAll0(address pair) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).depositAll0();
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        498
Source: 
>     function depositAll1(address pair) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).depositAll1();        
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        501
Source: 
>     function depositSome0(address pair, uint amount) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).depositSome0(amount);
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        504
Source: 
>     function depositSome1(address pair, uint amount) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).depositSome1(amount);        
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        507
Source: 
>     function setY0(address pair, address vault) external ownerExists(msg.sender) onlyWhiteListVault(vault) onlyUnisavePair(pair) {
>         IUnisavePair(pair).setY0(vault);     
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        510
Source: 
>     function setY1(address pair, address vault) external ownerExists(msg.sender) onlyWhiteListVault(vault) onlyUnisavePair(pair) {
>         IUnisavePair(pair).setY1(vault);     
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        513
Source: 
>     function setFee(address pair, uint16 _fee) external ownerExists(msg.sender) onlyUnisavePair(pair) {
>         IUnisavePair(pair).setFee(_fee);     
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }    

[0m
[0;31mSeverity:    HIGH
Pattern:     Uninitialized State Variable
Description: State variables should be explicitly initialized.
Type:        Violation
Contract:    MultiSigWalletWithTimelock
Line:        63
Source: 
>     uint256 public required;
>     uint256 public transactionCount;
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 

[0m
[0;35mSeverity:    LOW
Pattern:     Usage of block timestamp
Description: Returned value relies on block timestamp.
Type:        Conflict
Contract:    MultiSigWalletWithTimelock
Line:        364
Source: 
>         require(
>             block.timestamp >= unlockTimes[transactionId],
>             ^^^^^^^^^^^^^^^
>             "TRANSACTION_NEED_TO_UNLOCK"

[0m
