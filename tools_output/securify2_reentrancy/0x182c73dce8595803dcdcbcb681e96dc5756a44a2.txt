Environment variable LD_LIBRARY_PATH not set. Setting it up...
[0;31mSeverity:    LOW
Pattern:     External Calls of Functions
Description: A public function that is never called within the
             contract should be marked as external
Type:        Violation
Contract:    Future1exchange
Line:        326
Source: 
>      */
>     function disableSellerCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount) payable public returns(bool) {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    Future1exchange
Line:        129
Source: 
>      */
>     function setRequestCancellationMinimumTime(uint32 _newRequestCancelMinimumTime) onlyOwner external {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         requestCancelMinimumTime = _newRequestCancelMinimumTime;

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    Future1exchange
Line:        278
Source: 
>      */
>     function withdrawFees(address payable _to, uint256 _amount,uint16 _type, address _tokenContract) onlyOwner external {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if(_type == 1) {

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    Future1exchange
Line:        170
Source: 
>      */
>     function createEscrow(uint16 _tradeId, address _seller, address _buyer, uint256 _amount, address _tokenContract, uint256 _sellerFee, uint256 _buyerFee,uint16 _type,uint32 _sellerCancelInSeconds, address[2] calldata _Ref, address[2] calldata _Tokens, uint256[2] calldata _Type)  payable external returns(bool) {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    Future1exchange
Line:        362
Source: 
>      */
>     function buyerCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount,address tokenadd) external returns(bool) {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    Future1exchange
Line:        387
Source: 
>      */
>     function sellerCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount, address tokenadd) external returns(bool) {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    Future1exchange
Line:        464
Source: 
>      */
>     function releseFunds(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount,address _tokenContract) external  returns(bool)
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     {

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    Future1exchange
Line:        534
Source: 
>      */
>     function disputeByMediator(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount, uint16 _favour, address _tokenContract) external  returns(bool) {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(msg.sender == feeAddress,"This user not allowed to call this function");

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    Future1exchange
Line:        611
Source: 
>     
>     function tokenallowance(address tokenAddr,address _owner,address _spender) public view returns(uint256){ // to check token allowance to contract
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         return Token(tokenAddr).allowance(_owner,_spender);

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Reentrancy with constant gas
Description: Ether transfers (such as send and transfer) that are
             followed by state changes may be reentrant.
Type:        Warning
Contract:    Future1exchange
Line:        282
Source: 
>             _token[address(this)][address(0)] = _token[address(this)][address(0)].sub(_amount);
>             _to.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Reentrancy with constant gas
Description: Ether transfers (such as send and transfer) that are
             followed by state changes may be reentrant.
Type:        Warning
Contract:    Future1exchange
Line:        302
Source: 
>             _referralFee[msg.sender][address(0)] =  _referralFee[msg.sender][address(0)].sub(_amount);
>             msg.sender.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Reentrancy with constant gas
Description: Ether transfers (such as send and transfer) that are
             followed by state changes may be reentrant.
Type:        Warning
Contract:    Future1exchange
Line:        368
Source: 
>         if(escrow_map[_tradeHash].eType == 1 ) {
>             _seller.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Reentrancy with constant gas
Description: Ether transfers (such as send and transfer) that are
             followed by state changes may be reentrant.
Type:        Warning
Contract:    Future1exchange
Line:        395
Source: 
>        if(escrow_map[_tradeHash].eType == 1 ) {
>             _seller.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Reentrancy with constant gas
Description: Ether transfers (such as send and transfer) that are
             followed by state changes may be reentrant.
Type:        Warning
Contract:    Future1exchange
Line:        513
Source: 
>             if(escrow_map[_tradeHash].eType == 1 ) {//ether 
>                  _buyer.transfer(_amount.sub(escrow_map[_tradeHash].buyerFee));
>                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Reentrancy with constant gas
Description: Ether transfers (such as send and transfer) that are
             followed by state changes may be reentrant.
Type:        Warning
Contract:    Future1exchange
Line:        590
Source: 
>              if(_favour == 1) {//seller
>                   _seller.transfer(_amount);
>                   ^^^^^^^^^^^^^^^^^^^^^^^^^
>              }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Reentrancy with constant gas
Description: Ether transfers (such as send and transfer) that are
             followed by state changes may be reentrant.
Type:        Warning
Contract:    Future1exchange
Line:        593
Source: 
>              else if (_favour == 2) {//buyer
>                 _buyer.transfer(_amount.sub(escrow_map[_tradeHash].buyerFee));
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>              }

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        99
Source: 
>     
>     mapping(address => User) public referral_map;
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     mapping(bytes32 => Escrow) public escrow_map;

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        100
Source: 
>     mapping(address => User) public referral_map;
>     mapping(bytes32 => Escrow) public escrow_map;
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     mapping (address => mapping(address => uint256)) public _token;

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        101
Source: 
>     mapping(bytes32 => Escrow) public escrow_map;
>     mapping (address => mapping(address => uint256)) public _token;
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     mapping(address => mapping(address => uint256)) public _referralFee;

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        102
Source: 
>     mapping (address => mapping(address => uint256)) public _token;
>     mapping(address => mapping(address => uint256)) public _referralFee;
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        171
Source: 
>     function createEscrow(uint16 _tradeId, address _seller, address _buyer, uint256 _amount, address _tokenContract, uint256 _sellerFee, uint256 _buyerFee,uint16 _type,uint32 _sellerCancelInSeconds, address[2] calldata _Ref, address[2] calldata _Tokens, uint256[2] calldata _Type)  payable external returns(bool) {
>         bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));
>         ^^^^^^^^^^^^^^^^^^
>         

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        207
Source: 
>         
>         uint256 _sellerCancelAfter = _sellerCancelInSeconds == 0 ? 1 : ((now).add(_sellerCancelInSeconds));
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^
>         

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        327
Source: 
>     function disableSellerCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount) payable public returns(bool) {
>         bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));
>         ^^^^^^^^^^^^^^^^^^
>         require(escrow_map[_tradeHash].escrowStatus == true, "Status Checking Failed.. ");

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        363
Source: 
>     function buyerCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount,address tokenadd) external returns(bool) {
>        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));
>        ^^^^^^^^^^^^^^^^^^
>        require(escrow_map[_tradeHash].escrowStatus == true && msg.sender==feeAddress, "Invalid Escrow status or This user not allowed to call");

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        388
Source: 
>     function sellerCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount, address tokenadd) external returns(bool) {
>        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));
>        ^^^^^^^^^^^^^^^^^^
>         

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        415
Source: 
>     function sellerRequestCancel(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount) external returns(bool) {
>        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));
>        ^^^^^^^^^^^^^^^^^^
>        

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        440
Source: 
>     function consumeDispute(uint16 _tradeId, address payable _seller, address payable _buyer, uint256 _amount, uint16 disputetype) external returns (bool) {
>         bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));
>         ^^^^^^^^^^^^^^^^^^
>          

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        467
Source: 
>         require(msg.sender == feeAddress, "This user not allowed to call this function");
>         bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));
>         ^^^^^^^^^^^^^^^^^^
>         require(escrow_map[_tradeHash].escrowStatus == true, "Status Failed.. ");

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        469
Source: 
>         require(escrow_map[_tradeHash].escrowStatus == true, "Status Failed.. ");
>         uint256[2] memory _reffee; 
>         ^^^^^^^^^^^^^^^^^^^^^^^^^
>         uint256 percDiv =uint256((100)).mul(10**18);

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        537
Source: 
>         
>         bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId,_seller,_buyer,_amount));
>         ^^^^^^^^^^^^^^^^^^
>          

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    Future1exchange
Line:        545
Source: 
>          
>         uint256[2] memory _reffee;
>         ^^^^^^^^^^^^^^^^^^^^^^^^^
>         uint256 percDiv =uint256((100)).mul(10**18);

[0m
[0;31mSeverity:    LOW
Pattern:     Solidity pragma directives
Description: Avoid complex solidity version pragma statements.
Type:        Violation
Contract:    None
Line:        5
Source: 
> 
> pragma solidity ^0.5.12;
> ^^^^^^^^^^^^^^^^^^^^^^^^
> 

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Amount
Description: The amount of ether transferred must not be influenced by
             other transactions.
Type:        Warning
Contract:    Future1exchange
Line:        282
Source: 
>             _token[address(this)][address(0)] = _token[address(this)][address(0)].sub(_amount);
>             _to.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Amount
Description: The amount of ether transferred must not be influenced by
             other transactions.
Type:        Warning
Contract:    Future1exchange
Line:        302
Source: 
>             _referralFee[msg.sender][address(0)] =  _referralFee[msg.sender][address(0)].sub(_amount);
>             msg.sender.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Amount
Description: The amount of ether transferred must not be influenced by
             other transactions.
Type:        Warning
Contract:    Future1exchange
Line:        513
Source: 
>             if(escrow_map[_tradeHash].eType == 1 ) {//ether 
>                  _buyer.transfer(_amount.sub(escrow_map[_tradeHash].buyerFee));
>                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Amount
Description: The amount of ether transferred must not be influenced by
             other transactions.
Type:        Warning
Contract:    Future1exchange
Line:        593
Source: 
>              else if (_favour == 2) {//buyer
>                 _buyer.transfer(_amount.sub(escrow_map[_tradeHash].buyerFee));
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>              }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Warning
Contract:    Future1exchange
Line:        282
Source: 
>             _token[address(this)][address(0)] = _token[address(this)][address(0)].sub(_amount);
>             _to.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Warning
Contract:    Future1exchange
Line:        368
Source: 
>         if(escrow_map[_tradeHash].eType == 1 ) {
>             _seller.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Warning
Contract:    Future1exchange
Line:        395
Source: 
>        if(escrow_map[_tradeHash].eType == 1 ) {
>             _seller.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Warning
Contract:    Future1exchange
Line:        590
Source: 
>              if(_favour == 1) {//seller
>                   _seller.transfer(_amount);
>                   ^^^^^^^^^^^^^^^^^^^^^^^^^
>              }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Warning
Contract:    Future1exchange
Line:        593
Source: 
>              else if (_favour == 2) {//buyer
>                 _buyer.transfer(_amount.sub(escrow_map[_tradeHash].buyerFee));
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>              }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    Future1exchange
Line:        302
Source: 
>             _referralFee[msg.sender][address(0)] =  _referralFee[msg.sender][address(0)].sub(_amount);
>             msg.sender.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    Future1exchange
Line:        282
Source: 
>             _token[address(this)][address(0)] = _token[address(this)][address(0)].sub(_amount);
>             _to.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    Future1exchange
Line:        302
Source: 
>             _referralFee[msg.sender][address(0)] =  _referralFee[msg.sender][address(0)].sub(_amount);
>             msg.sender.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    Future1exchange
Line:        368
Source: 
>         if(escrow_map[_tradeHash].eType == 1 ) {
>             _seller.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    Future1exchange
Line:        395
Source: 
>        if(escrow_map[_tradeHash].eType == 1 ) {
>             _seller.transfer(_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    Future1exchange
Line:        513
Source: 
>             if(escrow_map[_tradeHash].eType == 1 ) {//ether 
>                  _buyer.transfer(_amount.sub(escrow_map[_tradeHash].buyerFee));
>                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    Future1exchange
Line:        590
Source: 
>              if(_favour == 1) {//seller
>                   _seller.transfer(_amount);
>                   ^^^^^^^^^^^^^^^^^^^^^^^^^
>              }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    Future1exchange
Line:        593
Source: 
>              else if (_favour == 2) {//buyer
>                 _buyer.transfer(_amount.sub(escrow_map[_tradeHash].buyerFee));
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>              }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        150
Source: 
>         require(tokenallowance(_tokenContract,_from,address(this)) >= _amount, "Insufficient Allowance");
>         Token(_tokenContract).transferFrom(_from,address(this),_amount);
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _referralFee[_from][_tokenContract] = _referralFee[_from][_tokenContract].add(_amount);

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        612
Source: 
>     function tokenallowance(address tokenAddr,address _owner,address _spender) public view returns(uint256){ // to check token allowance to contract
>         return Token(tokenAddr).allowance(_owner,_spender);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        202
Source: 
>         if(_type == 2){
>             Token(_tokenContract).transferFrom(_seller,address(this), _amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        288
Source: 
>             _token[address(this)][_tokenContract] = _token[address(this)][_tokenContract].sub(_amount);
>             Token(_tokenContract).transfer(_to,_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        308
Source: 
>                 _referralFee[ msg.sender][_tokenContract] = _referralFee[ msg.sender][_tokenContract].sub(_amount);
>                 Token(_tokenContract).transfer( msg.sender,_amount);
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>                 

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        314
Source: 
>                 _referralFee[ msg.sender][referral_map[msg.sender].referralTokenAddr] = _referralFee[ msg.sender][referral_map[msg.sender].referralTokenAddr].sub(_amount);
>                 Token(referral_map[msg.sender].referralTokenAddr).transfer(msg.sender,_amount);
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        371
Source: 
>         if (escrow_map[_tradeHash].eType== 2) {
>             Token(tokenadd).transfer(_seller,_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        399
Source: 
>         if (escrow_map[_tradeHash].eType == 2) {
>             Token(tokenadd).transfer(_seller,_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        517
Source: 
>             if (escrow_map[_tradeHash].eType == 2)  {//token 
>                 Token(_tokenContract).transfer(_buyer,(_amount));
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        598
Source: 
>               if(_favour == 1) { //seller
>                   Token(_tokenContract).transfer(_seller,_amount);
>                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>              }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    Future1exchange
Line:        601
Source: 
>              else if (_favour == 2) {//buyer
>                  Token(_tokenContract).transfer(_buyer,(_amount));
>                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             }

[0m
[0;31mSeverity:    INFO
Pattern:     Uninitialized Local Variables
Description: A variable is declared but never initialized.
Type:        Violation
Contract:    Future1exchange
Line:        471
Source: 
>         uint256 percDiv =uint256((100)).mul(10**18);
>         _reffee[0] = (escrow_map[_tradeHash].sellerFee.mul(referPercent)).div(percDiv);  // seller Referral Fee 
>         ^^^^^^^
>         _reffee[1] = (escrow_map[_tradeHash].buyerFee.mul(referPercent)).div(percDiv); // buyer Referral Fee

[0m
[0;31mSeverity:    INFO
Pattern:     Uninitialized Local Variables
Description: A variable is declared but never initialized.
Type:        Violation
Contract:    Future1exchange
Line:        547
Source: 
>         uint256 percDiv =uint256((100)).mul(10**18);
>         _reffee[0] = (escrow_map[_tradeHash].sellerFee.mul(referPercent)).div(percDiv);  // seller Referral Fee 
>         ^^^^^^^
>         _reffee[1] = (escrow_map[_tradeHash].buyerFee.mul(referPercent)).div(percDiv); // buyer Referral Fee

[0m
[0;31mSeverity:    HIGH
Pattern:     Uninitialized State Variable
Description: State variables should be explicitly initialized.
Type:        Violation
Contract:    Future1exchange
Line:        64
Source: 
>     uint32 public requestCancelMinimumTime;
>     uint256 public referPercent;
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        151
Source: 
>         Token(_tokenContract).transferFrom(_from,address(this),_amount);
>         _referralFee[_from][_tokenContract] = _referralFee[_from][_tokenContract].add(_amount);
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         return true;

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        234
Source: 
>         if(_sellrefer!= address(0)) { // referralAddr checking for referral fee 
>             referral_map[_seller].referralAddr =_sellrefer;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_seller].registerStatus =true;

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        235
Source: 
>             referral_map[_seller].referralAddr =_sellrefer;
>             referral_map[_seller].registerStatus =true;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        239
Source: 
>         if(_sellerFeeType == 1) {// referral token for admin fee/referral fee
>             referral_map[_seller].userAddr = _seller;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_seller].referralTokenAddr = _sellerToken;

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        240
Source: 
>             referral_map[_seller].userAddr = _seller;
>             referral_map[_seller].referralTokenAddr = _sellerToken;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_seller].referralType = _sellerFeeType;

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        241
Source: 
>             referral_map[_seller].referralTokenAddr = _sellerToken;
>             referral_map[_seller].referralType = _sellerFeeType;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        252
Source: 
>         if(_buyrefer != address(0)) { // referralAddr checking for referral fee
>             referral_map[_buyer].referralAddr = _buyrefer;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_buyer].registerStatus =true;

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        253
Source: 
>             referral_map[_buyer].referralAddr = _buyrefer;
>             referral_map[_buyer].registerStatus =true;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        257
Source: 
>         if(_buyerFeeType ==1) {// referral token for admin fee/referral fee
>             referral_map[_buyer].userAddr = _buyer;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_buyer].referralTokenAddr = _buyerToken;

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        258
Source: 
>             referral_map[_buyer].userAddr = _buyer;
>             referral_map[_buyer].referralTokenAddr = _buyerToken;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_buyer].referralType = _buyerFeeType;

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        259
Source: 
>             referral_map[_buyer].referralTokenAddr = _buyerToken;
>             referral_map[_buyer].referralType = _buyerFeeType;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        263
Source: 
>         else if(_buyerFeeType == 0) { // referral ether for admin fee/referral fee
>             referral_map[_buyer].userAddr = _buyer;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_buyer].referralTokenAddr = address(0);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        264
Source: 
>             referral_map[_buyer].userAddr = _buyer;
>             referral_map[_buyer].referralTokenAddr = address(0);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_buyer].referralType = _buyerFeeType;

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        265
Source: 
>             referral_map[_buyer].referralTokenAddr = address(0);
>             referral_map[_buyer].referralType = _buyerFeeType;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        245
Source: 
>         else if(_sellerFeeType == 0) {// referral ether for admin fee/referral fee
>             referral_map[_seller].userAddr = _seller;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_seller].referralTokenAddr = address(0);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        246
Source: 
>             referral_map[_seller].userAddr = _seller;
>             referral_map[_seller].referralTokenAddr = address(0);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             referral_map[_seller].referralType = _sellerFeeType;

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Violation
Contract:    Future1exchange
Line:        247
Source: 
>             referral_map[_seller].referralTokenAddr = address(0);
>             referral_map[_seller].referralType = _sellerFeeType;
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        150
Source: 
>         require(tokenallowance(_tokenContract,_from,address(this)) >= _amount, "Insufficient Allowance");
>         Token(_tokenContract).transferFrom(_from,address(this),_amount);
>         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _referralFee[_from][_tokenContract] = _referralFee[_from][_tokenContract].add(_amount);

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        202
Source: 
>         if(_type == 2){
>             Token(_tokenContract).transferFrom(_seller,address(this), _amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        288
Source: 
>             _token[address(this)][_tokenContract] = _token[address(this)][_tokenContract].sub(_amount);
>             Token(_tokenContract).transfer(_to,_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        308
Source: 
>                 _referralFee[ msg.sender][_tokenContract] = _referralFee[ msg.sender][_tokenContract].sub(_amount);
>                 Token(_tokenContract).transfer( msg.sender,_amount);
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>                 

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        314
Source: 
>                 _referralFee[ msg.sender][referral_map[msg.sender].referralTokenAddr] = _referralFee[ msg.sender][referral_map[msg.sender].referralTokenAddr].sub(_amount);
>                 Token(referral_map[msg.sender].referralTokenAddr).transfer(msg.sender,_amount);
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             }

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        371
Source: 
>         if (escrow_map[_tradeHash].eType== 2) {
>             Token(tokenadd).transfer(_seller,_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        399
Source: 
>         if (escrow_map[_tradeHash].eType == 2) {
>             Token(tokenadd).transfer(_seller,_amount);
>             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        517
Source: 
>             if (escrow_map[_tradeHash].eType == 2)  {//token 
>                 Token(_tokenContract).transfer(_buyer,(_amount));
>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             }

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        598
Source: 
>               if(_favour == 1) { //seller
>                   Token(_tokenContract).transfer(_seller,_amount);
>                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>              }

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    Future1exchange
Line:        601
Source: 
>              else if (_favour == 2) {//buyer
>                  Token(_tokenContract).transfer(_buyer,(_amount));
>                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>             }

[0m
