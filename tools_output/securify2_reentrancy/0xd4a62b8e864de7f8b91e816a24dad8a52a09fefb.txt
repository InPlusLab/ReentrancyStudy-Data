[0;31mSeverity:    INFO
Pattern:     Assembly Usage
Description: Usage of assembly in Solidity code is discouraged.
Type:        Violation
Contract:    ECDSA
Line:        378
Source: 
>         // solhint-disable-next-line no-inline-assembly
>         assembly {
>         ^^^^^^^^^^
>             r := mload(add(signature, 0x20))

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Dangerous Strict Equalities
Description: Strict equalities that use account's balance, timestamps
             and block numbers should be avoided
Type:        Violation
Contract:    SafeMath
Line:        157
Source: 
>         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
>         if (a == 0) {
>             ^^^^^^
>             return 0;

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Dangerous Strict Equalities
Description: Strict equalities that use account's balance, timestamps
             and block numbers should be avoided
Type:        Violation
Contract:    SafeMath
Line:        162
Source: 
>         uint256 c = a * b;
>         require(c / a == b, "SafeMath: multiplication overflow");
>                 ^^^^^^^^^^
> 

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Dangerous Strict Equalities
Description: Strict equalities that use account's balance, timestamps
             and block numbers should be avoided
Type:        Violation
Contract:    SafeMath
Line:        157
Source: 
>         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
>         if (a == 0) {
>             ^^^^^^
>             return 0;

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Dangerous Strict Equalities
Description: Strict equalities that use account's balance, timestamps
             and block numbers should be avoided
Type:        Violation
Contract:    SafeMath
Line:        162
Source: 
>         uint256 c = a * b;
>         require(c / a == b, "SafeMath: multiplication overflow");
>                 ^^^^^^^^^^
> 

[0m
[0;31mSeverity:    LOW
Pattern:     External Calls of Functions
Description: A public function that is never called within the
             contract should be marked as external
Type:        Violation
Contract:    Ownable
Line:        290
Source: 
>      */
>     function owner() public view returns (address) {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         return _owner;

[0m
[0;31mSeverity:    LOW
Pattern:     External Calls of Functions
Description: A public function that is never called within the
             contract should be marked as external
Type:        Violation
Contract:    Ownable
Line:        316
Source: 
>      */
>     function renounceOwnership() public onlyOwner {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         emit OwnershipTransferred(_owner, address(0));

[0m
[0;31mSeverity:    LOW
Pattern:     External Calls of Functions
Description: A public function that is never called within the
             contract should be marked as external
Type:        Violation
Contract:    Ownable
Line:        325
Source: 
>      */
>     function transferOwnership(address newOwner) public onlyOwner {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _transferOwnership(newOwner);

[0m
[0;31mSeverity:    LOW
Pattern:     External Calls of Functions
Description: A public function that is never called within the
             contract should be marked as external
Type:        Violation
Contract:    Ownable
Line:        316
Source: 
>      */
>     function renounceOwnership() public onlyOwner {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         emit OwnershipTransferred(_owner, address(0));

[0m
[0;31mSeverity:    LOW
Pattern:     External Calls of Functions
Description: A public function that is never called within the
             contract should be marked as external
Type:        Violation
Contract:    Ownable
Line:        325
Source: 
>      */
>     function transferOwnership(address newOwner) public onlyOwner {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _transferOwnership(newOwner);

[0m
[0;31mSeverity:    LOW
Pattern:     External Calls of Functions
Description: A public function that is never called within the
             contract should be marked as external
Type:        Violation
Contract:    Ownable
Line:        316
Source: 
>      */
>     function renounceOwnership() public onlyOwner {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         emit OwnershipTransferred(_owner, address(0));

[0m
[0;31mSeverity:    LOW
Pattern:     External Calls of Functions
Description: A public function that is never called within the
             contract should be marked as external
Type:        Violation
Contract:    Ownable
Line:        325
Source: 
>      */
>     function transferOwnership(address newOwner) public onlyOwner {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _transferOwnership(newOwner);

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;33mSeverity:    HIGH
Pattern:     External call in loop
Description: If a single call in the loop fails or revers, it will
             cause all other calls to fail as well.
Type:        Warning
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Gas-dependent Reentrancy
Description: Calls into external contracts that receive all remaining
             gas and are followed by state changes may be reentrant.
Type:        Warning
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Gas-dependent Reentrancy
Description: Calls into external contracts that receive all remaining
             gas and are followed by state changes may be reentrant.
Type:        Warning
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Gas-dependent Reentrancy
Description: Calls into external contracts that receive all remaining
             gas and are followed by state changes may be reentrant.
Type:        Warning
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Gas-dependent Reentrancy
Description: Calls into external contracts that receive all remaining
             gas and are followed by state changes may be reentrant.
Type:        Warning
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    Ownable
Line:        325
Source: 
>      */
>     function transferOwnership(address newOwner) public onlyOwner {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _transferOwnership(newOwner);

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        472
Source: 
> 
>     function setRoot(bytes32 _merkleRoot) external onlyOwner {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         merkleRoot = _merkleRoot;

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        477
Source: 
> 
>     function setVestingTime(uint256 _vestingTimeInSeconds) external onlyOwner {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         vestingTimeInSeconds = _vestingTimeInSeconds;

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        498
Source: 
> 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        503
Source: 
> 
>     function getTokensByMerkleProof(bytes32[] calldata _proof, address _who, uint256 _amount) external returns(uint256) {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(!spent[_who], "User has already retrieved its tokens");

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        512
Source: 
> 
>     function getTokensByMerkleProofFrom(bytes32[] calldata _proof, bytes calldata signature, address _who, uint256 _amount) external returns(uint256) {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(!spent[_who], "User has already retrieved its tokens");

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    Ownable
Line:        325
Source: 
>      */
>     function transferOwnership(address newOwner) public onlyOwner {
>     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         _transferOwnership(newOwner);

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        472
Source: 
> 
>     function setRoot(bytes32 _merkleRoot) external onlyOwner {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         merkleRoot = _merkleRoot;

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        477
Source: 
> 
>     function setVestingTime(uint256 _vestingTimeInSeconds) external onlyOwner {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         vestingTimeInSeconds = _vestingTimeInSeconds;

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        498
Source: 
> 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        503
Source: 
> 
>     function getTokensByMerkleProof(bytes32[] calldata _proof, address _who, uint256 _amount) external returns(uint256) {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(!spent[_who], "User has already retrieved its tokens");

[0m
[0;33mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Warning
Contract:    MerkleAirdrop
Line:        512
Source: 
> 
>     function getTokensByMerkleProofFrom(bytes32[] calldata _proof, bytes calldata signature, address _who, uint256 _amount) external returns(uint256) {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         require(!spent[_who], "User has already retrieved its tokens");

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MerkleAirdrop
Line:        467
Source: 
> 
>     function setTokenContract(address _tokenAddress) external onlyOwner {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         tokenContract = IERC20(_tokenAddress);

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MerkleAirdrop
Line:        488
Source: 
> 
>     function isAddressAlreadyClaimed(address who) external view returns (bool) {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         return spent[who];

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MerkleAirdrop
Line:        467
Source: 
> 
>     function setTokenContract(address _tokenAddress) external onlyOwner {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         tokenContract = IERC20(_tokenAddress);

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Missing Input Validation
Description: Method arguments must be sanitized before they are used
             in computations.
Type:        Violation
Contract:    MerkleAirdrop
Line:        488
Source: 
> 
>     function isAddressAlreadyClaimed(address who) external view returns (bool) {
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         return spent[who];

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    MerkleAirdrop
Line:        424
Source: 
> 
>     uint public constant cap = 10000;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     bytes32 public merkleRoot;

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    MerkleAirdrop
Line:        524
Source: 
> 
>         uint _startTimestamp = startTimestamp;
>            ^^^^^^^^^^^^^^^^^^^^
>         if(_startTimestamp == 0) {

[0m
[0;31mSeverity:    INFO
Pattern:     Solidity Naming Convention
Description: Reports declarations that do not adhere to Solidity's
             naming convention.
Type:        Violation
Contract:    MerkleAirdrop
Line:        529
Source: 
>         
>         uint _cap = cap;
>            ^^^^^^^^^
>         uint256 contractDeployedTime = block.timestamp - _startTimestamp;

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    Ownable
Line:        274
Source: 
> contract Ownable is Context {
>     address private _owner;
>     ^^^^^^^^^^^^^^^^^^^^^^
> 

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        424
Source: 
> 
>     uint public constant cap = 10000;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     bytes32 public merkleRoot;

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        425
Source: 
>     uint public constant cap = 10000;
>     bytes32 public merkleRoot;
>        ^^^^^^^^^^^^^^^^^^^^^^^
>     uint256 public vestingTimeInSeconds;

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        426
Source: 
>     bytes32 public merkleRoot;
>     uint256 public vestingTimeInSeconds;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     uint256 public startTimestamp = 0;

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        427
Source: 
>     uint256 public vestingTimeInSeconds;
>     uint256 public startTimestamp = 0;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     uint256 public minimumSwapPercentage;

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        428
Source: 
>     uint256 public startTimestamp = 0;
>     uint256 public minimumSwapPercentage;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        430
Source: 
> 
>     IERC20 public tokenContract = 
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         IERC20(0x147faF8De9d8D8DAAE129B187F0D02D819126750);

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        433
Source: 
> 
>     mapping (address => bool) spent;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     event Claimed(

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    Ownable
Line:        274
Source: 
> contract Ownable is Context {
>     address private _owner;
>     ^^^^^^^^^^^^^^^^^^^^^^
> 

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        424
Source: 
> 
>     uint public constant cap = 10000;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     bytes32 public merkleRoot;

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        425
Source: 
>     uint public constant cap = 10000;
>     bytes32 public merkleRoot;
>        ^^^^^^^^^^^^^^^^^^^^^^^
>     uint256 public vestingTimeInSeconds;

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        426
Source: 
>     bytes32 public merkleRoot;
>     uint256 public vestingTimeInSeconds;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     uint256 public startTimestamp = 0;

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        427
Source: 
>     uint256 public vestingTimeInSeconds;
>     uint256 public startTimestamp = 0;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     uint256 public minimumSwapPercentage;

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        428
Source: 
>     uint256 public startTimestamp = 0;
>     uint256 public minimumSwapPercentage;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        430
Source: 
> 
>     IERC20 public tokenContract = 
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         IERC20(0x147faF8De9d8D8DAAE129B187F0D02D819126750);

[0m
[0;33mSeverity:    HIGH
Pattern:     State Variable Shadowing
Description: State variables in inherited contract should not be named
             identically to inherited variables
Type:        Warning
Contract:    MerkleAirdrop
Line:        433
Source: 
> 
>     mapping (address => bool) spent;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     event Claimed(

[0m
[0;31mSeverity:    INFO
Pattern:     State variables default visibility
Description: Visibility of state variables should be stated explicitly
Type:        Violation
Contract:    MerkleAirdrop
Line:        433
Source: 
> 
>     mapping (address => bool) spent;
>        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>     event Claimed(

[0m
[0;31mSeverity:    INFO
Pattern:     Too Many Digit Literals
Description: Usage of assembly in Solidity code is discouraged.
Type:        Violation
Contract:    MerkleAirdrop
Line:        545
Source: 
>                 .mul(percentageContractDeployedTime)
>                 .div(1000000000000)
>                         ^^^^^^^^^^^
>             ).add(minimumSwapPercentage);

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Warning
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Warning
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Warning
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Warning
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Ether Receiver
Description: The receiver of ether transfers must not be influenced by
             other transactions.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;31mSeverity:    CRITICAL
Pattern:     Transaction Order Affects Execution of Ether Transfer
Description: Ether transfers whose execution can be manipulated by
             other transactions must be inspected for unintended
             behavior.
Type:        Violation
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;33mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Warning
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;31mSeverity:    HIGH
Pattern:     Unhandled Exception
Description: The return value of statements that may return error
             values must be explicitly checked.
Type:        Violation
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    INFO
Pattern:     Uninitialized Local Variables
Description: A variable is declared but never initialized.
Type:        Violation
Contract:    ECDSA
Line:        393
Source: 
>         // these malleable signatures as well.
>         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
>                        ^
>             return address(0);

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Unrestricted Ether Flow
Description: The execution of ether flows should be restricted to an
             authorized set of users.
Type:        Warning
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Unrestricted Ether Flow
Description: The execution of ether flows should be restricted to an
             authorized set of users.
Type:        Warning
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Unrestricted Ether Flow
Description: The execution of ether flows should be restricted to an
             authorized set of users.
Type:        Warning
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Unrestricted Ether Flow
Description: The execution of ether flows should be restricted to an
             authorized set of users.
Type:        Warning
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;33mSeverity:    CRITICAL
Pattern:     Unrestricted write to storage
Description: Contract fields that can be modified by any user must be
             inspected.
Type:        Warning
Contract:    MerkleAirdrop
Line:        572
Source: 
> 
>         spent[_who] = true;
>            ^^^^^^^^^^^^^^^^
>         uint256 biQuadraticPercentage = getVestingPercentage();

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    MerkleAirdrop
Line:        494
Source: 
>         address payable payableOwner = address(uint160(owner()));
>         tokenContract.transfer(owner(), tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(payableOwner);

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    MerkleAirdrop
Line:        499
Source: 
>     function sendRestTokensAndDestruct(address payable recipient) external onlyOwner {
>         tokenContract.transfer(recipient, tokenContract.balanceOf(address(this)));
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         selfdestruct(recipient);

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    MerkleAirdrop
Line:        576
Source: 
>         uint256 mainTokensLeft = _amount.sub(mainTokensUser);
>         tokenContract.transfer(recipient, mainTokensUser);
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         if (mainTokensLeft > 0) {

[0m
[0;31mSeverity:    MEDIUM
Pattern:     Unused Return Pattern
Description: The value returned by an external function call is never
             used
Type:        Violation
Contract:    MerkleAirdrop
Line:        578
Source: 
>         if (mainTokensLeft > 0) {
>             tokenContract.transfer(owner(), mainTokensLeft);
>                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>         }

[0m
[0;31mSeverity:    LOW
Pattern:     Usage of block timestamp
Description: Returned value relies on block timestamp.
Type:        Violation
Contract:    MerkleAirdrop
Line:        483
Source: 
>     function setStartTimestamp(uint256 _startTimestamp) external onlyOwner {
>         require(_startTimestamp >= block.timestamp, 'Start timestamp can not be higher than current timestamp');
>                                       ^^^^^^^^^^^^^^^
>         startTimestamp = _startTimestamp;

[0m
[0;31mSeverity:    LOW
Pattern:     Usage of block timestamp
Description: Returned value relies on block timestamp.
Type:        Violation
Contract:    MerkleAirdrop
Line:        530
Source: 
>         uint _cap = cap;
>         uint256 contractDeployedTime = block.timestamp - _startTimestamp;
>                                           ^^^^^^^^^^^^^^^
> 

[0m
[0;31mSeverity:    LOW
Pattern:     Usage of block timestamp
Description: Returned value relies on block timestamp.
Type:        Violation
Contract:    MerkleAirdrop
Line:        483
Source: 
>     function setStartTimestamp(uint256 _startTimestamp) external onlyOwner {
>         require(_startTimestamp >= block.timestamp, 'Start timestamp can not be higher than current timestamp');
>                                       ^^^^^^^^^^^^^^^
>         startTimestamp = _startTimestamp;

[0m
[0;31mSeverity:    LOW
Pattern:     Usage of block timestamp
Description: Returned value relies on block timestamp.
Type:        Violation
Contract:    MerkleAirdrop
Line:        530
Source: 
>         uint _cap = cap;
>         uint256 contractDeployedTime = block.timestamp - _startTimestamp;
>                                           ^^^^^^^^^^^^^^^
> 

[0m
