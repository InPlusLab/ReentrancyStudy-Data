/**

 *Submitted for verification at Etherscan.io on 2019-07-01

*/



pragma solidity ^0.4.11;



/*

 * Math operations with safety checks

 */

library SafeMath {

  function mul(uint a, uint b) internal returns (uint) {

    uint c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }



  function div(uint a, uint b) internal returns (uint) {

    // assert(b > 0); // Solidity automatically throws when dividing by 0

    uint c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;

  }



  function sub(uint a, uint b) internal returns (uint) {

    assert(b <= a);

    return a - b;

  }



  function add(uint a, uint b) internal returns (uint) {

    uint c = a + b;

    assert(c >= a);

    return c;

  }



  function max64(uint64 a, uint64 b) internal constant returns (uint64) {

    return a >= b ? a : b;

  }



  function min64(uint64 a, uint64 b) internal constant returns (uint64) {

    return a < b ? a : b;

  }



  function max256(uint256 a, uint256 b) internal constant returns (uint256) {

    return a >= b ? a : b;

  }



  function min256(uint256 a, uint256 b) internal constant returns (uint256) {

    return a < b ? a : b;

  }



  function assert(bool assertion) internal {

    if (!assertion) {

      throw;

    }

  }

}



/*

 * Ownable

 *

 * Base contract with an owner.

 * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.

 */

contract Ownable {

  address public owner;



  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



  function Ownable() {

    owner = msg.sender;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  function transferOwnership(address newOwner) onlyOwner public {

    require(newOwner != address(0));

    OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



}



/*

 * ERC20 interface

 * see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 {

  uint public totalSupply;

  function balanceOf(address who) constant returns (uint);

  function allowance(address owner, address spender) constant returns (uint);



  function transfer(address to, uint value) returns (bool ok);

  function transferFrom(address from, address to, uint value) returns (bool ok);

  function approve(address spender, uint value) returns (bool ok);

  event Transfer(address indexed from, address indexed to, uint value);

  event Approval(address indexed owner, address indexed spender, uint value);

}



/*

 * A token that defines fractional units as decimals.

 */

contract FractionalERC20 is ERC20 {



  uint public decimals;



}



/**

 * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.

 *

 */

contract StandardToken is ERC20 {



  using SafeMath for uint;



  /* Token supply got increased and a new owner received these tokens */

  event Minted(address receiver, uint amount);



  /* Actual balances of token holders */

  mapping(address => uint) balances;



  /* approve() allowances */

  mapping (address => mapping (address => uint)) allowed;



  /* Interface declaration */

  function isToken() public constant returns (bool weAre) {

    return true;

  }



  function transfer(address _to, uint _value) returns (bool success) {

    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    Transfer(msg.sender, _to, _value);

    return true;

  }



  function transferFrom(address _from, address _to, uint _value) returns (bool success) {

    uint _allowance = allowed[_from][msg.sender];



    balances[_to] = balances[_to].add(_value);

    balances[_from] = balances[_from].sub(_value);

    allowed[_from][msg.sender] = _allowance.sub(_value);

    Transfer(_from, _to, _value);

    return true;

  }



  function balanceOf(address _owner) constant returns (uint balance) {

    return balances[_owner];

  }



  function approve(address _spender, uint _value) returns (bool success) {



    // To change the approve amount you first have to reduce the addresses`

    //  allowance to zero by calling `approve(_spender, 0)` if it is not

    //  already 0 to mitigate the race condition described here:

    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;



    allowed[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);

    return true;

  }



  function allowance(address _owner, address _spender) constant returns (uint remaining) {

    return allowed[_owner][_spender];

  }



  function increaseApproval (address _spender, uint _addedValue)

    returns (bool success) {

    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);

    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  }



  function decreaseApproval (address _spender, uint _subtractedValue)

    returns (bool success) {

    uint oldValue = allowed[msg.sender][_spender];

    if (_subtractedValue > oldValue) {

      allowed[msg.sender][_spender] = 0;

    } else {

      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

    }

    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  }



}



contract MintableToken is StandardToken, Ownable {



  using SafeMath for uint;



  bool public mintingFinished = false;



  /* List of agents that are allowed to create new tokens */

  mapping (address => bool) public mintAgents;



  event MintingAgentChanged(address addr, bool state  );





  /*

   * Create new tokens and allocate them to an address..

   *

   * Only callably by a crowdsale contract (mint agent).

   */

  function mint(address receiver, uint amount) onlyMintAgent canMint public {



    if(amount == 0) {

      throw;

    }



    totalSupply = totalSupply.add(amount);

    balances[receiver] = balances[receiver].add(amount);

    Transfer(0, receiver, amount);

  }



  /*

   * Owner can allow a crowdsale contract to mint new tokens.

   */

  function setMintAgent(address addr, bool state) onlyOwner canMint public {

    mintAgents[addr] = state;

    MintingAgentChanged(addr, state);

  }



  modifier onlyMintAgent() {

    // Only crowdsale contracts are allowed to mint new tokens

    if(!mintAgents[msg.sender]) {

        throw;

    }

    _;

  }



  /* Make sure we are not done yet. */

  modifier canMint() {

    if(mintingFinished) throw;

    _;

  }

}



/*

 * Define interface for releasing the token transfer after a successful crowdsale.

 */

contract ReleasableToken is ERC20, Ownable {



  /* The finalizer contract that allows unlift the transfer limits on this token */

  address public releaseAgent;



  bool public released = false;



  /* Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */

  mapping (address => bool) public transferAgents;



  /*

   * Limit token transfer until the crowdsale is over.

   *

   */

  modifier canTransfer(address _sender) {



    if(!released) {

        if(!transferAgents[_sender]) {

            throw;

        }

    }



    _;

  }



  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {



    // We don't do interface check here as we might want to a normal wallet address to act as a release agent

    releaseAgent = addr;

  }



  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {

    transferAgents[addr] = state;

  }



  function releaseTokenTransfer() public onlyReleaseAgent {

    released = true;

  }



  /* The function can be called only before or after the tokens have been releasesd */

  modifier inReleaseState(bool releaseState) {

    if(releaseState != released) {

        throw;

    }

    _;

  }



  /* The function can be called only by a whitelisted release agent. */

  modifier onlyReleaseAgent() {

    if(msg.sender != releaseAgent) {

        throw;

    }

    _;

  }



  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {

    // Call StandardToken.transfer()

   return super.transfer(_to, _value);

  }



  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {

    // Call StandardToken.transferForm()

    return super.transferFrom(_from, _to, _value);

  }



}



contract UpgradeableToken is StandardToken {



  /* Contract  person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */

  address public upgradeMaster;



  /* The next contract where the tokens will be migrated. */

  UpgradeAgent public upgradeAgent;



  /* How many tokens we have upgraded by now. */

  uint256 public totalUpgraded;



  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}



  /*

   * Somebody has upgraded some of his tokens.

   */

  event Upgrade(address indexed _from, address indexed _to, uint256 _value);



  /*

   * New upgrade agent available.

   */

  event UpgradeAgentSet(address agent);



  /*

   * Do not allow construction without upgrade master set.

   */

  function UpgradeableToken(address _upgradeMaster) {

    upgradeMaster = _upgradeMaster;

  }



  /*

   * Allow the token holder to upgrade some of their tokens to a new contract.

   */

  function upgrade(uint256 value) public {



      UpgradeState state = getUpgradeState();

      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {

        // Called in a bad state

        throw;

      }



      // Validate input value.

      if (value == 0) throw;



      balances[msg.sender] = balances[msg.sender].sub(value);



      // Take tokens out from circulation

      totalSupply = totalSupply.sub(value);

      totalUpgraded = totalUpgraded.add(value);



      // Upgrade agent reissues the tokens

      upgradeAgent.upgradeFrom(msg.sender, value);

      Upgrade(msg.sender, upgradeAgent, value);

  }



  /*

   * Set an upgrade agent that handles

   */

  function setUpgradeAgent(address agent) external {



      if(!canUpgrade()) {

        // The token is not yet in a state that we could think upgrading

        throw;

      }



      if (agent == 0x0) throw;

      // Only a master can designate the next agent

      if (msg.sender != upgradeMaster) throw;

      // Upgrade has already begun for an agent

      if (getUpgradeState() == UpgradeState.Upgrading) throw;



      upgradeAgent = UpgradeAgent(agent);



      // Bad interface

      if(!upgradeAgent.isUpgradeAgent()) throw;

      // Make sure that token supplies match in source and target

      if (upgradeAgent.originalSupply() != totalSupply) throw;



      UpgradeAgentSet(upgradeAgent);

  }



  /*

   * Get the state of the token upgrade.

   */

  function getUpgradeState() public constant returns(UpgradeState) {

    if(!canUpgrade()) return UpgradeState.NotAllowed;

    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;

    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;

    else return UpgradeState.Upgrading;

  }



  /*

   * Change the upgrade master.

   *

   * This allows us to set a new owner for the upgrade mechanism.

   */

  function setUpgradeMaster(address master) public {

      if (master == 0x0) throw;

      if (msg.sender != upgradeMaster) throw;

      upgradeMaster = master;

  }



  /*

   * Child contract can enable to provide the condition when the upgrade can begun.

   */

  function canUpgrade() public constant returns(bool) {

     return true;

  }



}



contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {



  event UpdatedTokenInformation(string newName, string newSymbol);



  string public name;



  string public symbol;



  uint public decimals;



  /*

   * Construct the token.

   *

   * This token must be created through a team multisig wallet, so that it is owned by that wallet.

   */

  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)

    UpgradeableToken(msg.sender) {



    // Create any address, can be transferred

    // to team multisig via changeOwner(),

    // also remember to call setUpgradeMaster()

    owner = msg.sender;



    name = _name;

    symbol = _symbol;



    totalSupply = _initialSupply;



    decimals = _decimals;



    // Create initially all balance on the team multisig

    balances[owner] = totalSupply;



    if(totalSupply > 0) {

      Minted(owner, totalSupply);

    }



    // No more new supply allowed after the token creation. 

    if(!_mintable) {

      mintingFinished = true;

      if(totalSupply == 0) {

        throw; // Cannot create a token without supply and no minting

      }

    }



  }



  /*

   * When token is released to be transferable, enforce no new tokens can be created.

   */

  function releaseTokenTransfer() public onlyReleaseAgent {

    mintingFinished = true;

    super.releaseTokenTransfer();

  }



  /*

   * Allow upgrade agent functionality kick in only if the crowdsale was success.

   */

  function canUpgrade() public constant returns(bool) {

    return released && super.canUpgrade();

  }



  /*

   * Owner can update token information here

   */

  function setTokenInformation(string _name, string _symbol) onlyOwner {

    name = _name;

    symbol = _symbol;



    UpdatedTokenInformation(name, symbol);

  }



}



contract TapcoinToken is CrowdsaleToken {

  function TapcoinToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)

   CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) {

  }

}



contract UpgradeAgent {



  uint public originalSupply;



  /* Interface marker */

  function isUpgradeAgent() public constant returns (bool) {

    return true;

  }



  function upgradeFrom(address _from, uint256 _value) public;



}