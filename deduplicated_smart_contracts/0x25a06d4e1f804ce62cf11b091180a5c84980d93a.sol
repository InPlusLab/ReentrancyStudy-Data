/**

 *Submitted for verification at Etherscan.io on 2019-04-17

*/



pragma solidity ^0.4.20;



/*





                                                                                                                                                            

                                                                                                                                                            

TTTTTTTTTTTTTTTTTTTTTTT                                                                                                                                     

T:::::::::::::::::::::T                                                                                                                                     

T:::::::::::::::::::::T                                                                                                                                     

T:::::TT:::::::TT:::::T                                                                                                                                     

TTTTTT  T:::::T  TTTTTTrrrrr   rrrrrrrrr       eeeeeeeeeeee      aaaaaaaaaaaaa       ssssssssss   uuuuuu    uuuuuu  rrrrr   rrrrrrrrr       eeeeeeeeeeee    

        T:::::T        r::::rrr:::::::::r    ee::::::::::::ee    a::::::::::::a    ss::::::::::s  u::::u    u::::u  r::::rrr:::::::::r    ee::::::::::::ee  

        T:::::T        r:::::::::::::::::r  e::::::eeeee:::::ee  aaaaaaaaa:::::a ss:::::::::::::s u::::u    u::::u  r:::::::::::::::::r  e::::::eeeee:::::ee

        T:::::T        rr::::::rrrrr::::::re::::::e     e:::::e           a::::a s::::::ssss:::::su::::u    u::::u  rr::::::rrrrr::::::re::::::e     e:::::e

        T:::::T         r:::::r     r:::::re:::::::eeeee::::::e    aaaaaaa:::::a  s:::::s  ssssss u::::u    u::::u   r:::::r     r:::::re:::::::eeeee::::::e

        T:::::T         r:::::r     rrrrrrre:::::::::::::::::e   aa::::::::::::a    s::::::s      u::::u    u::::u   r:::::r     rrrrrrre:::::::::::::::::e 

        T:::::T         r:::::r            e::::::eeeeeeeeeee   a::::aaaa::::::a       s::::::s   u::::u    u::::u   r:::::r            e::::::eeeeeeeeeee  

        T:::::T         r:::::r            e:::::::e           a::::a    a:::::a ssssss   s:::::s u:::::uuuu:::::u   r:::::r            e:::::::e           

      TT:::::::TT       r:::::r            e::::::::e          a::::a    a:::::a s:::::ssss::::::su:::::::::::::::uu r:::::r            e::::::::e          

      T:::::::::T       r:::::r             e::::::::eeeeeeee  a:::::aaaa::::::a s::::::::::::::s  u:::::::::::::::u r:::::r             e::::::::eeeeeeee  

      T:::::::::T       r:::::r              ee:::::::::::::e   a::::::::::aa:::a s:::::::::::ss    uu::::::::uu:::u r:::::r              ee:::::::::::::e  

      TTTTTTTTTTT       rrrrrrr                eeeeeeeeeeeeee    aaaaaaaaaa  aaaa  sssssssssss        uuuuuuuu  uuuu rrrrrrr                eeeeeeeeeeeeee  

                                                                                                                                                            

                                                                                                                                                            

                                                                                                                                                            

                                                                                                                                                            

                                                                                                                                                            

                                                                                                                                                            

                                                                                                                                                            



>>TreasureDapp worlds most unique and best decentralize application on Ethereum blockchain and powered by one of the most intelligent smart contract

that runs on a distributed computing system.



>>vitalik buterin gives idea of decentralize application.



=================INDIA is brain of worlds mathematic=========================



+++++++++++++++++Treasure ->where your Ethereum will grow<-+++++++++++++++++



\\\\\\\\\\\\\\\\\\\Code start with 0 zero and end with zero 0/////////////// 



>>>Aryabhatta was the first of the major mathematician-astronomers from the classical age of Indian mathematics and Indian astronomy<<<<<



====we believe in community growth=== 



>>"Gas" is the name for a special unit used in Ethereum. It measures how much "work" an action or set of actions takes to perform.



+++++we believe in equality++++++



>>crypro is made by Satoshi with is vision//////0xxxxxxx vision of decentralization of money and use crypto cryptography /////Bitcoin is the solution of every problem we face with fiat currency)))))



------------------ “We are products of our past, but we don't have to be prisoners of it--------------



}}}}}}we believe in transparency of Ethereum<<<<<<<<



==== algorithm is solution-------



++++smart contract with smart developers+++



/////nothing is out of A-Z & 0-9/////////



>>>.mlm change the main purpose of crypto////////where public money is in one hands]]]]]]]



>A man should never be ashamed to own he has been in the wrong, which is butsaying... that he is wiser today than he was yesterday. The only real mistake is the one from which we learn nothing. Many times what we perceive as an error or failure is actually a gift.



---but vision of TreasureDapp is true decentralizatio>>>>>where public money is 100% safe###

}}}}}}



TreasureDapp is a life time unstoppable and life time Ethereum earning programme/////



‘’==========TREASURE ethe’’’’blockchain…..used====for---dapp;;;;

सत्य -सत्यमेवेश्वरो लोके सत्ये धर्मः सदाश्रितः । सत्यमूलनि सर्वाणि सत्यान्नास्ति परं पदम् ॥

‘’’’’’’’’’’keep learning////





1 ether is 10^18 wei



1 ETH is represented by 10^18 of its natural unit (1 Ether = 1,000,000,000,000,000,000 wei).

[[[[[why Treasure is unique Ethereum blockchain decentralize application??????

**Your Tokens in Treasure is like a “TREE” just enjoy its fruits, as long as you will hold your tokens you will enjoy dividend in Ethereum and if you want to strong your “TREE” for more Ethereum just strong your tree by reinvest your dividends 

+ =no administrator and ambassador ,,>>>>

++=no reserve token for any developer,administrator,ambassador & founder////

++=no back door & public funds are safe in wallet deployed on Ethereum blockchain when no can withdraw these funds====

+++=it is not traditional dividend programme dependent only one enter/exit-----

++++=Treasure is first ever Dapp start crypto trading for dapp holders and share profit with them and it will be open source for all===

+++++=our vision is use of crypto as fiat and we are committed for this/////

++++++=anytime enter any time exit---- you are on safe platform===deal with Ethereum blockchain==

//////// Egyptian code cryptography////////

== we believe in smart contract & decentralization and that we are==

//////0xxxxxxxhashxxxxwe9xxxxxxxta12xxxxxxx0000000

=+we will grow even when people will not enter & exit in system and we are only people in universe of its kind/////

+++we understand power of 18 decimals and we used it==understand if you can>>>>>

_=on every community action you will earn===

^^sh///xxx00xxiva^^vai//shn]nav.’’’dav^^i

|||we made decentralized community|||

////////use treasure key for unlock the fortune////////////



=====================Leaders by example=======================



[[[[[[[made crypto for your generation with us]]]]]]] γ

^^^^^X00604xxxro^^ π hi79t//rsp^eth^trs^say//eth β β π yad….=bharat..**143^^^pak000xxxxshw1283^^ikaXOO

====Blockchain protection’’



=====================born for leadership=======================



^^eth^^18^^gwei^^0.00000000^^we^^the^^x000pexxople

//

#ethxooo369luc23ja01xxxxoooooooo14bojlxxxxxxxoooooooooooo



////no upline/no downline/no cross leg//no setting/no reserve token/open for all/eth/blockchain/smart contract/corporate/business/



[[[[audit report of every step by community]]]]funds are safu////////

^^^15%>>>>10%^^^^^^x000010%00^^^^5%eth/////20%>>>>>trs]]]]

!!!apl///made^^^^^smart_contart___blockchain___ethxxxxx000_safe_code

/////////code_protected-/////surxx0000\\\xxxxxxxxrat0000000000000000

^^^^9dav33kotxxxxxxxxxxxxxpitooooooedevjava///code-lock/unhack///system/





=====we are unstoppable===vision is clear====



*/



contract Treasure {

    

    /*=================================

    =            MODIFIERS            =

    =================================*/

    // only people with tokens

    modifier onlybelievers () {

        require(myTokens() > 0);

        _;

    }

    

    // only people with profits

    modifier onlyhodler() {

        require(myDividends(true) > 0);

        _;

    }

    

    // only people with sold token

    modifier onlySelingholder() {

        require(sellingWithdrawBalance_[msg.sender] > 0);

        _;

    }

    

    

    // administrators can:

    // -> change the name of the contract

    // -> change the name of the token

    // -> change the PoS difficulty 

    // they CANNOT:

    // -> take funds

    // -> disable withdrawals

    // -> kill the contract

    // -> change the price of tokens

    modifier onlyAdministrator(){

        address _customerAddress = msg.sender;

        require(administrators[keccak256(_customerAddress)]);

        _;

    }

    

    



    

    /*==============================

    =            EVENTS            =

    ==============================*/

    event onTokenPurchase(

        address indexed customerAddress,

        uint256 incomingEthereum,

        uint256 tokensMinted,

        address indexed referredBy

    );

    

    event onTokenSell(

        address indexed customerAddress,

        uint256 tokensBurned

    );

    

    event onReinvestment(

        address indexed customerAddress,

        uint256 ethereumReinvested,

        uint256 tokensMinted

    );

    

    event onWithdraw(

        address indexed customerAddress,

        uint256 ethereumWithdrawn

    );

    

    event onSellingWithdraw(

        

        address indexed customerAddress,

        uint256 ethereumWithdrawn

    

    );

    

    // ERC20

    event Transfer(

        address indexed from,

        address indexed to,

        uint256 tokens

    );

    

    

    /*=====================================

    =            CONFIGURABLES            =

    =====================================*/

    string public name = "Treasure";

    string public symbol = "TRS";

    uint8 constant public decimals = 18;

    uint8 constant internal dividendFee_ = 10;

    

    uint256 constant internal tokenPriceInitial_ = 0.000000001 ether;

    uint256 constant internal tokenPriceIncremental_ = 0.000000001 ether;



    

    

    // proof of stake (defaults at 1 token)

    uint256 public stakingRequirement = 1e18;

    

    

    

    // add community wallet here

    address internal constant CommunityWalletAddr = address(0x9E4F01bf4D6Aa5c583bcb84462e32e8a5cE6195F);

        

        //add trading wallet here

    address internal constant TradingWalletAddr = address(0xB0e9fF0C19b7147bFDeb81f0e1D3089efEc4fBCD);	 



    

    

   /*================================

    =            DATASETS            =

    ================================*/

    // amount of shares for each address (scaled number)

    mapping(address => uint256) internal tokenBalanceLedger_;

    mapping(address => uint256) internal referralBalance_;

    mapping(address => int256) internal payoutsTo_;

    mapping(address => uint256) internal sellingWithdrawBalance_;

    mapping(address => uint256) internal ambassadorAccumulatedQuota_;



    address[] private contractTokenHolderAddresses_;



    

    uint256 internal tokenSupply_ = 0;

    uint256 internal profitPerShare_;

    

    uint256 internal soldTokens_=0;

    uint256 internal contractAddresses_=0;

    uint256 internal tempIncomingEther=0;

    uint256 internal calculatedPercentage=0;

    

    

    uint256 internal tempProfitPerShare=0;

    uint256 internal tempIf=0;

    uint256 internal tempCalculatedDividends=0;

    uint256 internal tempReferall=0;

    uint256 internal tempSellingWithdraw=0;

    





    

    // administrator list (see above on what they can do)

    mapping(bytes32 => bool) public administrators;

    

    

    bool public onlyAmbassadors = false;

    





    /*=======================================

    =            PUBLIC FUNCTIONS            =

    =======================================*/

    /*

    * -- APPLICATION ENTRY POINTS --  

    */

    function Treasure()

        public

    {

        // add administrators here

           

        administrators[0x2d059f17f1d7fa6ef66aa46ab6061d07858fa96e9ed14401231e0c01510d7f1f] = true;

                     

						 

        

    }

    

     

    /**

     * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)

     */

    function buy(address _referredBy)

        public

        payable

        returns(uint256)

    {

        purchaseTokens(msg.value, _referredBy);

    }

    

    

    function()

        payable

        public

    {

        purchaseTokens(msg.value, 0x0);

    }

    

    /**

     * Converts all of caller's dividends to tokens.

     */

    function reinvest()

        onlyhodler()

        public

    {

        address _customerAddress = msg.sender;



        // fetch dividends

        uint256 _dividends = myDividends(true); // retrieve ref. bonus later in the code

        

         //calculate  10 % for distribution 

        uint256  ten_percentForDistribution= SafeMath.percent(_dividends,10,100,18);



         //calculate  90 % to reinvest into tokens

        uint256  nighty_percentToReinvest= SafeMath.percent(_dividends,90,100,18);

        

        

        // dispatch a buy order with the calculatedPercentage 

        uint256 _tokens = purchaseTokens(nighty_percentToReinvest, 0x0);

        

        

        //Empty their  all dividends beacuse we are reinvesting them

         payoutsTo_[_customerAddress]=0;

         referralBalance_[_customerAddress]=0;

        

    

     

      //distribute to all as per holdings         

        profitPerShareAsPerHoldings(ten_percentForDistribution);

        

        // fire event

        onReinvestment(_customerAddress, _dividends, _tokens);

    }

    

    /**

     * Alias of sell() and withdraw().

     */

    function exit()

        public

    {

        // get token count for caller & sell them all

        address _customerAddress = msg.sender;

        uint256 _tokens = tokenBalanceLedger_[_customerAddress];

        if(_tokens > 0) sell(_tokens);

        

        

        withdraw();

    }



    /**

     * Withdraws all of the callers earnings.

     */

    function withdraw()

        onlyhodler()

        public

    {

        // setup data

        address _customerAddress = msg.sender;

        

        //calculate 20 % of all Dividends and transfer them to two communities

        //10% to community wallet

        //10% to trading wallet

        

        uint256 _dividends = myDividends(true); // get all dividends

        

        //calculate  10 % for trending wallet

        uint256  ten_percentForTradingWallet= SafeMath.percent(_dividends,10,100,18);



        //calculate 10 % for community wallet

         uint256 ten_percentForCommunityWallet= SafeMath.percent(_dividends,10,100,18);



        

        //Empty their  all dividends beacuse we are reinvesting them

         payoutsTo_[_customerAddress]=0;

         referralBalance_[_customerAddress]=0;

       

         // delivery service

        CommunityWalletAddr.transfer(ten_percentForCommunityWallet);

        

         // delivery service

        TradingWalletAddr.transfer(ten_percentForTradingWallet);

        

        //calculate 80% to tranfer it to customer address

         uint256 eighty_percentForCustomer= SafeMath.percent(_dividends,80,100,18);



       

        // delivery service

        _customerAddress.transfer(eighty_percentForCustomer);

        

        // fire event

        onWithdraw(_customerAddress, _dividends);

    }

    

     /**

     * Withdrawa all selling Withdraw of the callers earnings.

     */

    function sellingWithdraw()

        onlySelingholder()

        public

    {

        // setup data

        address _customerAddress = msg.sender;

        



        uint256 _sellingWithdraw = sellingWithdrawBalance_[_customerAddress] ; // get all balance

        



        //Empty  all sellingWithdraw beacuse we are giving them ethers

         sellingWithdrawBalance_[_customerAddress]=0;



     

        // delivery service

        _customerAddress.transfer(_sellingWithdraw);

        

        // fire event

        onSellingWithdraw(_customerAddress, _sellingWithdraw);

    }

    

    

    

     /**

     * Sell tokens.

     * Remember, there's a 10% fee here as well.

     */

    function sell(uint256 _amountOfTokens)

        onlybelievers ()

        public

    {

      

        address _customerAddress = msg.sender;

       

        //calculate 10 % of tokens and distribute them 

        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);

        uint256 _tokens = _amountOfTokens;

      

       uint256 _ethereum = tokensToEthereum_(_tokens);

        

          //calculate  10 % for distribution 

       uint256  ten_percentToDistributet= SafeMath.percent(_ethereum,10,100,18);



          //calculate  90 % for customer withdraw wallet

        uint256  nighty_percentToCustomer= SafeMath.percent(_ethereum,90,100,18);

        

        // burn the sold tokens

        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);

        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);

        

        //substract sold token from circulations of tokenSupply_

        soldTokens_=SafeMath.sub(soldTokens_,_tokens);

        

        // update sellingWithdrawBalance of customer 

       sellingWithdrawBalance_[_customerAddress] += nighty_percentToCustomer;       

        

       

        //distribute to all as per holdings         

       profitPerShareAsPerHoldings(ten_percentToDistributet);

      

      

        

        // fire event

        onTokenSell(_customerAddress, _tokens);

        

    }

    

    

    /**

     * Transfer tokens from the caller to a new holder.

     * Remember, there's a 5% fee here as well.

     */

    function transfer(address _toAddress, uint256 _amountOfTokens)

        onlybelievers ()

        public

        returns(bool)

    {

        // setup

        address _customerAddress = msg.sender;

        

        // make sure we have the requested tokens

     

        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);

      

        //calculate 5 % of total tokens calculate Tokens Received

        uint256  five_percentOfTokens= SafeMath.percent(_amountOfTokens,5,100,18);

        

       

       //calculate 95 % of total tokens calculate Tokens Received

        uint256  nightyFive_percentOfTokens= SafeMath.percent(_amountOfTokens,95,100,18);

        

        

        // burn the fee tokens

        //convert ethereum to tokens

        tokenSupply_ = SafeMath.sub(tokenSupply_,five_percentOfTokens);

        

        //substract five percent from communiity of tokens

        soldTokens_=SafeMath.sub(soldTokens_, five_percentOfTokens);



        // exchange tokens

        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);

        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], nightyFive_percentOfTokens) ;

        



        //calculate value of all token to transfer to ethereum

        uint256 five_percentToDistribute = tokensToEthereum_(five_percentOfTokens);





        //distribute to all as per holdings         

        profitPerShareAsPerHoldings(five_percentToDistribute);



        // fire event

        Transfer(_customerAddress, _toAddress, nightyFive_percentOfTokens);

        

        

        return true;

       

    }

    

    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/

    /**

     * administrator can manually disable the ambassador phase.

     */

    function disableInitialStage()

        onlyAdministrator()

        public

    {

        onlyAmbassadors = false;

    }

    

   

    function setAdministrator(bytes32 _identifier, bool _status)

        onlyAdministrator()

        public

    {

        administrators[_identifier] = _status;

    }

    

   

    function setStakingRequirement(uint256 _amountOfTokens)

        onlyAdministrator()

        public

    {

        stakingRequirement = _amountOfTokens;

    }

    

    

    function setName(string _name)

        onlyAdministrator()

        public

    {

        name = _name;

    }

    

   

    function setSymbol(string _symbol)

        onlyAdministrator()

        public

    {

        symbol = _symbol;

    }



    

    /*----------  HELPERS AND CALCULATORS  ----------*/

    /**

     * Method to view the current Ethereum stored in the contract

     * Example: totalEthereumBalance()

     */

    function totalEthereumBalance()

        public

        view

        returns(uint)

    {

        return this.balance;

    }

    

    /**

     * Retrieve the total token supply.

     */

    function totalSupply()

        public

        view

        returns(uint256)

    {

        return tokenSupply_;

    }

    

    /**

     * Retrieve the tokens owned by the caller.

     */

    function myTokens()

        public

        view

        returns(uint256)

    {

        address _customerAddress = msg.sender;

        return balanceOf(_customerAddress);

    }

    

    /**

     * Retrieve the sold tokens .

     */

    function soldTokens()

        public

        view

        returns(uint256)

    {



        return soldTokens_;

    }

    

    

    

    

    /**

     * Retrieve the dividends owned by the caller.

       */ 

    function myDividends(bool _includeReferralBonus) 

        public 

        view 

        returns(uint256)

    {

        address _customerAddress = msg.sender;

       return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;



    }

    

    /**

     * Retrieve the token balance of any single address.

     */

    function balanceOf(address _customerAddress)

        view

        public

        returns(uint256)

    {

        return tokenBalanceLedger_[_customerAddress];

    }

    

    /**

     * Retrieve the selingWithdraw balance of address.

     */

    function selingWithdrawBalance()

        view

        public

        returns(uint256)

    {

        address _customerAddress = msg.sender;

         

        uint256 _sellingWithdraw = (uint256) (sellingWithdrawBalance_[_customerAddress]) ; // get all balance

        

        return  _sellingWithdraw;

    }

    

    /**

     * Retrieve the dividend balance of any single address.

     */

    function dividendsOf(address _customerAddress)

        view

        public

        returns(uint256)

    {

     

        return  (uint256) (payoutsTo_[_customerAddress]) ;



        

    }

    

    /**

     * Return the buy price of 1 individual token.

     */

    function sellPrice() 

        public 

        view 

        returns(uint256)

    {

       

        if(tokenSupply_ == 0){

            return tokenPriceInitial_ - tokenPriceIncremental_;

        } else {

            uint256 _ethereum = tokensToEthereum_(1e18);

            

            return _ethereum - SafeMath.percent(_ethereum,15,100,18);

        }

    }

    

    /**

     * Return the sell price of 1 individual token.

     */

    function buyPrice() 

        public 

        view 

        returns(uint256)

    {

        

        if(tokenSupply_ == 0){

            return tokenPriceInitial_ ;

        } else {

            uint256 _ethereum = tokensToEthereum_(1e18);

           

           

            return _ethereum;

        }

    }

    

   

    /**

     * Function to calculate actual value after Taxes

     */

    function calculateTokensReceived(uint256 _ethereumToSpend) 

        public 

        view 

        returns(uint256)

    {

         //calculate  15 % for distribution 

        uint256  fifteen_percentToDistribute= SafeMath.percent(_ethereumToSpend,15,100,18);



        uint256 _dividends = SafeMath.sub(_ethereumToSpend, fifteen_percentToDistribute);

        uint256 _amountOfTokens = ethereumToTokens_(_dividends);

        

        return _amountOfTokens;

    }

    

    

   

   

    function calculateEthereumReceived(uint256 _tokensToSell) 

        public 

        view 

        returns(uint256)

    {

        require(_tokensToSell <= tokenSupply_);

        

        uint256 _ethereum = tokensToEthereum_(_tokensToSell);

        

         //calculate  10 % for distribution 

        uint256  ten_percentToDistribute= SafeMath.percent(_ethereum,10,100,18);

        

        uint256 _dividends = SafeMath.sub(_ethereum, ten_percentToDistribute);



        return _dividends;



    }

    

    

    /*==========================================

    =            INTERNAL FUNCTIONS            =

    ==========================================*/

    

    

    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)

        internal

        returns(uint256)

    {

        // data setup

        address _customerAddress = msg.sender;

        

        //check if address 

        tempIncomingEther=_incomingEthereum;

        

                bool isFound=false;

                

                for(uint k=0;k<contractTokenHolderAddresses_.length;k++){

                    

                    if(contractTokenHolderAddresses_[k] ==_customerAddress){

                        

                     isFound=true;

                    break;

                        

                    }

                }

    

    

        if(!isFound){

        

            //increment address to keep track of no of users in smartcontract

            contractAddresses_+=1;  

            

            contractTokenHolderAddresses_.push(_customerAddress);

                        

            }

    

     //calculate 85 percent

      calculatedPercentage= SafeMath.percent(_incomingEthereum,85,100,18);

      

      uint256 _amountOfTokens = ethereumToTokens_(SafeMath.percent(_incomingEthereum,85,100,18));    



        // we can't give people infinite ethereum

        if(tokenSupply_ > 0){

            

            // add tokens to the pool

            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);

 

        

        

        } else {

            // add tokens to the pool

            tokenSupply_ = _amountOfTokens;

        }

        

        // update circulating supply & the ledger address for the customer

        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);

        

        

        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));

        

        // is the user referred by a Treasure Key?

        if(

            // is this a referred purchase?

            _referredBy != 0x0000000000000000000000000000000000000000 &&



            // no cheating!

            _referredBy != _customerAddress &&

            

            // does the referrer have at least X whole tokens?

            // i.e is the referrer a godly chad masternode

            tokenBalanceLedger_[_referredBy] >= stakingRequirement

            

        ){

           

     // give 5 % to referral

     referralBalance_[_referredBy]+= SafeMath.percent(_incomingEthereum,5,100,18);

     

     tempReferall+=SafeMath.percent(_incomingEthereum,5,100,18);

     

     if(contractAddresses_>0){

         

     profitPerShareAsPerHoldings(SafeMath.percent(_incomingEthereum,10,100,18));

    

    

       

     }

     

    } else {

          

     

     if(contractAddresses_>0){

    

     profitPerShareAsPerHoldings(SafeMath.percent(_incomingEthereum,15,100,18));



 

        

     }

            

        }

        

      

    



        

        // fire event

        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);

        

        //calculate sold tokens here

        soldTokens_+=_amountOfTokens;

        

        return _amountOfTokens;

    }



   

     

   /**

     * Calculate Token price based on an amount of incoming ethereum

     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;

     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.

     */

     

    function ethereumToTokens_(uint256 _ethereum)

        internal

        view

        returns(uint256)

    {

        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;

        uint256 _tokensReceived = 

         (

            (

                // underflow attempts BTFO

                SafeMath.sub(

                    (sqrt

                        (

                            (_tokenPriceInitial**2)

                            +

                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))

                            +

                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))

                            +

                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)

                        )

                    ), _tokenPriceInitial

                )

            )/(tokenPriceIncremental_)

        )-(tokenSupply_)

        ;

  

        return _tokensReceived;

    }

    

    /**

     * Calculate token sell value.

          */

     function tokensToEthereum_(uint256 _tokens)

        internal

        view

        returns(uint256)

    {



        uint256 tokens_ = (_tokens + 1e18);

        uint256 _tokenSupply = (tokenSupply_ + 1e18);

        uint256 _etherReceived =

        (

            // underflow attempts BTFO

            SafeMath.sub(

                (

                    (

                        (

                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))

                        )-tokenPriceIncremental_

                    )*(tokens_ - 1e18)

                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2

            )

        /1e18);

        return _etherReceived;

    }

    

    //calculate profitPerShare as per holdings

    function profitPerShareAsPerHoldings(uint256 calculatedDividend)  internal {

    

       //calculate number of token 

       uint256 noOfTokens_;

        tempCalculatedDividends=calculatedDividend;



       for(uint i=0;i<contractTokenHolderAddresses_.length;i++){

         

         noOfTokens_+= tokenBalanceLedger_[contractTokenHolderAddresses_[i]];



        }

        

        //check if self token balance is zero then distribute to others as per holdings

        

    for(uint k=0;k<contractTokenHolderAddresses_.length;k++){

        

        if(noOfTokens_>0 && tokenBalanceLedger_[contractTokenHolderAddresses_[k]]!=0){

       



           profitPerShare_=SafeMath.percent(calculatedDividend,tokenBalanceLedger_[contractTokenHolderAddresses_[k]],noOfTokens_,18);

         

           tempProfitPerShare=profitPerShare_;



           payoutsTo_[contractTokenHolderAddresses_[k]] += (int256) (profitPerShare_) ;

           

           tempIf=1;



            

        }else if(noOfTokens_==0 && tokenBalanceLedger_[contractTokenHolderAddresses_[k]]==0){

            

            tempIf=2;

            tempProfitPerShare=profitPerShare_;



            payoutsTo_[contractTokenHolderAddresses_[k]] += (int256) (calculatedDividend) ;

        

            

        }

        

      }

        

        

    

        



    

    }

    

    //calculate square root

    function sqrt(uint x) internal pure returns (uint y) {

        uint z = (x + 1) / 2;

        y = x;

        while (z < y) {

            y = z;

            z = (x / z + z) / 2;

        }

    }

}



/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {

    

    function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(/*uint division,*/uint quotient) {



         // caution, check safe-to-multiply here

        uint _numerator  = numerator * 10 ** (precision+1);

        // with rounding of last digit

        uint _quotient =  ((_numerator / denominator) + 5) / 10;

        

       // uint division_=numerator/denominator;

        /* value*division_,*/

        return (value*_quotient/1000000000000000000);

  }





    

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        }

        uint256 c = a * b;

        assert(c / a == b);

        return c;

    }



   

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // assert(b > 0); // Solidity automatically throws when dividing by 0

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;

    }



    

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        assert(b <= a);

        return a - b;

    }



   

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        assert(c >= a);

        return c;

    }





    

}