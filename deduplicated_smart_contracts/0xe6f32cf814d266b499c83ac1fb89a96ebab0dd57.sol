/**

 *Submitted for verification at Etherscan.io on 2019-03-05

*/



//File: node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol

pragma solidity ^0.4.21;





/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

  address public owner;





  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  function Ownable() public {

    owner = msg.sender;

  }



  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param newOwner The address to transfer ownership to.

   */

  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



}



//File: node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol

pragma solidity ^0.4.21;





/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {

    if (a == 0) {

      return 0;

    }

    c = a * b;

    assert(c / a == b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    // assert(b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return a / b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {

    c = a + b;

    assert(c >= a);

    return c;

  }

}



//File: contracts/tokens/SuntoshiToken.sol

/**

 * @title Suntoshi Token

 * MiniMe Token with a subset of features. ERC20 Compliant

 * @version 1.0



 */

pragma solidity ^0.4.21;









contract ApproveAndCallFallBack {

    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;

}



contract SuntoshiToken is Ownable {

    using SafeMath for uint256;



    string public constant name = "Suntoshi Token";

    string public constant symbol = "SUNTO";

    uint8 public constant decimals = 18;

    string public version = "SUNTO_0.1";



    /**

    * @dev `Checkpoint` is the structure that attaches a block number to a

    * given value, the block number attached is the one that last changed the value

    */

    struct Checkpoint {

        // `fromBlock` is the block number that the value was generatedsuper.mint(_to, _amount); from

        uint128 fromBlock;

        // `value` is the amount of tokens at a specific block number

        uint128 value;

    }

    // Tracks the history of the `totalSupply` of the token

    Checkpoint[] totalSupplyHistory;



    // `creationBlock` is the block number that the Clone Token was created

    uint256 public creationBlock;



    // `balances` is the map that tracks the balance of each address, in this

    //  contract when the balance changes the block number that the change

    //  occurred is also included in the map

    mapping (address => Checkpoint[]) balances;



    // `allowed` tracks any extra transfer rights as in all ERC20 tokens

    mapping (address => mapping (address => uint256)) allowed;



    // Flag that determines if the token is transferable or not.

    bool public transfersEnabled;



    ////////////////

    // Events

    ////////////////

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);



    /**

     * @dev Constructor of SuntoshiToken that instantiates a new MiniMe inspired ERC20 token

     */

    function SuntoshiToken() public {

        // token should not be transferrable until after all tokens have been issued

        transfersEnabled = false;

        creationBlock = block.number;

    }



    ///////////////////

    // ERC20 Methods

    ///////////////////



    /// @notice Send `_amount` tokens to `_to` from `msg.sender`

    /// @param _to The address of the recipient

    /// @param _amount The amount of tokens to be transferred

    /// @return Whether the transfer was successful or not

    function transfer(address _to, uint256 _amount) public returns (bool success) {

        require(transfersEnabled);

        doTransfer(msg.sender, _to, _amount);

        return true;

    }



    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it

    ///  is approved by `_from`

    /// @param _from The address holding the tokens being transferred

    /// @param _to The address of the recipient

    /// @param _amount The amount of tokens to be transferred

    /// @return True if the transfer was successful

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {



        // The controller of this contract can move tokens around at will,

        //  this is important to recognize! Confirm that you trust the

        //  controller of this contract, which in most situations should be

        //  another open source smart contract or 0x0

        if (msg.sender != owner) {

            require(transfersEnabled);



            // The standard ERC 20 transferFrom functionality

            require(allowed[_from][msg.sender] >= _amount);

            allowed[_from][msg.sender] -= _amount;

        }

        doTransfer(_from, _to, _amount);

        return true;

    }



    /// @dev This is the actual transfer function in the token contract, it can

    ///  only be called by other functions in this contract.

    /// @param _from The address holding the tokens being transferred

    /// @param _to The address of the recipient

    /// @param _amount The amount of tokens to be transferred

    /// @return True if the transfer was successful

    function doTransfer(address _from, address _to, uint256 _amount) internal {

        if (_amount == 0) {

            emit Transfer(_from, _to, _amount);    // Follow the spec to louch the event when transfer 0

            return;

        }



        // Do not allow transfer to the token contract itself - Matt: modified to allow sending to to address(0)

        require((_to != address(this)));



        // If the amount being transfered is more than the balance of the

        //  account the transfer throws

        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);



        require(previousBalanceFrom >= _amount);



        // First update the balance array with the new value for the address

        //  sending the tokens

        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);



        // Then update the balance array with the new value for the address

        //  receiving the tokens

        uint256 previousBalanceTo = balanceOfAt(_to, block.number);

        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow

        updateValueAtNow(balances[_to], previousBalanceTo + _amount);



        // An event to make the transfer easy to find on the blockchain

        emit Transfer(_from, _to, _amount);

    }



    /// @param _owner The address that's balance is being requested

    /// @return The balance of `_owner` at the current block

    function balanceOf(address _owner) public constant returns (uint256 balance) {

        return balanceOfAt(_owner, block.number);

    }



    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on

    ///  its behalf. This is a modified version of the ERC20 approve function

    ///  to be a little bit safer

    /// @param _spender The address of the account able to transfer the tokens

    /// @param _amount The amount of tokens to be approved for transfer

    /// @return True if the approval was successful

    function approve(address _spender, uint256 _amount) public returns (bool success) {

        require(transfersEnabled);



        // To change the approve amount you first have to reduce the addresses`

        //  allowance to zero by calling `approve(_spender,0)` if it is not

        //  already 0 to mitigate the race condition described here:

        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));



        allowed[msg.sender][_spender] = _amount;

        emit Approval(msg.sender, _spender, _amount);

        return true;

    }



    /// @dev This function makes it easy to read the `allowed[]` map

    /// @param _owner The address of the account that owns the token

    /// @param _spender The address of the account able to transfer the tokens

    /// @return Amount of remaining tokens of _owner that _spender is allowed

    ///  to spend

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }



    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on

    ///  its behalf, and then a function is triggered in the contract that is

    ///  being approved, `_spender`. This allows users to use their tokens to

    ///  interact with contracts in one function call instead of two

    /// @param _spender The address of the contract able to transfer the tokens

    /// @param _amount The amount of tokens to be approved for transfer

    /// @return True if the function call was successful

    function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {

        require(approve(_spender, _amount));



        ApproveAndCallFallBack(_spender).receiveApproval(

            msg.sender,

            _amount,

            this,

            _extraData

        );



        return true;

    }



    /// @dev This function makes it easy to get the total number of tokens

    /// @return The total number of tokens

    function totalSupply() public constant returns (uint256) {

        return totalSupplyAt(block.number);

    }



    ////////////////

    // Query balance and totalSupply in History

    ////////////////



    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`

    /// @param _owner The address from which the balance will be retrieved

    /// @param _blockNumber The block number when the balance is queried

    /// @return The balance at `_blockNumber`

    function balanceOfAt(address _owner, uint256 _blockNumber) public constant returns (uint256) {



        // These next few lines are used when the balance of the token is

        //  requested before a check point was ever created for this token, it

        //  requires that the `parentToken.balanceOfAt` be queried at the

        //  genesis block for that token as this contains initial balance of

        //  this token

        if ((balances[_owner].length == 0)|| (balances[_owner][0].fromBlock > _blockNumber)) {

            return 0;

        // This will return the expected balance during normal situations

        } else {

            return getValueAt(balances[_owner], _blockNumber);

        }

    }



    /// @notice Total amount of tokens at a specific `_blockNumber`.

    /// @param _blockNumber The block number when the totalSupply is queried

    /// @return The total amount of tokens at `_blockNumber`

    function totalSupplyAt(uint256 _blockNumber) public constant returns(uint256) {



        // These next few lines are used when the totalSupply of the token is

        //  requested before a check point was ever created for this token, it

        //  requires that the `parentToken.totalSupplyAt` be queried at the

        //  genesis block for this token as that contains totalSupply of this

        //  token at this block number.

        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {

            return 0;

        // This will return the expected totalSupply during normal situations

        } else {

            return getValueAt(totalSupplyHistory, _blockNumber);

        }

    }



    ////////////////

    // Generate and destroy tokens

    ////////////////



    /**

    * @dev Generates `_amount` tokens that are assigned to `_owner`

    * @param _owner The address that will be assigned the new tokens

    * @param _amount The quantity of tokens generated

    * @return True if the tokens are generated correctly

    */

    function generateTokens(address _owner, uint256 _amount) public onlyOwner returns (bool) {

        uint256 curTotalSupply = totalSupply();

        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow

        uint256 previousBalanceTo = balanceOf(_owner);

        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow

        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);

        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);

        emit Transfer(0, _owner, _amount);

        return true;

    }



    /// @notice Burns `_amount` tokens from `_owner`

    /// @param _owner The address that will lose the tokens

    /// @param _amount The quantity of tokens to burn

    /// @return True if the tokens are burned correctly

    function destroyTokens(address _owner, uint256 _amount) onlyOwner public returns (bool) {

        uint256 curTotalSupply = totalSupply();

        require(curTotalSupply >= _amount);

        uint256 previousBalanceFrom = balanceOf(_owner);

        require(previousBalanceFrom >= _amount);

        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);

        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);

        emit Transfer(_owner, 0, _amount);

        return true;

    }



    ////////////////

    // Enable tokens transfers

    ////////////////



    /// @notice Enables token holders to transfer their tokens freely if true

    /// @param _transfersEnabled True if transfers are allowed in the clone

    function enableTransfers(bool _transfersEnabled) public onlyOwner {

        transfersEnabled = _transfersEnabled;

    }



    ////////////////

    // Internal helper functions to query and set a value in a snapshot array

    ////////////////



    /**

    * @dev `getValueAt` retrieves the number of tokens at a given block number

    * @param checkpoints The history of values being queried

    * @param _block The block number to retrieve the value at

    * @return The number of tokens being queried

    */

    function getValueAt(Checkpoint[] storage checkpoints, uint256 _block) constant internal returns (uint256) {

        if (checkpoints.length == 0) return 0;



        // Shortcut for the actual value

        if (_block >= checkpoints[checkpoints.length-1].fromBlock)

            return checkpoints[checkpoints.length-1].value;

        if (_block < checkpoints[0].fromBlock) return 0;



        // Binary search of the value in the array

        uint256 min = 0;

        uint256 max = checkpoints.length-1;

        while (max > min) {

            uint256 mid = (max + min + 1)/ 2;

            if (checkpoints[mid].fromBlock<=_block) {

                min = mid;

            } else {

                max = mid-1;

            }

        }

        return checkpoints[min].value;

    }



    /// @dev `updateValueAtNow` used to update the `balances` map and the

    ///  `totalSupplyHistory`

    /// @param checkpoints The history of data being updated

    /// @param _value The new number of tokens

    function updateValueAtNow(Checkpoint[] storage checkpoints, uint256 _value

    ) internal  {

        if ((checkpoints.length == 0)

        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {

               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];

               newCheckPoint.fromBlock =  uint128(block.number);

               newCheckPoint.value = uint128(_value);

           } else {

               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];

               oldCheckPoint.value = uint128(_value);

           }

    }

}