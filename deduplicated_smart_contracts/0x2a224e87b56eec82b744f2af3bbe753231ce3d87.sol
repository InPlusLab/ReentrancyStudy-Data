/**

 *Submitted for verification at Etherscan.io on 2019-02-08

*/



/**

 * Copyright (c) 2018-present, Leap DAO (leapdao.org)

 *

 * This source code is licensed under the Mozilla Public License, version 2,

 * found in the LICENSE file in the root directory of this source tree.

 */



pragma solidity 0.5.2;





/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * @notice Renouncing to ownership will leave the contract without an owner.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}

pragma solidity ^0.5.0;



/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

interface IERC20 {

    function transfer(address to, uint256 value) external returns (bool);



    function approve(address spender, uint256 value) external returns (bool);



    function transferFrom(address from, address to, uint256 value) external returns (bool);



    function totalSupply() external view returns (uint256);



    function balanceOf(address who) external view returns (uint256);



    function allowance(address owner, address spender) external view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);

}



/**

 * Copyright (c) 2018-present, Leap DAO (leapdao.org)

 *

 * This source code is licensed under the Mozilla Public License, version 2,

 * found in the LICENSE file in the root directory of this source tree.

 */





pragma solidity 0.5.2;



/**

 * @title Proxy

 * @dev Implements delegation of calls to other contracts, with proper

 * forwarding of return values and bubbling of failures.

 * It defines a fallback function that delegates all calls to the address

 * returned by the abstract _implementation() internal function.

 */

contract Proxy {

  /**

   * @dev Fallback function.

   * Implemented entirely in `_fallback`.

   */

  function () external payable {

    _fallback();

  }



  /**

   * @return The Address of the implementation.

   */

  function _implementation() internal view returns (address);



  /**

   * @dev Delegates execution to an implementation contract.

   * This is a low level function that doesn't return to its internal call site.

   * It will return to the external caller whatever the implementation returns.

   * @param implementation Address to delegate.

   */

  function _delegate(address implementation) internal {

    assembly {

      // Copy msg.data. We take full control of memory in this inline assembly

      // block because it will not return to Solidity code. We overwrite the

      // Solidity scratch pad at memory position 0.

      calldatacopy(0, 0, calldatasize)



      // Call the implementation.

      // out and outsize are 0 because we don't know the size yet.

      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)



      // Copy the returned data.

      returndatacopy(0, 0, returndatasize)



      switch result

      // delegatecall returns 0 on error.

      case 0 { revert(0, returndatasize) }

      default { return(0, returndatasize) }

    }

  }



  /**

   * @dev Function that is run as the first thing in the fallback function.

   * Can be redefined in derived contracts to add functionality.

   * Redefinitions must call super._willFallback().

   */

  function _willFallback() internal {

  }



  /**

   * @dev fallback implementation.

   * Extracted to enable manual triggering.

   */

  function _fallback() internal {

    _willFallback();

    _delegate(_implementation());

  }

}



/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



/**

 * @title UpgradeabilityProxy

 * @dev This contract implements a proxy that allows to change the

 * implementation address to which it will delegate.

 * Such a change is called an implementation upgrade.

 */

contract UpgradeabilityProxy is Proxy {

  /**

   * @dev Emitted when the implementation is upgraded.

   * @param implementation Address of the new implementation.

   */

  event Upgraded(address indexed implementation);



  /**

   * @dev Storage slot with the address of the current implementation.

   * This is the keccak-256 hash of "org.zeppelinos.proxy.implementation", and is

   * validated in the constructor.

   */

  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;



  /**

   * @dev Contract constructor.

   * @param _implementation Address of the initial implementation.

   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.

   * It should include the signature and the parameters of the function to be called, as described in

   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.

   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.

   */

  constructor(address _implementation, bytes memory _data) public payable {

    assert(IMPLEMENTATION_SLOT == keccak256("org.zeppelinos.proxy.implementation"));

    _setImplementation(_implementation);

    if (_data.length > 0) {

      bool rv;

      (rv,) = _implementation.delegatecall(_data);

      require(rv);

    }

  }



  /**

   * @dev Returns the current implementation.

   * @return Address of the current implementation

   */

  function _implementation() internal view returns (address impl) {

    bytes32 slot = IMPLEMENTATION_SLOT;

    assembly {

      impl := sload(slot)

    }

  }



  /**

   * @dev Upgrades the proxy to a new implementation.

   * @param newImplementation Address of the new implementation.

   */

  function _upgradeTo(address newImplementation) internal {

    _setImplementation(newImplementation);

    emit Upgraded(newImplementation);

  }



  /**

   * @dev Sets the implementation address of the proxy.

   * @param newImplementation Address of the new implementation.

   */

  function _setImplementation(address newImplementation) private {

    require(Address.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");



    bytes32 slot = IMPLEMENTATION_SLOT;



    assembly {

      sstore(slot, newImplementation)

    }

  }

}



/**

 * @title AdminUpgradeabilityProxy

 * @dev This contract combines an upgradeability proxy with an authorization

 * mechanism for administrative tasks.

 * All external functions in this contract must be guarded by the

 * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity

 * feature proposal that would enable this to be done automatically.

 */

contract AdminUpgradeabilityProxy is UpgradeabilityProxy {

  /**

   * @dev Emitted when the administration has been transferred.

   * @param previousAdmin Address of the previous admin.

   * @param newAdmin Address of the new admin.

   */

  event AdminChanged(address previousAdmin, address newAdmin);



  /**

   * @dev Storage slot with the admin of the contract.

   * This is the keccak-256 hash of "org.zeppelinos.proxy.admin", and is

   * validated in the constructor.

   */

  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;



  /**

   * @dev Modifier to check whether the `msg.sender` is the admin.

   * If it is, it will run the function. Otherwise, it will delegate the call

   * to the implementation.

   */

  modifier ifAdmin() {

    if (msg.sender == _admin()) {

      _;

    } else {

      _fallback();

    }

  }



  /**

   * Contract constructor.

   * It sets the `msg.sender` as the proxy administrator.

   * @param _implementation address of the initial implementation.

   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.

   * It should include the signature and the parameters of the function to be called, as described in

   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.

   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.

   */

  constructor(address _implementation, bytes memory _data) UpgradeabilityProxy(_implementation, _data) public payable {

    assert(ADMIN_SLOT == keccak256("org.zeppelinos.proxy.admin"));



    _setAdmin(msg.sender);

  }



  /**

   * @return The address of the proxy admin.

   */

  function admin() external ifAdmin returns (address) {

    return _admin();

  }



  /**

   * @return The address of the implementation.

   */

  function implementation() external ifAdmin returns (address) {

    return _implementation();

  }



  /**

   * @dev Changes the admin of the proxy.

   * Only the current admin can call this function.

   * @param newAdmin Address to transfer proxy administration to.

   */

  function changeAdmin(address newAdmin) external ifAdmin {

    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");

    emit AdminChanged(_admin(), newAdmin);

    _setAdmin(newAdmin);

  }



  /**

   * @dev Upgrade the backing implementation of the proxy.

   * Only the admin can call this function.

   * @param newImplementation Address of the new implementation.

   */

  function upgradeTo(address newImplementation) external ifAdmin {

    _upgradeTo(newImplementation);

  }



  /**

   * @dev Upgrade the backing implementation of the proxy and call a function

   * on the new implementation.

   * This is useful to initialize the proxied contract.

   * @param newImplementation Address of the new implementation.

   * @param data Data to send as msg.data in the low level call.

   * It should include the signature and the parameters of the function to be called, as described in

   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.

   */

  function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {

    _upgradeTo(newImplementation);

    bool rv;

    (rv,) = newImplementation.delegatecall(data);

    require(rv);

  }



  /**

   * @return The admin slot.

   */

  function _admin() internal view returns (address adm) {

    bytes32 slot = ADMIN_SLOT;

    assembly {

      adm := sload(slot)

    }

  }



  /**

   * @dev Sets the address of the proxy admin.

   * @param newAdmin Address of the new proxy admin.

   */

  function _setAdmin(address newAdmin) internal {

    bytes32 slot = ADMIN_SLOT;



    assembly {

      sstore(slot, newAdmin)

    }

  }



  /**

   * @dev Only fall back when the sender is not the admin.

   */

  function _willFallback() internal {

    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");

    super._willFallback();

  }

}



/**

 * @title AdminUpgradeabilityProxy

 * @dev This contract combines an upgradeability proxy with an authorization

 * mechanism for administrative tasks.

 * All external functions in this contract must be guarded by the

 * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity

 * feature proposal that would enable this to be done automatically.

 */

contract AdminableProxy is AdminUpgradeabilityProxy {



  /**

   * Contract constructor.

   */

  constructor(address _implementation, bytes memory _data) 

  AdminUpgradeabilityProxy(_implementation, _data) public payable {

  }



  /**

   * @dev apply proposal.

   */

  function applyProposal(bytes calldata data) external ifAdmin returns (bool) {

    bool rv;

    (rv, ) = _implementation().delegatecall(data);

    return rv;

  }



}



contract MinGov is Ownable {

  

  uint256 public proposalTime;

  uint256 public first;

  uint256 public size;

  

  struct Proposal {

    address subject;

    uint32 created;

    bool canceled;

    bytes msgData;

  }

  

  mapping(uint256 => Proposal) public proposals;

  

  event NewProposal(uint256 indexed proposalId, address indexed subject, bytes msgData);

  event Execution(uint256 indexed proposalId, address indexed subject, bytes msgData);

  

  constructor(uint256 _proposalTime) public {

    proposalTime = _proposalTime;

    first = 1;

    size = 0;

  }



  function propose(address _subject, bytes memory _msgData) public onlyOwner {

    require(size < 5);

    proposals[first + size] = Proposal(

      _subject,

      uint32(now),

      false,

      _msgData

    );

    emit NewProposal(first + size, _subject, _msgData);

    size++;

  }

  

  function cancel(uint256 _proposalId) public onlyOwner() {

    Proposal storage prop = proposals[_proposalId];

    require(prop.created > 0);

    require(prop.canceled == false);

    prop.canceled = true;

  }



  function withdrawTax(address _token) public onlyOwner {

    IERC20 token = IERC20(_token);

    token.transfer(owner(), token.balanceOf(address(this)));

  }



  function finalize() public {

    for (uint256 i = first; i < first + size; i++) {

      Proposal memory prop = proposals[i];

      if (prop.created + proposalTime <= now) {

        if (!prop.canceled) {

          bool rv;

          bytes4 sig = getSig(prop.msgData);

          // 0x8f283970 = changeAdmin(address)

          // 0x3659cfe6 = upgradeTo(address)

           // 0x983b2d56 = addMinter(address)

          if (sig == 0x8f283970||sig == 0x3659cfe6||sig == 0x983b2d56) {

            // this changes proxy parameters 

            (rv, ) = prop.subject.call(prop.msgData);

          } else {

            // this changes governance parameters to the implementation

            rv = AdminableProxy(address(uint160(prop.subject))).applyProposal(prop.msgData);

          }

          if (rv) {

            emit Execution(i, prop.subject, prop.msgData);

          }

        }

        delete proposals[i];

        first++;

        size--;

      }

    }

  }



  // proxy function to manage validator slots without governance delay

  function setSlot(uint256 _slotId, address, bytes32) public onlyOwner {

    // extract subject

    address payable subject = address(uint160(_slotId >> 96));

    // strip out subject from data

    bytes memory msgData = new bytes(100);

    assembly {

      calldatacopy(add(msgData, 32), 0, 4)

      calldatacopy(add(msgData, 56), 24, 76)

    }

    // call subject

    require(AdminableProxy(subject).applyProposal(msgData), "setSlot call failed");

  }



  function getSig(bytes memory _msgData) internal pure returns (bytes4) {

    return bytes4(_msgData[3]) >> 24 | bytes4(_msgData[2]) >> 16 | bytes4(_msgData[1]) >> 8 | bytes4(_msgData[0]);

  }



}