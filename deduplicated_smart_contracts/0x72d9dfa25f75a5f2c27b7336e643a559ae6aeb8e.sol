/**

 *Submitted for verification at Etherscan.io on 2018-08-22

*/



pragma solidity ^0.4.18;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

  address public owner;





  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  function Ownable() public {

    owner = msg.sender;

  }





  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }





  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param newOwner The address to transfer ownership to.

   */

  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }

}



/**

 * @title Pausable

 * @dev Base contract which allows children to implement an emergency stop mechanism.

 */

contract Pausable is Ownable {

  event Pause();

  event Unpause();



  bool public paused = false;





  /**

   * @dev Modifier to make a function callable only when the contract is not paused.

   */

  modifier whenNotPaused() {

    require(!paused);

    _;

  }



  /**

   * @dev Modifier to make a function callable only when the contract is paused.

   */

  modifier whenPaused() {

    require(paused);

    _;

  }



  /**

   * @dev called by the owner to pause, triggers stopped state

   */

  function pause() onlyOwner whenNotPaused public {

    paused = true;

    Pause();

  }



  /**

   * @dev called by the owner to unpause, returns to normal state

   */

  function unpause() onlyOwner whenPaused public {

    paused = false;

    Unpause();

  }

}



contract IController is Pausable {

    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);



    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;

    function updateController(bytes32 _id, address _controller) external;

    function getContract(bytes32 _id) public view returns (address);

}



contract IManager {

    event SetController(address controller);

    event ParameterUpdate(string param);



    function setController(address _controller) external;

}



contract Manager is IManager {

    // Controller that contract is registered with

    IController public controller;



    // Check if sender is controller

    modifier onlyController() {

        require(msg.sender == address(controller));

        _;

    }



    // Check if sender is controller owner

    modifier onlyControllerOwner() {

        require(msg.sender == controller.owner());

        _;

    }



    // Check if controller is not paused

    modifier whenSystemNotPaused() {

        require(!controller.paused());

        _;

    }



    // Check if controller is paused

    modifier whenSystemPaused() {

        require(controller.paused());

        _;

    }



    function Manager(address _controller) public {

        controller = IController(_controller);

    }



    /*

     * @dev Set controller. Only callable by current controller

     * @param _controller Controller contract address

     */

    function setController(address _controller) external onlyController {

        controller = IController(_controller);



        SetController(_controller);

    }

}



/**

 * @title ManagerProxyTarget

 * @dev The base contract that target contracts used by a proxy contract should inherit from

 * Note: Both the target contract and the proxy contract (implemented as ManagerProxy) MUST inherit from ManagerProxyTarget in order to guarantee

 * that both contracts have the same storage layout. Differing storage layouts in a proxy contract and target contract can

 * potentially break the delegate proxy upgradeability mechanism

 */

contract ManagerProxyTarget is Manager {

    // Used to look up target contract address in controller's registry

    bytes32 public targetContractId;

}



/**

 * @title ServiceRegistry

 * @dev Maintains a registry of service metadata associated with service provider addresses (transcoders/orchestrators)

 */

contract ServiceRegistry is ManagerProxyTarget {

    // Store service metadata

    struct Record {

        string serviceURI;   // Service URI endpoint that can be used to send off-chain requests

    }



    // Track records for addresses

    mapping (address => Record) private records;



    // Event fired when a caller updates its service URI endpoint

    event ServiceURIUpdate(address indexed addr, string serviceURI);



    /**

     * @dev ServiceRegistry constructor. Only invokes constructor of base Manager contract with provided Controller address

     * @param _controller Address of a Controller that this contract will be registered with

     */

    function ServiceRegistry(address _controller) public Manager(_controller) {}



    /**

     * @dev Stores service URI endpoint for the caller that can be used to send requests to the caller off-chain 

     * @param _serviceURI Service URI endpoint for the caller

     */

    function setServiceURI(string _serviceURI) external {

        records[msg.sender].serviceURI = _serviceURI;



        ServiceURIUpdate(msg.sender, _serviceURI);

    }



    /**

     * @dev Returns service URI endpoint stored for a given address

     * @param _addr Address for which a service URI endpoint is desired

     */

    function getServiceURI(address _addr) public view returns (string) {

        return records[_addr].serviceURI;

    }

}