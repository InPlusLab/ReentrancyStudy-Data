/**

 *Submitted for verification at Etherscan.io on 2019-04-26

*/



// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.0;



/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

interface IERC20 {

    function transfer(address to, uint256 value) external returns (bool);



    function approve(address spender, uint256 value) external returns (bool);



    function transferFrom(address from, address to, uint256 value) external returns (bool);



    function totalSupply() external view returns (uint256);



    function balanceOf(address who) external view returns (uint256);



    function allowance(address owner, address spender) external view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.0;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * @notice Renouncing to ownership will leave the contract without an owner.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: lib/CanReclaimToken.sol



pragma solidity ^0.5.0;







/**

 * @title Contracts that should be able to recover tokens

 * @author SylTi

 * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.

 * This will prevent any accidental loss of tokens.

 */

contract CanReclaimToken is Ownable {



  /**

   * @dev Reclaim all ERC20 compatible tokens

   * @param token ERC20 The address of the token contract

   */

  function reclaimToken(IERC20 token) external onlyOwner {

    address payable owner = address(uint160(owner()));



    if (address(token) == address(0)) {

      owner.transfer(address(this).balance);

      return;

    }

    uint256 balance = token.balanceOf(address(this));

    token.transfer(owner, balance);

  }



}



// File: contracts/CHDT_TRON.sol



pragma solidity ^0.5.0;



/// @title DividendToken Contract

/// @dev It is ERC20 compliant, but still needs to under go further testing.







/// @dev The actual token contract, the default owner is the msg.sender

contract DividendToken is IERC20, CanReclaimToken {



    string public name;                //The Token's name: e.g. DigixDAO Tokens

    uint8 public decimals;             //Number of decimals of the smallest unit

    string public symbol;              //An identifier: e.g. REP



    /// @dev `Checkpoint` is the structure that attaches a block number to a

    ///  given value, the block number attached is the one that last changed the

    ///  value

    struct  Checkpoint {



        // `fromBlock` is the block number that the value was generated from

        uint128 fromBlock;



        // `value` is the amount of tokens at a specific block number

        uint128 value;

    }



    // `parentToken` is the Token address that was cloned to produce this token;

    //  it will be 0x0 for a token that was not cloned

    DividendToken public parentToken;



    // `parentSnapShotBlock` is the block number from the Parent Token that was

    //  used to determine the initial distribution of the Clone Token

    uint public parentSnapShotBlock;



    // `creationBlock` is the block number that the Clone Token was created

    uint public creationBlock;



    // `balances` is the map that tracks the balance of each address, in this

    //  contract when the balance changes the block number that the change

    //  occurred is also included in the map

    mapping (address => Checkpoint[]) balances;



    // `allowed` tracks any extra transfer rights as in all ERC20 tokens

    mapping (address => mapping (address => uint256)) allowed;



    // Tracks the history of the `totalSupply` of the token

    Checkpoint[] totalSupplyHistory;





    ////////////////

    // Constructor

    ////////////////



    /// @param _parentToken Address of the parent token, set to 0x0 if it is a

    ///  new token

    /// @param _parentSnapShotBlock Block of the parent token that will

    ///  determine the initial distribution of the clone token, set to 0 if it

    ///  is a new token

    constructor (address _parentToken, uint _parentSnapShotBlock) public {

        name = "CH Dividend Token TRON";

        symbol = "CHDT TRON";

        decimals = 18;

        parentToken = DividendToken(_parentToken);

        parentSnapShotBlock = _parentSnapShotBlock == 0 ? block.number : _parentSnapShotBlock;

        creationBlock = block.number;



        //initial emission

        uint _amount = 7000000 * (10 ** uint256(decimals));

        updateValueAtNow(totalSupplyHistory, _amount);

        updateValueAtNow(balances[msg.sender], _amount);

        emit Transfer(address(0), msg.sender, _amount);

    }



    /// @notice The fallback function

    function () external {}





    ///////////////////

    // ERC20 Methods

    ///////////////////



    /// @notice Send `_amount` tokens to `_to` from `msg.sender`

    /// @param _to The address of the recipient

    /// @param _amount The amount of tokens to be transferred

    /// @return Whether the transfer was successful or not

    function transfer(address _to, uint256 _amount) external returns (bool success) {

        doTransfer(msg.sender, _to, _amount);

        return true;

    }



    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it

    ///  is approved by `_from`

    /// @param _from The address holding the tokens being transferred

    /// @param _to The address of the recipient

    /// @param _amount The amount of tokens to be transferred

    /// @return True if the transfer was successful

    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success) {

        // The standard ERC 20 transferFrom functionality

        require(allowed[_from][msg.sender] >= _amount);

        allowed[_from][msg.sender] -= _amount;

        doTransfer(_from, _to, _amount);

        return true;

    }



    /// @dev This is the actual transfer function in the token contract, it can

    ///  only be called by other functions in this contract.

    /// @param _from The address holding the tokens being transferred

    /// @param _to The address of the recipient

    /// @param _amount The amount of tokens to be transferred

    /// @return True if the transfer was successful

    function doTransfer(address _from, address _to, uint _amount) internal {



        if (_amount == 0) {

            emit Transfer(_from, _to, _amount);    // Follow the spec to louch the event when transfer 0

            return;

        }



        require(parentSnapShotBlock < block.number);



        // Do not allow transfer to 0x0 or the token contract itself

        require((_to != address(0)) && (_to != address(this)));



        // If the amount being transfered is more than the balance of the

        //  account the transfer throws

        uint previousBalanceFrom = balanceOfAt(_from, block.number);



        require(previousBalanceFrom >= _amount);



        // First update the balance array with the new value for the address

        //  sending the tokens

        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);



        // Then update the balance array with the new value for the address

        //  receiving the tokens

        uint previousBalanceTo = balanceOfAt(_to, block.number);

        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow

        updateValueAtNow(balances[_to], previousBalanceTo + _amount);



        // An event to make the transfer easy to find on the blockchain

        emit Transfer(_from, _to, _amount);



    }



    /// @param _owner The address that's balance is being requested

    /// @return The balance of `_owner` at the current block

    function balanceOf(address _owner) public view returns (uint256 balance) {

        return balanceOfAt(_owner, block.number);

    }



    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on

    ///  its behalf. This is a modified version of the ERC20 approve function

    ///  to be a little bit safer

    /// @param _spender The address of the account able to transfer the tokens

    /// @param _amount The amount of tokens to be approved for transfer

    /// @return True if the approval was successful

    function approve(address _spender, uint256 _amount) public returns (bool success) {

        // To change the approve amount you first have to reduce the addresses`

        //  allowance to zero by calling `approve(_spender,0)` if it is not

        //  already 0 to mitigate the race condition described here:

        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));



        allowed[msg.sender][_spender] = _amount;

        emit Approval(msg.sender, _spender, _amount);

        return true;

    }



    /**

     * @dev Increase the amount of tokens that an owner allowed to a spender.

     *

     * approve should be called when allowance[_spender] == 0. To increment

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * @param _spender The address which will spend the funds.

     * @param _addedAmount The amount of tokens to increase the allowance by.

     */

    function increaseApproval(address _spender, uint _addedAmount) external returns (bool) {

        require(allowed[msg.sender][_spender] + _addedAmount >= allowed[msg.sender][_spender]); // Check for overflow

        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedAmount;

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }



    /**

     * @dev Decrease the amount of tokens that an owner allowed to a spender.

     *

     * approve should be called when allowance[_spender] == 0. To decrement

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * @param _spender The address which will spend the funds.

     * @param _subtractedAmount The amount of tokens to decrease the allowance by.

     */

    function decreaseApproval(address _spender, uint _subtractedAmount) external returns (bool)

    {

        uint oldValue = allowed[msg.sender][_spender];

        if (_subtractedAmount >= oldValue) {

            allowed[msg.sender][_spender] = 0;

        } else {

            allowed[msg.sender][_spender] = oldValue - _subtractedAmount;

        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }





    /// @dev This function makes it easy to read the `allowed[]` map

    /// @param _owner The address of the account that owns the token

    /// @param _spender The address of the account able to transfer the tokens

    /// @return Amount of remaining tokens of _owner that _spender is allowed

    ///  to spend

    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }





    /// @dev This function makes it easy to get the total number of tokens

    /// @return The total number of tokens

    function totalSupply() public view returns (uint) {

        return totalSupplyAt(block.number);

    }





    ////////////////

    // Query balance and totalSupply in History

    ////////////////



    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`

    /// @param _owner The address from which the balance will be retrieved

    /// @param _blockNumber The block number when the balance is queried

    /// @return The balance at `_blockNumber`

    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {



        // These next few lines are used when the balance of the token is

        //  requested before a check point was ever created for this token, it

        //  requires that the `parentToken.balanceOfAt` be queried at the

        //  genesis block for that token as this contains initial balance of

        //  this token

        if ((balances[_owner].length == 0)

            || (balances[_owner][0].fromBlock > _blockNumber)) {

            if (address(parentToken) != address(0)) {

                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));

            } else {

                // Has no parent

                return 0;

            }



            // This will return the expected balance during normal situations

        } else {

            return getValueAt(balances[_owner], _blockNumber);

        }

    }



    /// @notice Total amount of tokens at a specific `_blockNumber`.

    /// @param _blockNumber The block number when the totalSupply is queried

    /// @return The total amount of tokens at `_blockNumber`

    function totalSupplyAt(uint _blockNumber) public view returns(uint) {



        // These next few lines are used when the totalSupply of the token is

        //  requested before a check point was ever created for this token, it

        //  requires that the `parentToken.totalSupplyAt` be queried at the

        //  genesis block for this token as that contains totalSupply of this

        //  token at this block number.

        if ((totalSupplyHistory.length == 0)

            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {

            if (address(parentToken) != address(0)) {

                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));

            } else {

                return 0;

            }



            // This will return the expected totalSupply during normal situations

        } else {

            return getValueAt(totalSupplyHistory, _blockNumber);

        }

    }





    ////////////////

    // Mint and burn tokens

    ////////////////



    /// @notice Mints `_amount` tokens that are assigned to `_owner`

    /// @param _owner The address that will be assigned the new tokens

    /// @param _amount The quantity of tokens generated

    /// @return True if the tokens are generated correctly

    function mint(address _owner, uint _amount) external onlyOwner returns (bool) {

        uint curTotalSupply = totalSupply();

        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow

        uint previousBalanceTo = balanceOf(_owner);

        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow

        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);

        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);

        emit Transfer(address(0), _owner, _amount);

        return true;

    }





    /// @notice Burns `_amount` tokens from `_owner`

    /// @param _owner The address that will lose the tokens

    /// @param _amount The quantity of tokens to burn

    /// @return True if the tokens are burned correctly

    function burn(address _owner, uint _amount) external onlyOwner returns (bool) {

        uint curTotalSupply = totalSupply();

        require(curTotalSupply >= _amount);

        uint previousBalanceFrom = balanceOf(_owner);

        require(previousBalanceFrom >= _amount);

        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);

        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);

        emit Transfer(_owner, address(0), _amount);

        return true;

    }





    ////////////////

    // Internal helper functions to query and set a value in a snapshot array

    ////////////////



    /// @dev `getValueAt` retrieves the number of tokens at a given block number

    /// @param checkpoints The history of values being queried

    /// @param _block The block number to retrieve the value at

    /// @return The number of tokens being queried

    function getValueAt(Checkpoint[] storage checkpoints, uint _block) view internal returns (uint) {

        if (checkpoints.length == 0) return 0;



        // Shortcut for the actual value

        if (_block >= checkpoints[checkpoints.length-1].fromBlock)

            return checkpoints[checkpoints.length-1].value;

        if (_block < checkpoints[0].fromBlock) return 0;



        // Binary search of the value in the array

        uint min = 0;

        uint max = checkpoints.length-1;

        while (max > min) {

            uint mid = (max + min + 1)/ 2;

            if (checkpoints[mid].fromBlock<=_block) {

                min = mid;

            } else {

                max = mid-1;

            }

        }

        return checkpoints[min].value;

    }



    /// @dev `updateValueAtNow` used to update the `balances` map and the

    ///  `totalSupplyHistory`

    /// @param checkpoints The history of data being updated

    /// @param _value The new number of tokens

    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal  {

        if ((checkpoints.length == 0)

            || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {

            Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];

            newCheckPoint.fromBlock =  uint128(block.number);

            newCheckPoint.value = uint128(_value);

        } else {

            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];

            oldCheckPoint.value = uint128(_value);

        }

    }





    /// @dev Helper function to return a min betwen the two uints

    function min(uint a, uint b) pure internal returns (uint) {

        return a < b ? a : b;

    }





}