/**

 *Submitted for verification at Etherscan.io on 2018-09-30

*/



pragma solidity ^0.4.25;



/// @title ERC-721 Non-Fungible Token Standard

/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.

interface ERC721 /* is ERC165 */ {

    /// @dev This emits when ownership of any NFT changes by any mechanism.

    ///  This event emits when NFTs are created (`from` == 0) and destroyed

    ///  (`to` == 0). Exception: during contract creation, any number of NFTs

    ///  may be created and assigned without emitting Transfer. At the time of

    ///  any transfer, the approved address for that NFT (if any) is reset to none.

    ///

    /// MOVED THIS TO CSportsBase because of how class structure is derived.

    ///

    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);



    /// @dev This emits when the approved address for an NFT is changed or

    ///  reaffirmed. The zero address indicates there is no approved address.

    ///  When a Transfer event emits, this also indicates that the approved

    ///  address for that NFT (if any) is reset to none.

    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);



    /// @dev This emits when an operator is enabled or disabled for an owner.

    ///  The operator can manage all NFTs of the owner.

    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);



    /// @notice Count all NFTs assigned to an owner

    /// @dev NFTs assigned to the zero address are considered invalid, and this

    ///  function throws for queries about the zero address.

    /// @param _owner An address for whom to query the balance

    /// @return The number of NFTs owned by `_owner`, possibly zero

    function balanceOf(address _owner) external view returns (uint256);



    /// @notice Find the owner of an NFT

    /// @dev NFTs assigned to zero address are considered invalid, and queries

    ///  about them do throw.

    /// @param _tokenId The identifier for an NFT

    /// @return The address of the owner of the NFT

    function ownerOf(uint256 _tokenId) external view returns (address);



    /// @notice Transfers the ownership of an NFT from one address to another address

    /// @dev Throws unless `msg.sender` is the current owner, an authorized

    ///  operator, or the approved address for this NFT. Throws if `_from` is

    ///  not the current owner. Throws if `_to` is the zero address. Throws if

    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function

    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls

    ///  `onERC721Received` on `_to` and throws if the return value is not

    ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.

    /// @param _from The current owner of the NFT

    /// @param _to The new owner

    /// @param _tokenId The NFT to transfer

    /// @param data Additional data with no specified format, sent in call to `_to`

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;



    /// @notice Transfers the ownership of an NFT from one address to another address

    /// @dev This works identically to the other function with an extra data parameter,

    ///  except this function just sets data to "".

    /// @param _from The current owner of the NFT

    /// @param _to The new owner

    /// @param _tokenId The NFT to transfer

    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;



    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE

    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE

    ///  THEY MAY BE PERMANENTLY LOST

    /// @dev Throws unless `msg.sender` is the current owner, an authorized

    ///  operator, or the approved address for this NFT. Throws if `_from` is

    ///  not the current owner. Throws if `_to` is the zero address. Throws if

    ///  `_tokenId` is not a valid NFT.

    /// @param _from The current owner of the NFT

    /// @param _to The new owner

    /// @param _tokenId The NFT to transfer

    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;



    /// @notice Change or reaffirm the approved address for an NFT

    /// @dev The zero address indicates there is no approved address.

    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized

    ///  operator of the current owner.

    /// @param _approved The new approved NFT controller

    /// @param _tokenId The NFT to approve

    function approve(address _approved, uint256 _tokenId) external payable;



    /// @notice Enable or disable approval for a third party ("operator") to manage

    ///  all of `msg.sender`'s assets

    /// @dev Emits the ApprovalForAll event. The contract MUST allow

    ///  multiple operators per owner.

    /// @param _operator Address to add to the set of authorized operators

    /// @param _approved True if the operator is approved, false to revoke approval

    function setApprovalForAll(address _operator, bool _approved) external;



    /// @notice Get the approved address for a single NFT

    /// @dev Throws if `_tokenId` is not a valid NFT.

    /// @param _tokenId The NFT to find the approved address for

    /// @return The approved address for this NFT, or the zero address if there is none

    function getApproved(uint256 _tokenId) external view returns (address);



    /// @notice Query if an address is an authorized operator for another address

    /// @param _owner The address that owns the NFTs

    /// @param _operator The address that acts on behalf of the owner

    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise

    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

}



/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension

/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.

interface ERC721Metadata /* is ERC721 */ {

    /// @notice A descriptive name for a collection of NFTs in this contract

    function name() external view returns (string _name);



    /// @notice An abbreviated name for NFTs in this contract

    function symbol() external view returns (string _symbol);



    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.

    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC

    ///  3986. The URI may point to a JSON file that conforms to the "ERC721

    ///  Metadata JSON Schema".

    function tokenURI(uint256 _tokenId) external view returns (string);

}



/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension

/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

///  Note: the ERC-165 identifier for this interface is 0x780e9d63.

interface ERC721Enumerable /* is ERC721 */ {

    /// @notice Count NFTs tracked by this contract

    /// @return A count of valid NFTs tracked by this contract, where each one of

    ///  them has an assigned and queryable owner not equal to the zero address

    function totalSupply() external view returns (uint256);



    /// @notice Enumerate valid NFTs

    /// @dev Throws if `_index` >= `totalSupply()`.

    /// @param _index A counter less than `totalSupply()`

    /// @return The token identifier for the `_index`th NFT,

    ///  (sort order not specified)

    function tokenByIndex(uint256 _index) external view returns (uint256);



    /// @notice Enumerate NFTs assigned to an owner

    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if

    ///  `_owner` is the zero address, representing invalid NFTs.

    /// @param _owner An address where we are interested in NFTs owned by them

    /// @param _index A counter less than `balanceOf(_owner)`

    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,

    ///   (sort order not specified)

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);

}



/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.

interface ERC721TokenReceiver {

    /// @notice Handle the receipt of an NFT

    /// @dev The ERC721 smart contract calls this function on the recipient

    ///  after a `transfer`. This function MAY throw to revert and reject the

    ///  transfer. Return of other than the magic value MUST result in the

    ///  transaction being reverted.

    ///  Note: the contract address is always the message sender.

    /// @param _operator The address which called `safeTransferFrom` function

    /// @param _from The address which previously owned the token

    /// @param _tokenId The NFT identifier which is being transferred

    /// @param _data Additional data with no specified format

    /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

    ///  unless throwing

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);

}



interface ERC165 {

    /// @notice Query if a contract implements an interface

    /// @param interfaceID The interface identifier, as specified in ERC-165

    /// @dev Interface identification is specified in ERC-165. This function

    ///  uses less than 30,000 gas.

    /// @return `true` if the contract implements `interfaceID` and

    ///  `interfaceID` is not 0xffffffff, `false` otherwise

    function supportsInterface(bytes4 interfaceID) external view returns (bool);

}



/// @title Auction Core

/// @dev Contains models, variables, and internal methods for the auction.

contract TimeAuctionBase {



    // Represents an auction on an NFT

    struct Auction {

        // Current owner of NFT

        address seller;

        // Price (in wei) at beginning of auction

        uint128 startingPrice;

        // Price (in wei) at end of auction

        uint128 endingPrice;

        // Duration (in seconds) of auction

        uint64 duration;

        // Time when auction started

        // NOTE: 0 if this auction has been concluded

        uint64 startedAt;

    }



    // Reference to contract tracking NFT ownership

    ERC721 public nonFungibleContract;



    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).

    // Values 0-10,000 map to 0%-100%

    uint256 public ownerCut;



    // Map from token ID to their corresponding auction.

    mapping (uint256 => Auction) tokenIdToAuction;



    event AuctionCreated(uint256 tokenId, address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration);

    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);

    event AuctionCancelled(uint256 tokenId);

    event AuctionSettled(uint256 tokenId, uint256 price, uint256 sellerProceeds, address seller, address buyer);

    event AuctionRepriced(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint64 duration, uint64 startedAt);



    /// @dev DON'T give me your money.

    function() external {}



    // Modifiers to check that inputs can be safely stored with a certain

    // number of bits. We use constants and multiple modifiers to save gas.

    modifier canBeStoredWith32Bits(uint256 _value) {

        require(_value <= 4294967295);

        _;

    }



    // Modifiers to check that inputs can be safely stored with a certain

    // number of bits. We use constants and multiple modifiers to save gas.

    modifier canBeStoredWith64Bits(uint256 _value) {

        require(_value <= 18446744073709551615);

        _;

    }



    modifier canBeStoredWith128Bits(uint256 _value) {

        require(_value < 340282366920938463463374607431768211455);

        _;

    }



    /// @dev Returns true if the claimant owns the token.

    /// @param _claimant - Address claiming to own the token.

    /// @param _tokenId - ID of token whose ownership to verify.

    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {

        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);

    }



    /// @dev Escrows the NFT, assigning ownership to this contract.

    /// Throws if the escrow fails.

    /// @param _owner - Current owner address of token to escrow.

    /// @param _tokenId - ID of token whose approval to verify.

    function _escrow(address _owner, uint256 _tokenId) internal {

        // it will throw if transfer fails

        nonFungibleContract.transferFrom(_owner, this, _tokenId);

    }



    /// @dev Transfers an NFT owned by this contract to another address.

    /// Returns true if the transfer succeeds.

    /// @param _receiver - Address to transfer NFT to.

    /// @param _tokenId - ID of token to transfer.

    function _transfer(address _receiver, uint256 _tokenId) internal {

        // it will throw if transfer fails

        nonFungibleContract.approve(_receiver, _tokenId);

        nonFungibleContract.transferFrom(address(this), _receiver, _tokenId);

    }



    /// @dev Adds an auction to the list of open auctions. Also fires the

    ///  AuctionCreated event.

    /// @param _tokenId The ID of the token to be put on auction.

    /// @param _auction Auction to add.

    function _addAuction(uint256 _tokenId, Auction _auction) internal {

        // Require that all auctions have a duration of

        // at least one minute. (Keeps our math from getting hairy!)

        require(_auction.duration >= 1 minutes);



        tokenIdToAuction[_tokenId] = _auction;



        emit AuctionCreated(

            uint256(_tokenId),

            address(_auction.seller),

            uint256(_auction.startingPrice),

            uint256(_auction.endingPrice),

            uint256(_auction.duration)

        );

    }



    /// @dev Cancels an auction unconditionally.

    function _cancelAuction(uint256 _tokenId, address _seller) internal {

        _removeAuction(_tokenId);

        _transfer(_seller, _tokenId);

        emit AuctionCancelled(_tokenId);

    }



    /// @dev Computes the price and transfers winnings.

    /// Does NOT transfer ownership of token.

    function _bid(uint256 _tokenId, uint256 _bidAmount)

        internal

        returns (uint256)

    {

        // Get a reference to the auction struct

        Auction storage auction = tokenIdToAuction[_tokenId];



        // Explicitly check that this auction is currently live.

        // (Because of how Ethereum mappings work, we can't just count

        // on the lookup above failing. An invalid _tokenId will just

        // return an auction object that is all zeros.)

        require(_isOnAuction(auction));



        // Check that the incoming bid is higher than the current

        // price

        uint256 price = _currentPrice(auction);

        require(_bidAmount >= price);



        // Grab a reference to the seller before the auction struct

        // gets deleted.

        address seller = auction.seller;



        // The bid is good! Remove the auction before sending the fees

        // to the sender so we can't have a reentrancy attack.

        _removeAuction(_tokenId);



        // Transfer proceeds to seller (if there are any!)

        if (price > 0) {

            //  Calculate the auctioneer's cut.

            // (NOTE: _computeCut() is guaranteed to return a

            //  value <= price, so this subtraction can't go negative.)

            uint256 auctioneerCut = _computeCut(price);

            uint256 sellerProceeds = price - auctioneerCut;



            // NOTE: Doing a transfer() in the middle of a complex

            // method like this is generally discouraged because of

            // reentrancy attacks and DoS attacks if the seller is

            // a contract with an invalid fallback function. We explicitly

            // guard against reentrancy attacks by removing the auction

            // before calling transfer(), and the only thing the seller

            // can DoS is the sale of their own asset! (And if it's an

            // accident, they can call cancelAuction(). )

            seller.transfer(sellerProceeds);

            emit AuctionSettled(_tokenId, price, sellerProceeds, seller, msg.sender);

        }



        // Tell the world!

        emit AuctionSuccessful(_tokenId, price, msg.sender);



        return price;

    }



    /// @dev Removes an auction from the list of open auctions.

    /// @param _tokenId - ID of NFT on auction.

    function _removeAuction(uint256 _tokenId) internal {

        delete tokenIdToAuction[_tokenId];

    }



    /// @dev Returns true if the NFT is on auction.

    /// @param _auction - Auction to check.

    function _isOnAuction(Auction storage _auction) internal view returns (bool) {

        return (_auction.startedAt > 0);

    }



    /// @dev Returns current price of an NFT on auction. Broken into two

    ///  functions (this one, that computes the duration from the auction

    ///  structure, and the other that does the price computation) so we

    ///  can easily test that the price computation works correctly.

    function _currentPrice(Auction storage _auction)

        internal

        view

        returns (uint256)

    {

        uint256 secondsPassed = 0;



        // A bit of insurance against negative values (or wraparound).

        // Probably not necessary (since Ethereum guarnatees that the

        // now variable doesn't ever go backwards).

        if (now > _auction.startedAt) {

            secondsPassed = now - _auction.startedAt;

        }



        return _computeCurrentPrice(

            _auction.startingPrice,

            _auction.endingPrice,

            _auction.duration,

            secondsPassed

        );

    }



    /// @dev Computes the current price of an auction. Factored out

    ///  from _currentPrice so we can run extensive unit tests.

    ///  When testing, make this function public and turn on

    ///  `Current price computation` test suite.

    function _computeCurrentPrice(

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration,

        uint256 _secondsPassed

    )

        internal

        pure

        returns (uint256)

    {

        // NOTE: We don't use SafeMath (or similar) in this function because

        //  all of our public functions carefully cap the maximum values for

        //  time (at 64-bits) and currency (at 128-bits). _duration is

        //  also known to be non-zero (see the require() statement in

        //  _addAuction())

        if (_secondsPassed >= _duration) {

            // We've reached the end of the dynamic pricing portion

            // of the auction, just return the end price.

            return _endingPrice;

        } else {

            // Starting price can be higher than ending price (and often is!), so

            // this delta can be negative.

            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);



            // This multiplication can't overflow, _secondsPassed will easily fit within

            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product

            // will always fit within 256-bits.

            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);



            // currentPriceChange can be negative, but if so, will have a magnitude

            // less that _startingPrice. Thus, this result will always end up positive.

            int256 currentPrice = int256(_startingPrice) + currentPriceChange;



            return uint256(currentPrice);

        }

    }



    /// @dev Computes owner's cut of a sale.

    /// @param _price - Sale price of NFT.

    function _computeCut(uint256 _price) internal view returns (uint256) {

        // NOTE: We don't use SafeMath (or similar) in this function because

        //  all of our entry functions carefully cap the maximum values for

        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()

        //  statement in the TimeAuction constructor). The result of this

        //  function is always guaranteed to be <= _price.

        return _price * ownerCut / 10000;

    }



}



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

  address public owner;



  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  constructor() public {

    owner = msg.sender;

  }



  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param newOwner The address to transfer ownership to.

   */

  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



}



/**

 * @title Pausable

 * @dev Base contract which allows children to implement an emergency stop mechanism.

 */

contract Pausable is Ownable {

  event Pause();

  event Unpause();



  bool public paused = false;



  /**

   * @dev Modifier to make a function callable only when the contract is not paused.

   */

  modifier whenNotPaused() {

    require(!paused);

    _;

  }



  /**

   * @dev Modifier to make a function callable only when the contract is paused.

   */

  modifier whenPaused() {

    require(paused);

    _;

  }



  /**

   * @dev called by the owner to pause, triggers stopped state

   */

  function pause() onlyOwner whenNotPaused public {

    paused = true;

    emit Pause();

  }



  /**

   * @dev called by the owner to unpause, returns to normal state

   */

  function unpause() onlyOwner whenPaused public {

    paused = false;

    emit Unpause();

  }

}



/// @title Clock auction for non-fungible tokens.

contract TimeAuction is Pausable, TimeAuctionBase {



    /// @dev Constructor creates a reference to the NFT ownership contract

    ///  and verifies the owner cut is in the valid range.

    /// @param _nftAddress - address of a deployed contract implementing

    ///  the Nonfungible Interface.

    /// @param _cut - 100*(percent cut) the owner takes on each auction, must be

    ///  between 0-10,000.

    constructor(address _nftAddress, uint256 _cut) public {

        require(_cut <= 10000);

        ownerCut = _cut;



        ERC721 candidateContract = ERC721(_nftAddress);

        nonFungibleContract = candidateContract;

    }



    /// @dev Remove all Ether from the contract, which is the owner's cuts

    ///  as well as any Ether sent directly to the contract address.

    ///  Always transfers to the NFT contract, and can only be called from

    ///  the NFT contract.

    function withdrawBalance() external {

        address nftAddress = address(nonFungibleContract);

        require(msg.sender == nftAddress);

        nftAddress.transfer(address(this).balance);

    }



    /// @dev Creates and begins a new auction.

    /// @param _tokenId - ID of token to auction, sender must be owner.

    /// @param _startingPrice - Price of item (in wei) at beginning of auction.

    /// @param _endingPrice - Price of item (in wei) at end of auction.

    /// @param _duration - Length of time to move between starting

    ///  price and ending price (in seconds).

    /// @param _seller - Seller, if not the message sender

    function createAuction(

        uint256 _tokenId,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration,

        address _seller

    )

        public

        whenNotPaused

        canBeStoredWith128Bits(_startingPrice)

        canBeStoredWith128Bits(_endingPrice)

        canBeStoredWith64Bits(_duration)

    {

        require(_owns(msg.sender, _tokenId));

        _escrow(msg.sender, _tokenId);

        Auction memory auction = Auction(

            _seller,

            uint128(_startingPrice),

            uint128(_endingPrice),

            uint64(_duration),

            uint64(now)

        );

        _addAuction(_tokenId, auction);

    }



    /// @dev Bids on an open auction, completing the auction and transferring

    ///  ownership of the NFT if enough Ether is supplied.

    /// @param _tokenId - ID of token to bid on.

    function bid(uint256 _tokenId)

        public

        payable

        whenNotPaused

    {

        // _bid will throw if the bid or funds transfer fails

        _bid(_tokenId, msg.value);

        _transfer(msg.sender, _tokenId);

    }



    /// @dev Cancels an auction that hasn't been won yet.

    ///  Returns the NFT to original owner.

    /// @notice This is a state-modifying function that can

    ///  be called while the contract is paused. An auction can

    ///  only be cancelled by the seller.

    /// @param _tokenId - ID of token on auction

    function cancelAuction(uint256 _tokenId)

        public

    {

        Auction storage auction = tokenIdToAuction[_tokenId];

        require(_isOnAuction(auction));

        address seller = auction.seller;

        require(msg.sender == seller);

        _cancelAuction(_tokenId, seller);

    }



    /// @dev Cancels an auction when the contract is paused.

    ///  Only the owner (account that created the contract)

    ///  may do this, and NFTs are returned to

    ///  the seller. This should only be used in emergencies.

    /// @param _tokenId - ID of the NFT on auction to cancel.

    function cancelAuctionWhenPaused(uint256 _tokenId)

        whenPaused

        onlyOwner

        public

    {

        Auction storage auction = tokenIdToAuction[_tokenId];

        require(_isOnAuction(auction));

        _cancelAuction(_tokenId, auction.seller);

    }



    /// @dev Returns auction info for an NFT on auction.

    /// @param _tokenId - ID of NFT on auction.

    function getAuction(uint256 _tokenId)

        public

        view

        returns

    (

        address seller,

        uint256 startingPrice,

        uint256 endingPrice,

        uint256 currentPrice,

        uint256 duration,

        uint256 startedAt

    ) {

        Auction storage auction = tokenIdToAuction[_tokenId];

        require(_isOnAuction(auction));

        uint256 price = _currentPrice(auction);

        return (

            auction.seller,

            auction.startingPrice,

            auction.endingPrice,

            price,

            auction.duration,

            auction.startedAt

        );

    }



    /// @dev Returns current auction prices for up to 50 auctions

    /// @param _tokenIds - up to 50 IDs of NFT on auction that we want the prices of

    function getCurrentAuctionPrices(uint128[] _tokenIds) public view returns (uint128[50]) {



        require (_tokenIds.length <= 50);



        /// @dev A fixed array we can return current auction price information in.

        uint128[50] memory currentPricesArray;



        for (uint8 i = 0; i < _tokenIds.length; i++) {

          Auction storage auction = tokenIdToAuction[_tokenIds[i]];

          if (_isOnAuction(auction)) {

            uint256 price = _currentPrice(auction);

            currentPricesArray[i] = uint128(price);

          }

        }



        return currentPricesArray;

    }



    /// @dev Returns the current price of an auction.

    /// @param _tokenId - ID of the token price we are checking.

    function getCurrentPrice(uint256 _tokenId)

        public

        view

        returns (uint256)

    {

        Auction storage auction = tokenIdToAuction[_tokenId];

        require(_isOnAuction(auction));

        return _currentPrice(auction);

    }



}



/// @title Interface to allow a contract to listen to auction events.

contract SaleClockAuctionListener {

    function implementsSaleClockAuctionListener() public pure returns (bool);

    function auctionCreated(uint256 tokenId, address seller, uint128 startingPrice, uint128 endingPrice, uint64 duration) public;

    function auctionSuccessful(uint256 tokenId, uint128 totalPrice, address seller, address buyer) public;

    function auctionCancelled(uint256 tokenId, address seller) public;

}



/// @title Clock auction modified for sale of kitties

contract SaleClockAuction is TimeAuction {



    // @dev A listening contract that wants notifications of auction creation,

    //  completion, and cancellation

    SaleClockAuctionListener public listener;



    // Delegate constructor

    constructor(address _nftAddr, uint256 _cut) public TimeAuction(_nftAddr, _cut) {



    }



    /// @dev Sanity check that allows us to ensure that we are pointing to the

    ///  right auction in our setSaleAuctionAddress() call.

    function isSaleClockAuction() public pure returns (bool) {

        return true;

    }



    // @dev Method used to add a listener for auction events. This can only be called

    //  if the listener has not already been set (i.e. once). This limitation is in place to prevent

    //  malicious attempt to hijack the listening contract and perhaps try to do

    //  something bad (like throw). Since the listener methods are called inline with our

    //  createAuction(...), bid(...), and cancelAuction(...) methods, we need to make

    //  sure none of the listener methods causes a revert/throw/out of gas/etc.

    // @param _listener - Address of a SaleClockAuctionListener compatible contract

    function setListener(address _listener) public {

      require(listener == address(0));

      SaleClockAuctionListener candidateContract = SaleClockAuctionListener(_listener);

      require(candidateContract.implementsSaleClockAuctionListener());

      listener = candidateContract;

    }



    /// @dev Creates and begins a new auction. We override the base class

    ///   so we can add the listener capability.

    ///

    /// CALLABLE ONLY BY NFT CONTRACT

    ///

    /// @param _tokenId - ID of token to auction, sender must be owner.

    /// @param _startingPrice - Price of item (in wei) at beginning of auction.

    /// @param _endingPrice - Price of item (in wei) at end of auction.

    /// @param _duration - Length of auction (in seconds).

    /// @param _seller - Seller, if not the message sender

    function createAuction(

        uint256 _tokenId,

        uint256 _startingPrice,

        uint256 _endingPrice,

        uint256 _duration,

        address _seller

    )

        public

        canBeStoredWith128Bits(_startingPrice)

        canBeStoredWith128Bits(_endingPrice)

        canBeStoredWith64Bits(_duration)

    {

        require(msg.sender == address(nonFungibleContract));

        _escrow(_seller, _tokenId);

        Auction memory auction = Auction(

            _seller,

            uint128(_startingPrice),

            uint128(_endingPrice),

            uint64(_duration),

            uint64(now)

        );

        _addAuction(_tokenId, auction);



        if (listener != address(0)) {

          listener.auctionCreated(_tokenId, _seller, uint128(_startingPrice), uint128(_endingPrice), uint64(_duration));

        }

    }



    /// @dev Reprices (and updates duration) of an array of tokens that are currently

    /// being auctioned by this contract.

    ///

    /// CALLABLE ONLY BY NFT CONTRACT

    ///

    /// @param _tokenIds Array of tokenIds corresponding to auctions being updated

    /// @param _startingPrices New starting prices

    /// @param _endingPrices New ending prices

    /// @param _duration New duration

    /// @param _seller Address of the seller in all specified auctions to be updated

    function repriceAuctions(

        uint256[] _tokenIds,

        uint256[] _startingPrices,

        uint256[] _endingPrices,

        uint256 _duration,

        address _seller

    )

    public

    canBeStoredWith64Bits(_duration)

    {

        require(msg.sender == address(nonFungibleContract));



        uint64 timeNow = uint64(now);

        for (uint32 i = 0; i < _tokenIds.length; i++) {

            uint256 _tokenId = _tokenIds[i];

            uint256 _startingPrice = _startingPrices[i];

            uint256 _endingPrice = _endingPrices[i];



            // Must be able to be stored in 128 bits

            require(_startingPrice < 340282366920938463463374607431768211455);

            require(_endingPrice < 340282366920938463463374607431768211455);



            Auction storage auction = tokenIdToAuction[_tokenId];



            // Here is where we make sure the seller in the auction is correct.

            // Since this method can only be called by the NFT, the NFT controls

            // what happens here by passing in the _seller we are to require.

            if (auction.seller == _seller) {

                // Update the auction parameters

                auction.startingPrice = uint128(_startingPrice);

                auction.endingPrice = uint128(_endingPrice);

                auction.duration = uint64(_duration);

                auction.startedAt = timeNow;

                emit AuctionRepriced(_tokenId, _startingPrice, _endingPrice, uint64(_duration), timeNow);

            }

        }

    }



    /// @dev Place a bid to purchase multiple tokens in a single call.

    /// @param _tokenIds Array of IDs of tokens to bid on.

    function batchBid(uint256[] _tokenIds) public payable whenNotPaused

    {

        // Check to make sure the bid amount is sufficient to purchase

        // all of the auctions specified.

        uint256 totalPrice = 0;

        for (uint32 i = 0; i < _tokenIds.length; i++) {

          uint256 _tokenId = _tokenIds[i];

          Auction storage auction = tokenIdToAuction[_tokenId];

          totalPrice += _currentPrice(auction);

        }

        require(msg.value >= totalPrice);



        // Loop through auctions, placing bids to buy

        //

        for (i = 0; i < _tokenIds.length; i++) {



          _tokenId = _tokenIds[i];

          auction = tokenIdToAuction[_tokenId];



          // Need to store this before the _bid & _transfer calls

          // so we can fire our auctionSuccessful events

          address seller = auction.seller;



          uint256 bid = _currentPrice(auction);

          uint256 price = _bid(_tokenId, bid);

          _transfer(msg.sender, _tokenId);



          if (listener != address(0)) {

            listener.auctionSuccessful(_tokenId, uint128(price), seller, msg.sender);

          }

        }

    }



    /// @dev Does exactly what the parent does, but also notifies any

    ///   listener of the successful bid.

    /// @param _tokenId - ID of token to bid on.

    function bid(uint256 _tokenId) public payable whenNotPaused

    {

        Auction storage auction = tokenIdToAuction[_tokenId];



        // Need to store this before the _bid & _transfer calls

        // so we can fire our auctionSuccessful events

        address seller = auction.seller;



        // _bid will throw if the bid or funds transfer fails

        uint256 price = _bid(_tokenId, msg.value);

        _transfer(msg.sender, _tokenId);



        if (listener != address(0)) {

          listener.auctionSuccessful(_tokenId, uint128(price), seller, msg.sender);

        }

    }



    /// @dev Cancels an auction that hasn't been won yet by calling

    ///   the super(...) and then notifying any listener.

    /// @param _tokenId - ID of token on auction

    function cancelAuction(uint256 _tokenId) public

    {

      super.cancelAuction(_tokenId);

      if (listener != address(0)) {

        listener.auctionCancelled(_tokenId, msg.sender);

      }

    }



}