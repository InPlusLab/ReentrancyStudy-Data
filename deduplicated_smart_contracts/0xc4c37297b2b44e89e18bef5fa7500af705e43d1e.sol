/**

 *Submitted for verification at Etherscan.io on 2018-09-03

*/



pragma solidity 0.4.24;

pragma experimental "v0.5.0";

/******************************************************************************\

* Author: Nick Mudge, [emailÂ protected]

* Mokens

* Copyright (c) 2018

*

* Implements ERC998ERC20TopDown.

/******************************************************************************/

///////////////////////////////////////////////////////////////////////////////////

//Storage contracts

////////////

//Some delegate contracts are listed with storage contracts they inherit.

///////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////

//Mokens

///////////////////////////////////////////////////////////////////////////////////

contract Storage0 {

    // funcId => delegate contract

    mapping(bytes4 => address) internal delegates;

}

///////////////////////////////////////////////////////////////////////////////////

//MokenUpdates

//MokenOwner

//QueryMokenDelegates

///////////////////////////////////////////////////////////////////////////////////

contract Storage1 is Storage0 {

    address internal contractOwner;

    bytes[] internal funcSignatures;

    // signature => index+1

    mapping(bytes => uint256) internal funcSignatureToIndex;

}

///////////////////////////////////////////////////////////////////////////////////

//MokensSupportsInterfaces

///////////////////////////////////////////////////////////////////////////////////

contract Storage2 is Storage1 {

    mapping(bytes4 => bool) internal supportedInterfaces;

}

///////////////////////////////////////////////////////////////////////////////////

//MokenRootOwnerOf

//MokenERC721Metadata

///////////////////////////////////////////////////////////////////////////////////

contract Storage3 is Storage2 {

    struct Moken {

        string name;

        uint256 data;

        uint256 parentTokenId;

    }

    //tokenId => moken

    mapping(uint256 => Moken) internal mokens;

    uint256 internal mokensLength;

    // child address => child tokenId => tokenId+1

    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;

}

///////////////////////////////////////////////////////////////////////////////////

//MokenERC721Enumerable

//MokenLinkHash

///////////////////////////////////////////////////////////////////////////////////

contract Storage4 is Storage3 {

    // root token owner address => (tokenId => approved address)

    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;

    // token owner => (operator address => bool)

    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;

    // Mapping from owner to list of owned token IDs

    mapping(address => uint32[]) internal ownedTokens;

}

///////////////////////////////////////////////////////////////////////////////////

//MokenERC998ERC721TopDown

//MokenERC998ERC721TopDownBatch

//MokenERC721

//MokenERC721Batch

///////////////////////////////////////////////////////////////////////////////////

contract Storage5 is Storage4 {

    // tokenId => (child address => array of child tokens)

    mapping(uint256 => mapping(address => uint256[])) internal childTokens;

    // tokenId => (child address => (child token => child index)

    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;

    // tokenId => (child address => contract index)

    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;

    // tokenId => child contract

    mapping(uint256 => address[]) internal childContracts;

}

///////////////////////////////////////////////////////////////////////////////////

//MokenERC998ERC20TopDown

//MokenStateChange

///////////////////////////////////////////////////////////////////////////////////

contract Storage6 is Storage5 {

    // tokenId => token contract

    mapping(uint256 => address[]) internal erc20Contracts;

    // tokenId => (token contract => token contract index)

    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;

    // tokenId => (token contract => balance)

    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;

}



contract RootOwnerOfHelper is Storage3 {



    bytes32 constant ERC998_MAGIC_VALUE = 0xcd740db5;



    // Use Cases handled:

    // Case 1: Token owner is this contract and token

    // Case 2: Token owner is this contract and top-down composable.

    // Case 3: Token owner is top-down composable

    // Case 4: Token owner is an unknown contract

    // Case 5: Token owner is a user

    // Case 6: Token owner is a bottom-up composable

    // Case 7: Token owner is ERC721 token owned by top-down token

    // Case 8: Token owner is ERC721 token owned by unknown contract

    // Case 9: Token owner is ERC721 token owned by user

    function rootOwnerOf_(uint256 _tokenId) internal view returns (bytes32 rootOwner) {

        address rootOwnerAddress = address(mokens[_tokenId].data);

        require(rootOwnerAddress != address(0), "tokenId not found.");

        uint256 parentTokenId;

        bool isParent;



        while (rootOwnerAddress == address(this)) {

            parentTokenId = mokens[_tokenId].parentTokenId;

            isParent = parentTokenId > 0;

            if (isParent) {

                // Case 1: Token owner is this contract and token

                _tokenId = parentTokenId - 1;

            }

            else {

                // Case 2: Token owner is this contract and top-down composable.

                _tokenId = childTokenOwner[rootOwnerAddress][_tokenId] - 1;

            }

            rootOwnerAddress = address(mokens[_tokenId].data);

        }



        parentTokenId = mokens[_tokenId].parentTokenId;

        isParent = parentTokenId > 0;

        if (isParent) {

            parentTokenId--;

        }



        bytes memory calldata;

        bool callSuccess;



        if (isParent == false) {



            // success if this token is owned by a top-down token

            // 0xed81cdda == rootOwnerOfChild(address,uint256)

            calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);

            assembly {

                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)

                if callSuccess {

                    rootOwner := mload(calldata)

                }

            }

            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {

                // Case 3: Token owner is top-down composable

                return rootOwner;

            }

            else {

                // Case 4: Token owner is an unknown contract

                // Or

                // Case 5: Token owner is a user

                return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);

            }

        }

        else {



            // 0x43a61a8e == rootOwnerOf(uint256)

            calldata = abi.encodeWithSelector(0x43a61a8e, parentTokenId);

            assembly {

                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)

                if callSuccess {

                    rootOwner := mload(calldata)

                }

            }

            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {

                // Case 6: Token owner is a bottom-up composable

                // Or

                // Case 2: Token owner is top-down composable

                return rootOwner;

            }

            else {

                // token owner is ERC721

                address childContract = rootOwnerAddress;

                //0x6352211e == "ownerOf(uint256)"

                calldata = abi.encodeWithSelector(0x6352211e, parentTokenId);

                assembly {

                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)

                    if callSuccess {

                        rootOwnerAddress := mload(calldata)

                    }

                }

                require(callSuccess, "Call to ownerOf failed");



                // 0xed81cdda == rootOwnerOfChild(address,uint256)

                calldata = abi.encodeWithSelector(0xed81cdda, childContract, parentTokenId);

                assembly {

                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)

                    if callSuccess {

                        rootOwner := mload(calldata)

                    }

                }

                if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {

                    // Case 7: Token owner is ERC721 token owned by top-down token

                    return rootOwner;

                }

                else {

                    // Case 8: Token owner is ERC721 token owned by unknown contract

                    // Or

                    // Case 9: Token owner is ERC721 token owned by user

                    return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);

                }

            }

        }

    }

}



interface ERC20AndERC223 {

    function transferFrom(address _from, address _to, uint _value) external returns (bool success);

    function transfer(address _to, uint _value) external returns (bool success);

    function transfer(address _to, uint _value, bytes data) external returns (bool success);

}



contract MokenERC998ERC20TopDown is Storage6, RootOwnerOfHelper {



    event ReceivedERC20(address indexed from, uint256 indexed tokenId, address indexed erc20Contract, uint256 value);

    event TransferERC20(uint256 indexed tokenId, address indexed to, address indexed erc20Contract, uint256 value);



    function removeERC20(uint256 _tokenId, address _erc20Contract, uint256 _value) internal {

        if (_value == 0) {

            return;

        }

        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract];

        require(erc20Balance >= _value, "Not enough token available to transfer.");

        uint256 newERC20Balance = erc20Balance - _value;

        erc20Balances[_tokenId][_erc20Contract] = newERC20Balance;

        if (newERC20Balance == 0) {

            uint256 lastContractIndex = erc20Contracts[_tokenId].length - 1;

            address lastContract = erc20Contracts[_tokenId][lastContractIndex];

            if (_erc20Contract != lastContract) {

                uint256 contractIndex = erc20ContractIndex[_tokenId][_erc20Contract];

                erc20Contracts[_tokenId][contractIndex] = lastContract;

                erc20ContractIndex[_tokenId][lastContract] = contractIndex;

            }

            erc20Contracts[_tokenId].length--;

            delete erc20ContractIndex[_tokenId][_erc20Contract];

        }

    }





    function isContract(address addr) internal view returns (bool) {

        uint256 size;

        assembly {size := extcodesize(addr)}

        return size > 0;

    }



    function transferERC20(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) external {

        address rootOwner = address(rootOwnerOf_(_tokenId));

        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||

        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender, "msg.sender not rootOwner/operator/approved.");

        require(_to != address(0), "_to cannot be 0 address");

        removeERC20(_tokenId, _erc20Contract, _value);

        require(ERC20AndERC223(_erc20Contract).transfer(_to, _value), "ERC20 transfer failed.");

        emit TransferERC20(_tokenId, _to, _erc20Contract, _value);

    }



    // implementation of ERC 223

    function transferERC223(uint256 _tokenId, address _to, address _erc223Contract, uint256 _value, bytes _data) external {

        address rootOwner = address(rootOwnerOf_(_tokenId));

        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||

        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender, "msg.sender not rootOwner/operator/approved.");

        require(_to != address(0), "_to cannot be 0 address");

        removeERC20(_tokenId, _erc223Contract, _value);

        require(ERC20AndERC223(_erc223Contract).transfer(_to, _value, _data), "ERC223 transfer failed.");

        emit TransferERC20(_tokenId, _to, _erc223Contract, _value);

    }



    // this contract has to be approved first by _erc20Contract

    function getERC20(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) public {

        bool allowed = _from == msg.sender;

        if (!allowed) {

            uint256 remaining;

            // 0xdd62ed3e == allowance(address,address)

            bytes memory calldata = abi.encodeWithSelector(0xdd62ed3e, _from, msg.sender);

            bool callSuccess;

            assembly {

                callSuccess := staticcall(gas, _erc20Contract, add(calldata, 0x20), mload(calldata), calldata, 0x20)

                if callSuccess {

                    remaining := mload(calldata)

                }

            }

            require(callSuccess, "call to allowance failed");

            require(remaining >= _value, "Value greater than remaining");

            allowed = true;

        }

        require(allowed, "msg.sender not _from and has no allowance.");

        erc20Received(_from, _tokenId, _erc20Contract, _value);

        require(ERC20AndERC223(_erc20Contract).transferFrom(_from, this, _value), "ERC20 transfer failed.");

    }



    function erc20Received(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) internal {

        require(address(mokens[_tokenId].data) != address(0), "_tokenId does not exist.");

        if (_value == 0) {

            return;

        }

        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract];

        if (erc20Balance == 0) {

            erc20ContractIndex[_tokenId][_erc20Contract] = erc20Contracts[_tokenId].length;

            erc20Contracts[_tokenId].push(_erc20Contract);

        }

        erc20Balances[_tokenId][_erc20Contract] += _value;

        emit ReceivedERC20(_from, _tokenId, _erc20Contract, _value);

    }



    // used by ERC 223

    function tokenFallback(address _from, uint256 _value, bytes _data) external {

        require(_data.length > 0, "_data must contain the uint256 tokenId to transfer the token to.");

        require(isContract(msg.sender), "msg.sender is not a contract");

        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes

        uint256 tokenId;

        assembly {

            tokenId := calldataload(132)

        }

        if (_data.length < 32) {

            tokenId = tokenId >> 256 - _data.length * 8;

        }

        //END TODO

        erc20Received(_from, tokenId, msg.sender, _value);

    }



    function balanceOfERC20(uint256 _tokenId, address _erc20Contract) external view returns (uint256) {

        return erc20Balances[_tokenId][_erc20Contract];

    }



    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address) {

        require(_index < erc20Contracts[_tokenId].length, "Contract address does not exist for this token and index.");

        return erc20Contracts[_tokenId][_index];

    }



    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256) {

        return erc20Contracts[_tokenId].length;

    }

}