/**

 *Submitted for verification at Etherscan.io on 2019-05-03

*/



pragma solidity ^0.5.2;



// File: node_modules/openzeppelin-solidity/contracts/access/Roles.sol



/**

 * @title Roles

 * @dev Library for managing addresses assigned to a Role.

 */

library Roles {

    struct Role {

        mapping (address => bool) bearer;

    }



    /**

     * @dev give an account access to this role

     */

    function add(Role storage role, address account) internal {

        require(account != address(0));

        require(!has(role, account));



        role.bearer[account] = true;

    }



    /**

     * @dev remove an account's access to this role

     */

    function remove(Role storage role, address account) internal {

        require(account != address(0));

        require(has(role, account));



        role.bearer[account] = false;

    }



    /**

     * @dev check if an account has this role

     * @return bool

     */

    function has(Role storage role, address account) internal view returns (bool) {

        require(account != address(0));

        return role.bearer[account];

    }

}



// File: contracts/Adminable.sol



contract Adminable {

    using Roles for Roles.Role;



    event AdminAdded(address indexed account);

    event AdminRemoved(address indexed account);



    Roles.Role private _admins;



    constructor () internal {

        _addAdmin(msg.sender);

    }



    modifier onlyAdmin() {

        require(isAdmin(msg.sender));

        _;

    }



    function isAdmin(address account) public view returns (bool) {

        return _admins.has(account);

    }



    function addAdmin(address account) public onlyAdmin {

        _addAdmin(account);

    }



    function renounceAdmin() public {

        _removeAdmin(msg.sender);

    }



    function _addAdmin(address account) internal {

        _admins.add(account);

        emit AdminAdded(account);

    }



    function _removeAdmin(address account) internal {

        _admins.remove(account);

        emit AdminRemoved(account);

    }

}



// File: contracts/Authorizable.sol



contract Authorizable is Adminable {



    address public authorizedAddress;

    

    modifier onlyAuthorized() {

        require(msg.sender == authorizedAddress);

        _;

    }



    function updateAuthorizedAddress(address _address) onlyAdmin public {

        authorizedAddress = _address;

    }



}



// File: contracts/SoarStorage.sol



/**

    @title Soar Storage

    @author Marek Tlacbaba ([emailÂ protected])

    @dev This smart contract behave as simple storage and can be 

    accessed only by authorized caller who is responsible for any

    checks and validation. The authorized caller can updated by 

    admins so it allows to update application logic 

    and keeping data and events untouched.

*/



//TODO

// use safeMath

contract SoarStorage is Authorizable {



    /**

    Status: 

        0 - unknown

        1 - created

        2 - updated

        3 - deleted

    */

    struct ListingObject {

        address owner;

        address sponsor;

        bytes12 geohash;

        mapping (address => mapping (bytes32 => uint )) sales;

        uint256 salesCount;

        uint8 status;

    }



    uint public counter = 0;

    mapping (bytes32 => ListingObject) internal listings;



    event Listing (

        bytes32 filehash,

        address indexed owner,

        address indexed sponsor,

        string previewUrl, 

        string url, 

        string pointWKT,

        bytes12 geohash, 

        string metadata

    );



    event ListingUpdated (

        bytes32 filehash,

        address indexed owner, 

        address indexed sponsor,

        string previewUrl, 

        string url, 

        string pointWKT,

        bytes12 geohash, 

        string metadata 

    );



    event ListingDeleted (

        bytes32 filehash,

        address indexed owner,

        address indexed sponsor

    );



    event Sale(

        address indexed buyer, 

        bytes32 id, 

        address indexed owner, 

        address sponsor,

        bytes32 indexed filehash,

        uint price 

    );



    function putListing (

        bytes32 _filehash,

        address _owner,

        address _sponsor,

        string memory _previewUrl, 

        string memory _url, 

        string memory _pointWKT, 

        bytes12 _geohash, 

        string memory _metadata

    ) 

        public 

        onlyAuthorized 

    {

        listings[_filehash].owner = _owner;

        listings[_filehash].sponsor = _sponsor;

        listings[_filehash].geohash = _geohash;

        listings[_filehash].status = 1;

        counter++;

        emit Listing(

            _filehash, 

            _owner,

            _sponsor, 

            _previewUrl, 

            _url, 

            _pointWKT, 

            _geohash, 

            _metadata

        );

    }



    function updateListing (

        bytes32 _filehash,

        address _owner,

        address _sponsor,

        string memory _previewUrl, 

        string memory _url, 

        string memory _pointWKT, 

        bytes12 _geohash, 

        string memory _metadata 

    ) 

        public 

        onlyAuthorized 

    {

        listings[_filehash].geohash = _geohash;

        listings[_filehash].status = 2;

        emit ListingUpdated(

            _filehash, 

            _owner,

            _sponsor, 

            _previewUrl, 

            _url, 

            _pointWKT, 

            _geohash, 

            _metadata

        );

    }



    function deleteListing(

        bytes32 _filehash 

    )

        public 

        onlyAuthorized 

    {

        listings[_filehash].status = 3;

        counter--;

        emit ListingDeleted(_filehash, listings[_filehash].owner, listings[_filehash].sponsor);

    }



    function putSale (

        address _buyer,

        bytes32 _id,

        bytes32 _filehash, 

        uint256 _price

    ) 

        public 

        onlyAuthorized 

    {

        listings[_filehash].sales[_buyer][_id] = _price;

        listings[_filehash].salesCount++;

        emit Sale(_buyer, _id, listings[_filehash].owner, listings[_filehash].sponsor, _filehash, _price);

    }



    function getListingDetails(bytes32 _filehash, address _user, bytes32 _id) 

        public view

        returns (

            address owner_,

            address sponsor_,

            bytes12 geohash_,

            uint8 status_,

            uint256 sale_

        )

    {

        owner_ = listings[_filehash].owner;

        sponsor_ = listings[_filehash].sponsor;

        geohash_ = listings[_filehash].geohash;

        status_ = listings[_filehash].status;

        sale_ = listings[_filehash].sales[_user][_id];

    }

}