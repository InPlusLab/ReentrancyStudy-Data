/**

 *Submitted for verification at Etherscan.io on 2018-11-10

*/



/*

 * SuperFOMO - §Ù§Ñ§â§Ñ§Ò§Ñ§ä§í§Ó§Ñ§Û §Õ§à 11,5% §Ó §ã§å§ä§Ü§Ú!

 *

 * §®§Ú§ß. §â§Ñ§Ù§Ş§Ö§â §Õ§Ö§á§à§Ù§Ú§ä§Ñ 0.05 eth

 * §®§Ú§ß. §â§Ñ§Ù§Ş§Ö§â §Õ§Ö§á§à§Ù§Ú§ä§Ñ §Õ§İ§ñ §å§é§Ñ§ã§ä§Ú§ñ §Ó §â§à§Ù§í§Ô§â§í§ê§Ö §Õ§Ø§Ö§Ü-§á§à§ä§Ñ: 1eth

 *

 * §³§ç§Ö§Ş§Ñ §â§Ñ§ã§á§â§Ö§Õ§Ö§İ§Ö§ß§Ú§ñ §Ó§ç§à§Õ§ñ§ë§Ú§ç §ã§â§Ö§Õ§ã§ä§Ó:

 * 100% §ß§Ñ §Ó§í§á§İ§Ñ§ä§í §å§é§Ñ§ã§ä§ß§Ú§Ü§Ñ§Ş

 *

 * §ª§¯§£§¦§³§´§ª§¸§ª§°§¯§¯§½§« §±§­§¡§¯:

 * §é§Ö§Ş §á§à§Ù§Ø§Ö §Ù§Ñ§ê§Ö§İ - §ä§Ö§Ş §Ò§à§İ§î§ê§Ö §Ù§Ñ§â§Ñ§Ò§à§ä§Ñ§İ!

 *

 * §¬§Ñ§Ø§Õ§í§Û §Õ§Ö§á§à§Ù§Ú§ä §â§Ñ§Ò§à§ä§Ñ§Ö§ä §à§ä§Õ§Ö§İ§î§ß§à §Õ§à §ã§Ó§à§Ö§Ô§à §å§Õ§Ó§à§Ö§ß§Ú§ñ

 *

 * §¥§Ö§á§à§Ù§Ú§ä§í §ã§Õ§Ö§İ§Ñ§ß§ß§í§Ö §Ó §á§Ö§â§Ú§à§Õ §ã 1 §á§à 12 §Õ§Ö§ß§î §Ø§Ú§Ù§ß§Ú §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ: 2,5% §Ó §Õ§Ö§ß§î

 * §¥§Ö§á§à§Ù§Ú§ä§í §ã§Õ§Ö§İ§Ñ§ß§ß§í§Ö §Ó §á§Ö§â§Ú§à§Õ §ã 12 §á§à 18 §Õ§Ö§ß§î §Ø§Ú§Ù§ß§Ú §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ: 3,5% §Ó §Õ§Ö§ß§î

 * §¥§Ö§á§à§Ù§Ú§ä§í §ã§Õ§Ö§İ§Ñ§ß§ß§í§Ö §Ó §á§Ö§â§Ú§à§Õ §ã 18 §á§à 24 §Õ§Ö§ß§î §Ø§Ú§Ù§ß§Ú §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ: 4,5% §Ó §Õ§Ö§ß§î

 * §¥§Ö§á§à§Ù§Ú§ä§í §ã§Õ§Ö§İ§Ñ§ß§ß§í§Ö §Ó §á§Ö§â§Ú§à§Õ §ã 24 §á§à 30 §Õ§Ö§ß§î §Ø§Ú§Ù§ß§Ú §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ: 5,5% §Ó §Õ§Ö§ß§î

 * §¥§Ö§á§à§Ù§Ú§ä§í §ã§Õ§Ö§İ§Ñ§ß§ß§í§Ö §Ó §á§Ö§â§Ú§à§Õ §ã 30 §á§à 36 §Õ§Ö§ß§î §Ø§Ú§Ù§ß§Ú §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ: 6,5% §Ó §Õ§Ö§ß§î

 * §¥§Ö§á§à§Ù§Ú§ä§í §ã§Õ§Ö§İ§Ñ§ß§ß§í§Ö §Ó §á§Ö§â§Ú§à§Õ §ã 36 §á§à 42 §Õ§Ö§ß§î §Ø§Ú§Ù§ß§Ú §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ: 7,5% §Ó §Õ§Ö§ß§î

 * §¥§Ö§á§à§Ù§Ú§ä§í §ã§Õ§Ö§İ§Ñ§ß§ß§í§Ö §Ó §á§Ö§â§Ú§à§Õ §ã 42 §á§à 48 §Õ§Ö§ß§î §Ø§Ú§Ù§ß§Ú §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ: 8,5% §Ó §Õ§Ö§ß§î

 * §¥§Ö§á§à§Ù§Ú§ä§í §ã§Õ§Ö§İ§Ñ§ß§ß§í§Ö §Ó §á§Ö§â§Ú§à§Õ §ã 48 §á§à 54 §Õ§Ö§ß§î §Ø§Ú§Ù§ß§Ú §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ: 9,5% §Ó §Õ§Ö§ß§î

 * §¥§Ö§á§à§Ù§Ú§ä§í §ã§Õ§Ö§İ§Ñ§ß§ß§í§Ö §Ó §á§Ö§â§Ú§à§Õ §ã 54 §Õ§ß§ñ §Ø§Ú§Ù§ß§Ú §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ: 10% §Ó §Õ§Ö§ß§î

 *

 * §¢§°§¯§µ§³ §·§°§­§¥§¦§²§¡§®:

 * §´§Ö§Ş, §Ü§ä§à §ß§Ö §Ù§Ñ§Ü§Ñ§Ù§í§Ó§Ñ§Ö§ä §Ó§í§Ó§à§Õ §á§â§à§è§Ö§ß§ä§à§Ó §Ó §ä§Ö§é§Ö§ß§Ú§Ö 48 §é§Ñ§ã§à§Ó §Ó§Ü§İ§ğ§é§Ñ§Ö§ä§ã§ñ §Ò§à§ß§å§ã §ß§Ñ §Ó§ã§Ö §Õ§Ö§á§à§Ù§Ú§ä§í +1,5% §Ó §ã§å§ä§Ü§Ú §Ü§Ñ§Ø§Õ§í§Û §Õ§Ö§ß§î.

 *

 * §¥§¨§¦§¬-§±§°§´:

 * §³ §Ü§Ñ§Ø§Õ§à§Ô§à §Õ§Ö§á§à§Ù§Ú§ä§Ñ 3% "§Ù§Ñ§Ş§à§â§Ñ§Ø§Ú§Ó§Ñ§Ö§ä§ã§ñ" §ß§Ñ §Ò§Ñ§İ§Ñ§ß§ã§Ö §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ §Ó §æ§à§ß§Õ §Õ§Ø§Ö§Ü-§á§à§ä§Ñ.

 *

 * §µ§ã§İ§à§Ó§Ú§ñ §â§à§Ù§í§Ô§â§í§ê§Ñ:

 * §±§â§Ú §à§ä§ã§å§ä§ã§ä§Ó§Ú§Ú §ß§à§Ó§í§ç §Õ§Ö§á§à§Ù§Ú§ä§à§Ó (§à§ä 1 eth §Ú §Ò§à§İ§Ö§Ö) §Ò§à§İ§Ö§Ö 24 §é§Ñ§ã§à§Ó §æ§à§ß§Õ §Õ§Ø§Ö§Ü-§á§à§ä§Ñ §â§Ñ§ã§á§â§Ö§Õ§Ö§İ§ñ§Ö§ä§ã§ñ §Ş§Ö§Ø§Õ§å §á§à§ã§İ§Ö§Õ§ß§Ú§Ş§Ú 5 §Ó§Ü§İ§Ñ§Õ§é§Ú§Ü§Ñ§Ş§Ú §ã §Õ§Ö§á§à§Ù§Ú§ä§à§Ş 1 eth §Ú §Ò§à§İ§Ö§Ö.

 * 60% §Õ§Ø§Ö§Ü-§á§à§ä§Ñ §ß§Ñ§é§Ú§ã§İ§ñ§ğ§ä§ã§ñ §Õ§İ§ñ §Ó§í§Ó§à§Õ§Ñ §á§à§ã§İ§Ö§Õ§ß§Ö§Ş§å §Ó§Ü§İ§Ñ§Õ§é§Ú§Ü§å §Ú §á§à 10% §Ö§ë§Ö 4§Ş §Ó§Ü§İ§Ñ§Õ§é§Ú§Ü§Ñ§Ş §ã §Õ§Ö§á§à§Ù§Ú§ä§Ñ§Ş§Ú §à§ä  1 eth §Ú §Ò§à§İ§Ö§Ö.

 * §±§à§ã§İ§Ö §â§à§Ù§í§Ô§â§í§ê§Ñ §Õ§Ø§Ö§Ü-§á§à§ä §ß§Ñ§é§Ú§ß§Ñ§Ö§ä §ß§Ñ§Ü§Ñ§á§İ§Ú§Ó§Ñ§ä§î§ã§ñ §Ù§Ñ§ß§à§Ó§à.

 *

 * §±§Ñ§â§ä§ß§Ö§â§ã§Ü§Ñ§ñ §á§â§à§Ô§â§Ñ§Ş§Ş§Ñ:

 * §¥§İ§ñ §å§é§Ñ§ã§ä§Ú§ñ §Ó §á§Ñ§â§ä§ß§Ö§â§ã§Ü§à§Û §á§â§à§Ô§â§Ñ§Ş§Ş§Ö §å §Ó§Ñ§ã §Õ§à§İ§Ø§Ö§ß §Ò§í§ä§î §ã§Ó§à§Û §Õ§Ö§á§à§Ù§Ú§ä, §á§à §Ü§à§ä§à§â§à§Ş§å §Ó§í §á§à§İ§å§é§Ñ§Ö§ä§Ö §ß§Ñ§é§Ú§ã§İ§Ö§ß§Ú§ñ.

 * §¥§İ§ñ §á§à§İ§å§é§Ö§ß§Ú§ñ §Ó§à§Ù§ß§Ñ§Ô§â§Ñ§Ø§Õ§Ö§ß§Ú§ñ §Ó§Ñ§ê §á§â§Ú§Ô§İ§Ñ§ê§Ö§ß§ß§í§Û §Õ§à§İ§Ø§Ö§ß §å§Ü§Ñ§Ù§Ñ§ä§î §Ñ§Õ§â§Ö§ã §Ó§Ñ§ê§Ö§Ô§à §Ü§à§ê§Ö§İ§î§Ü§Ñ eth §Ó §á§à§İ§Ö data.

 *

 * §¢§à§ß§å§ã §á§â§Ú§Ô§İ§Ñ§ê§Ö§ß§ß§à§Ş§å: §Ó§ß§à§ã§Ú§Ş§í§Û §Õ§Ö§á§à§Ù§Ú§ä §å§Ó§Ö§é§Ú§Ó§Ñ§Ö§ä§ã§ñ §ß§Ñ 2%

 * §¢§à§ß§å§ã §á§â§Ú§Ô§İ§Ñ§ã§Ú§ä§Ö§İ§ğ: §Ñ§Ó§ä§à§Ş§Ñ§ä§Ú§é§Ö§ã§Ü§Ú §Ó§í§á§İ§Ñ§é§Ú§Ó§Ñ§Ö§ä§ã§ñ 5% §à§ä §ã§å§Ş§Ş§í §á§à§á§à§İ§ß§Ö§ß§Ú§ñ

 *

 * §ª§¯§³§´§²§µ§¬§¸§ª§Á:

 * *  1. §°§ä§á§â§Ñ§Ó§Ú§ä§î eth (§Ò§à§İ§î§ê§Ö 0.05) §Õ§İ§ñ §ã§à§Ù§Õ§Ñ§ß§Ú§ñ §Õ§Ö§á§à§Ù§Ú§ä§Ñ.

 * *  2. §¥§İ§ñ §á§à§İ§å§é§Ö§ß§Ú§ñ §Ó§í§á§İ§Ñ§ä§í §á§à §Ó§ã§Ö§Ş §Õ§Ö§á§à§Ù§Ú§ä§Ñ§Ş §ß§Ö§à§Ò§ç§à§Õ§Ú§Ş§à §à§ä§á§â§Ñ§Ó§Ú§ä§î §à§ä 0 §Õ§à 0,05 eth §ß§Ñ §Ñ§Õ§â§Ö§ã §ã§Ş§Ñ§â§ä §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ, §ã§é§Ö§ä§é§Ú§Ü §ç§à§İ§Õ§Ñ §á§â§Ú §ï§ä§à §ã§Ò§â§Ñ§ã§í§Ó§Ñ§Ö§ä§ã§ñ.

 * *  3. §¦§ã§İ§Ú §à§ä§á§â§Ñ§Ó§İ§Ö§ß§à 0,05 §Ú§İ§Ú §Ò§à§İ§Ö§Ö eth §ã§à§Ù§Õ§Ñ§Ö§ä§ã§ñ §ß§à§Ó§í§Û §Õ§Ö§á§à§Ù§Ú§ä, §ß§à §ß§Ñ§é§Ú§ã§İ§Ö§ß§ß§í§Ö §á§â§à§è§Ö§ß§ä§í §ß§Ö §Ó§í§á§İ§Ñ§é§Ú§Ó§Ñ§ğ§ä§ã§ñ §Ú §ã§é§Ö§ä§é§Ú§Ü §ç§à§İ§Õ§Ñ §ß§Ö §ã§Ò§â§Ñ§ã§í§Ó§Ñ§Ö§ä§ã§ñ. §³ §Ü§Ñ§Ø§Õ§à§Û §Ó§í§á§İ§Ñ§ä§í 12% §à§ä§á§â§Ñ§Ó§İ§ñ§Ö§ä§ã§ñ §ß§Ñ §â§Ö§Ü§İ§Ñ§Ş§å §Ú 3% §ß§Ñ §ä§Ö§ç. §á§à§Õ§Õ§Ö§â§Ø§Ü§å §á§â§à§Ö§Ü§ä§Ñ.

 *

 */

















pragma solidity 0.4.25;





library SafeMath {





    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {

        if (_a == 0) {

            return 0;

        }



        uint256 c = _a * _b;

        require(c / _a == _b);



        return c;

    }



    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {

        require(_b > 0);

        uint256 c = _a / _b;



        return c;

    }



    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {

        require(_b <= _a);

        uint256 c = _a - _b;



        return c;

    }



    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {

        uint256 c = _a + _b;

        require(c >= _a);



        return c;

    }



    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



contract Storage {



    address private owner;



    mapping (address => Investor) investors;



    struct Investor {

        uint index;

        mapping (uint => uint) deposit;

        mapping (uint => uint) interest;

        mapping (uint => uint) withdrawals;

        mapping (uint => uint) start;

        uint checkpoint;

    }



    constructor() public {

        owner = msg.sender;

    }



    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    function updateInfo(address _address, uint _value, uint _interest) external onlyOwner {

        investors[_address].deposit[investors[_address].index] += _value;

        investors[_address].start[investors[_address].index] = block.timestamp;

        investors[_address].interest[investors[_address].index] = _interest;

    }



    function updateCheckpoint(address _address) external onlyOwner {

        investors[_address].checkpoint = block.timestamp;

    }



    function updateWithdrawals(address _address, uint _index, uint _withdrawal) external onlyOwner {

        investors[_address].withdrawals[_index] += _withdrawal;

    }



    function updateIndex(address _address) external onlyOwner {

        investors[_address].index += 1;

    }



    function ind(address _address) external view returns(uint) {

        return investors[_address].index;

    }



    function d(address _address, uint _index) external view returns(uint) {

        return investors[_address].deposit[_index];

    }



    function i(address _address, uint _index) external view returns(uint) {

        return investors[_address].interest[_index];

    }



    function w(address _address, uint _index) external view returns(uint) {

        return investors[_address].withdrawals[_index];

    }



    function s(address _address, uint _index) external view returns(uint) {

        return investors[_address].start[_index];

    }



    function c(address _address) external view returns(uint) {

        return investors[_address].checkpoint;

    }

}



contract SuperFOMO {

    using SafeMath for uint;



    address public owner;

    address advertising;

    address techsupport;



    uint waveStartUp;

    uint jackPot;

    uint lastLeader;



    address[] top;



    Storage x;



    event LogInvestment(address indexed _addr, uint _value);

    event LogPayment(address indexed _addr, uint _value);

    event LogReferralInvestment(address indexed _referrer, address indexed _referral, uint _value);

    event LogGift(address _firstAddr, address _secondAddr, address _thirdAddr, address _fourthAddr, address _fifthAddr);

    event LogNewWave(uint _waveStartUp);

    event LogNewLeader(address _leader);



    modifier notOnPause() {

        require(waveStartUp <= block.timestamp);

        _;

    }



    modifier notFromContract() {

        address addr = msg.sender;

        uint size;

        assembly { size := extcodesize(addr) }

        require(size <= 0);

        _;

    }



    constructor(address _advertising, address _techsupport) public {

        owner = msg.sender;

        advertising = _advertising;

        techsupport = _techsupport;

        waveStartUp = block.timestamp;

        x = new Storage();

    }



    function renounceOwnership() external {

        require(msg.sender == owner);

        owner = 0x0;

    }



    function bytesToAddress(bytes _source) internal pure returns(address parsedreferrer) {

        assembly {

            parsedreferrer := mload(add(_source,0x14))

        }

        return parsedreferrer;

    }



    function setRef() internal returns(uint) {

        address _referrer = bytesToAddress(bytes(msg.data));

        if (_referrer != msg.sender && getDividends(_referrer) > 0) {

            _referrer.transfer(msg.value / 20);



            emit LogReferralInvestment(_referrer, msg.sender, msg.value);

            return(msg.value / 50);

        } else {

            advertising.transfer(msg.value / 20);

            return(0);

        }

    }



    function getInterest() public view returns(uint) {

        uint multiplier = (block.timestamp.sub(waveStartUp)) / 6 days;

        if (multiplier == 0) {

            return 25;

        }

        if (multiplier <= 8){

            return(15 + (multiplier * 10));

        } else {

            return 100;

        }

    }



    function toTheTop() internal {

        top.push(msg.sender);

        lastLeader = block.timestamp;



        emit LogNewLeader(msg.sender);

    }



    function payDay() internal {

        top[top.length - 1].transfer(jackPot * 3 / 5);

        top[top.length - 2].transfer(jackPot / 10);

        top[top.length - 3].transfer(jackPot / 10);

        top[top.length - 4].transfer(jackPot / 10);

        top[top.length - 5].transfer(jackPot / 10);

        jackPot = 0;

        lastLeader = block.timestamp;

        emit LogGift(top[top.length - 1], top[top.length - 2], top[top.length - 3], top[top.length - 4], top[top.length - 5]);

    }



    function() external payable {

        if (msg.value < 50000000000000000) {

            msg.sender.transfer(msg.value);

            withdraw();

        } else {

            invest();

        }

    }



    function invest() public payable notOnPause notFromContract {



        require(msg.value >= 0.05 ether);

        jackPot += msg.value * 3 / 100;



        if (x.d(msg.sender, 0) > 0) {

            x.updateIndex(msg.sender);

        } else {

            x.updateCheckpoint(msg.sender);

        }



        if (msg.data.length == 20) {

            uint addend = setRef();

        } else {

            advertising.transfer(msg.value / 20);

        }



        x.updateInfo(msg.sender, msg.value + addend, getInterest());





        if (msg.value >= 1 ether) {

            toTheTop();

        }



        emit LogInvestment(msg.sender, msg.value);

    }



    function withdraw() public {



        uint _payout;



        uint _multiplier;



        if (block.timestamp > x.c(msg.sender) + 2 days) {

            _multiplier = 1;

        }



        for (uint i = 0; i <= x.ind(msg.sender); i++) {

            if (x.w(msg.sender, i) < x.d(msg.sender, i) * 2) {

                if (x.s(msg.sender, i) <= x.c(msg.sender)) {

                    uint dividends = (x.d(msg.sender, i).mul(_multiplier.mul(15).add(x.i(msg.sender, i))).div(1000)).mul(block.timestamp.sub(x.c(msg.sender).add(_multiplier.mul(2 days)))).div(1 days);

                    dividends = dividends.add(x.d(msg.sender, i).mul(x.i(msg.sender, i)).div(1000).mul(_multiplier).mul(2));

                    if (x.w(msg.sender, i) + dividends <= x.d(msg.sender, i) * 2) {

                        x.updateWithdrawals(msg.sender, i, dividends);

                        _payout = _payout.add(dividends);

                    } else {

                        _payout = _payout.add((x.d(msg.sender, i).mul(2)).sub(x.w(msg.sender, i)));

                        x.updateWithdrawals(msg.sender, i, x.d(msg.sender, i) * 2);

                    }

                } else {

                    dividends = (x.d(msg.sender, i).mul(_multiplier.mul(15).add(x.i(msg.sender, i))).div(1000)).mul(block.timestamp.sub(x.s(msg.sender, i).add(_multiplier.mul(2 days)))).div(1 days);

                    dividends = dividends.add(x.d(msg.sender, i).mul(x.i(msg.sender, i)).div(1000).mul(_multiplier).mul(2));

                    if (x.w(msg.sender, i) + dividends <= x.d(msg.sender, i) * 2) {

                        x.updateWithdrawals(msg.sender, i, dividends);

                        _payout = _payout.add(dividends);

                    } else {

                        _payout = _payout.add((x.d(msg.sender, i).mul(2)).sub(x.w(msg.sender, i)));

                        x.updateWithdrawals(msg.sender, i, x.d(msg.sender, i) * 2);

                    }

                }



            }

        }



        if (_payout > 0) {

            if (_payout > address(this).balance && address(this).balance <= 0.1 ether) {

                nextWave();

                return;

            }

            x.updateCheckpoint(msg.sender);

            advertising.transfer(_payout * 3 / 25);

            techsupport.transfer(_payout * 3 / 100);

            msg.sender.transfer(_payout * 17 / 20);



            emit LogPayment(msg.sender, _payout * 17 / 20);

        }



        if (block.timestamp >= lastLeader + 1 days && top.length >= 5) {

            payDay();

        }

    }



    function nextWave() private {

        top.length = 0;

        x = new Storage();

        waveStartUp = block.timestamp + 10 days;

        emit LogNewWave(waveStartUp);

    }



    function getDeposits(address _address) public view returns(uint Invested) {

        uint _sum;

        for (uint i = 0; i <= x.ind(_address); i++) {

            if (x.w(_address, i) < x.d(_address, i) * 2) {

                _sum += x.d(_address, i);

            }

        }

        Invested = _sum;

    }



    function getDepositN(address _address, uint _number) public view returns(uint Deposit_N) {

        if (x.w(_address, _number - 1) < x.d(_address, _number - 1) * 2) {

            Deposit_N = x.d(_address, _number - 1);

        } else {

            Deposit_N = 0;

        }

    }



    function getDividends(address _address) public view returns(uint Dividends) {



        uint _payout;

        uint _multiplier;



        if (block.timestamp > x.c(_address) + 2 days) {

            _multiplier = 1;

        }



        for (uint i = 0; i <= x.ind(_address); i++) {

            if (x.w(_address, i) < x.d(_address, i) * 2) {

                if (x.s(_address, i) <= x.c(_address)) {

                    uint dividends = (x.d(_address, i).mul(_multiplier.mul(15).add(x.i(_address, i))).div(1000)).mul(block.timestamp.sub(x.c(_address).add(_multiplier.mul(2 days)))).div(1 days);

                    dividends += (x.d(_address, i).mul(x.i(_address, i)).div(1000).mul(_multiplier).mul(2));

                    if (x.w(_address, i) + dividends <= x.d(_address, i) * 2) {

                        _payout = _payout.add(dividends);

                    } else {

                        _payout = _payout.add((x.d(_address, i).mul(2)).sub(x.w(_address, i)));

                    }

                } else {

                    dividends = (x.d(_address, i).mul(_multiplier.mul(15).add(x.i(_address, i))).div(1000)).mul(block.timestamp.sub(x.s(_address, i).add(_multiplier.mul(2 days)))).div(1 days);

                    dividends += (x.d(_address, i).mul(x.i(_address, i)).div(1000).mul(_multiplier).mul(2));

                    if (x.w(_address, i) + dividends <= x.d(_address, i) * 2) {

                        _payout = _payout.add(dividends);

                    } else {

                        _payout = _payout.add((x.d(_address, i).mul(2)).sub(x.w(_address, i)));

                    }

                }



            }

        }



        Dividends = _payout * 17 / 20;

    }



    function getWithdrawals(address _address) external view returns(uint) {

        uint _sum;

        for (uint i = 0; i <= x.ind(_address); i++) {

            if (x.w(_address, i) < x.d(_address, i) * 2) {

                _sum += x.d(_address, i);

            }

        }

        return(_sum);

    }



    function getTop() external view returns(address, address, address, address, address) {

        return(top[top.length - 1], top[top.length - 2], top[top.length - 3], top[top.length - 4], top[top.length - 5]);

    }



    function getJackPot() external view returns(uint) {

        return(jackPot);

    }

    

    function getNextPayDay() external view returns(uint) {

        return(lastLeader + 1 days);

    }



}