/**

 *Submitted for verification at Etherscan.io on 2019-01-11

*/



pragma solidity ^0.4.24;



contract ERC20Interface {

    function totalSupply() public view returns (uint);

    function balanceOf(address tokenOwner) public view returns (uint balance);

    function transfer(address to, uint tokens) public returns (bool success);



    

    //function allowance(address tokenOwner, address spender) public view returns (uint remaining);

    //function approve(address spender, uint tokens) public returns (bool success);

    //function transferFrom(address from, address to, uint tokens) public returns (bool success);

    

    event Transfer(address indexed from, address indexed to, uint tokens);

    //event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}



contract Ownable {

  address public owner;



  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



  constructor() public {

    owner = msg.sender;

  }



  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



}





contract medcarednaio is ERC20Interface, Ownable{

    string public name = "medcaredna.io";

    string public symbol = "mcd";

    uint public decimals = 18;

    

    uint public supply;

    address public founder;

    

    mapping(address => uint) public balances;





 event Transfer(address indexed from, address indexed to, uint tokens);





    constructor() public{

        supply = 10000000000000000000000000;

        founder = msg.sender;

        balances[founder] = supply;

    }

    

    

    function totalSupply() public view returns (uint){

        return supply;

    }

    

    function balanceOf(address tokenOwner) public view returns (uint balance){

         return balances[tokenOwner];

     }

     

     

    //transfer from the owner balance to another address

    function transfer(address to, uint tokens) public returns (bool success){

         require(balances[msg.sender] >= tokens && tokens > 0);

         

         balances[to] += tokens;

         balances[msg.sender] -= tokens;

         emit Transfer(msg.sender, to, tokens);

         return true;

     }

     

     

     function burn(uint256 _value) public returns (bool success) {

        require(balances[founder] >= _value);   // Check if the sender has enough

        balances[founder] -= _value;            // Subtract from the sender

        supply -= _value;                      // Updates totalSupply

        return true;

    }

     

}