/**

 *Submitted for verification at Etherscan.io on 2018-10-05

*/



pragma solidity 0.4.24;





/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

    uint256 public totalSupply;

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

}



/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public view returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



/**

 * Safe unsigned safe math.

 *

 * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli

 *

 * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol

 *

 * Maintained here until merged to mainline zeppelin-solidity.

 *

 */

library SafeMathLibExt {



    function times(uint a, uint b) public pure returns (uint) {

        uint c = a * b;

        assert(a == 0 || c / a == b);

        return c;

    }



    function divides(uint a, uint b) public pure returns (uint) {

        assert(b > 0);

        uint c = a / b;

        assert(a == b * c + a % b);

        return c;

    }



    function minus(uint a, uint b) public pure returns (uint) {

        assert(b <= a);

        return a - b;

    }



    function plus(uint a, uint b) public pure returns (uint) {

        uint c = a + b;

        assert(c >= a);

        return c;

    }



}



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address public owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

    * @dev The Ownable constructor sets the original `owner` of the contract to the sender

    * account.

    */

    constructor () public {

        owner = msg.sender;

    }



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner);

        _;

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    * @param newOwner The address to transfer ownership to.

    */

    function transferOwnership(address newOwner) public onlyOwner {

        require(newOwner != address(0));

        emit OwnershipTransferred(owner, newOwner);

        owner = newOwner;

    }

}



contract Allocatable is Ownable {



  /** List of agents that are allowed to allocate new tokens */

    mapping (address => bool) public allocateAgents;



    event AllocateAgentChanged(address addr, bool state  );



  /**

   * Owner can allow a crowdsale contract to allocate new tokens.

   */

    function setAllocateAgent(address addr, bool state) public onlyOwner  

    {

        allocateAgents[addr] = state;

        emit AllocateAgentChanged(addr, state);

    }



    modifier onlyAllocateAgent() {

        //Only crowdsale contracts are allowed to allocate new tokens

        require(allocateAgents[msg.sender]);

        _;

    }

}



/**

 * Contract to enforce Token Vesting

 */

contract TokenVesting is Allocatable {



    using SafeMathLibExt for uint;



    address public crowdSaleTokenAddress;



    /** keep track of total tokens yet to be released, 

     * this should be less than or equal to UTIX tokens held by this contract. 

     */

    uint256 public totalUnreleasedTokens;



    // default vesting parameters

    uint256 private startAt = 0;

    uint256 private cliff = 1;

    uint256 private duration = 4; 

    uint256 private step = 300; //15778463;  //2592000;

    bool private changeFreezed = false;



    struct VestingSchedule {

        uint256 startAt;

        uint256 cliff;

        uint256 duration;

        uint256 step;

        uint256 amount;

        uint256 amountReleased;

        bool changeFreezed;

    }



    mapping (address => VestingSchedule) public vestingMap;



    event VestedTokensReleased(address _adr, uint256 _amount);

    

    constructor(address _tokenAddress) public {

        

        crowdSaleTokenAddress = _tokenAddress;

    }



    /** Modifier to check if changes to vesting is freezed  */

    modifier changesToVestingFreezed(address _adr) {

        require(vestingMap[_adr].changeFreezed);

        _;

    }



    /** Modifier to check if changes to vesting is not freezed yet  */

    modifier changesToVestingNotFreezed(address adr) {

        require(!vestingMap[adr].changeFreezed); // if vesting not set then also changeFreezed will be false

        _;

    }



    /** Function to set default vesting schedule parameters. */

    function setDefaultVestingParameters(

        uint256 _startAt, uint256 _cliff, uint256 _duration,

        uint256 _step, bool _changeFreezed) public onlyAllocateAgent {



        // data validation

        require(_step != 0);

        require(_duration != 0);

        require(_cliff <= _duration);



        startAt = _startAt;

        cliff = _cliff;

        duration = _duration; 

        step = _step;

        changeFreezed = _changeFreezed;



    }



    /** Function to set vesting with default schedule. */

    function setVestingWithDefaultSchedule(address _adr, uint256 _amount) 

    public 

    changesToVestingNotFreezed(_adr) onlyAllocateAgent {

       

        setVesting(_adr, startAt, cliff, duration, step, _amount, changeFreezed);

    }    



    /** Function to set/update vesting schedule. PS - Amount cannot be changed once set */

    function setVesting(

        address _adr,

        uint256 _startAt,

        uint256 _cliff,

        uint256 _duration,

        uint256 _step,

        uint256 _amount,

        bool _changeFreezed) 

    public changesToVestingNotFreezed(_adr) onlyAllocateAgent {



        VestingSchedule storage vestingSchedule = vestingMap[_adr];



        // data validation

        require(_step != 0);

        require(_amount != 0 || vestingSchedule.amount > 0);

        require(_duration != 0);

        require(_cliff <= _duration);



        //if startAt is zero, set current time as start time.

        if (_startAt == 0) 

            _startAt = block.timestamp;



        vestingSchedule.startAt = _startAt;

        vestingSchedule.cliff = _cliff;

        vestingSchedule.duration = _duration;

        vestingSchedule.step = _step;



        // special processing for first time vesting setting

        if (vestingSchedule.amount == 0) {

            // check if enough tokens are held by this contract

            ERC20 token = ERC20(crowdSaleTokenAddress);

            require(token.balanceOf(this) >= totalUnreleasedTokens.plus(_amount));

            totalUnreleasedTokens = totalUnreleasedTokens.plus(_amount);

            vestingSchedule.amount = _amount; 

        }



        vestingSchedule.amountReleased = 0;

        vestingSchedule.changeFreezed = _changeFreezed;

    }



    function isVestingSet(address adr) public view returns (bool isSet) {

        return vestingMap[adr].amount != 0;

    }



    function freezeChangesToVesting(address _adr) public changesToVestingNotFreezed(_adr) onlyAllocateAgent {

        require(isVestingSet(_adr)); // first check if vesting is set

        vestingMap[_adr].changeFreezed = true;

    }



    /** Release tokens as per vesting schedule, called by contributor  */

    function releaseMyVestedTokens() public changesToVestingFreezed(msg.sender) {

        releaseVestedTokens(msg.sender);

    }



    /** Release tokens as per vesting schedule, called by anyone  */

    function releaseVestedTokens(address _adr) public changesToVestingFreezed(_adr) {

        VestingSchedule storage vestingSchedule = vestingMap[_adr];

        

        // check if all tokens are not vested

        require(vestingSchedule.amount.minus(vestingSchedule.amountReleased) > 0);

        

        // calculate total vested tokens till now

        uint256 totalTime = block.timestamp - vestingSchedule.startAt;

        uint256 totalSteps = totalTime / vestingSchedule.step;



        // check if cliff is passed

        require(vestingSchedule.cliff <= totalSteps);



        uint256 tokensPerStep = vestingSchedule.amount / vestingSchedule.duration;

        // check if amount is divisble by duration

        if (tokensPerStep * vestingSchedule.duration != vestingSchedule.amount) tokensPerStep++;



        uint256 totalReleasableAmount = tokensPerStep.times(totalSteps);



        // handle the case if user has not claimed even after vesting period is over or amount was not divisible

        if (totalReleasableAmount > vestingSchedule.amount) totalReleasableAmount = vestingSchedule.amount;



        uint256 amountToRelease = totalReleasableAmount.minus(vestingSchedule.amountReleased);

        vestingSchedule.amountReleased = vestingSchedule.amountReleased.plus(amountToRelease);



        // transfer vested tokens

        ERC20 token = ERC20(crowdSaleTokenAddress);

        token.transfer(_adr, amountToRelease);

        // decrement overall unreleased token count

        totalUnreleasedTokens = totalUnreleasedTokens.minus(amountToRelease);

        emit VestedTokensReleased(_adr, amountToRelease);

    }



    /**

    * Allow to (re)set Token.

    */

    function setCrowdsaleTokenExtv1(address _token) public onlyAllocateAgent {       

        crowdSaleTokenAddress = _token;

    }

}