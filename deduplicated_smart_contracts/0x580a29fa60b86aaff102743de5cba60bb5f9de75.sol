/**

 *Submitted for verification at Etherscan.io on 2019-01-29

*/



pragma solidity ^0.4.24;



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (_a == 0) {

      return 0;

    }



    c = _a * _b;

    assert(c / _a == _b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {

    // assert(_b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = _a / _b;

    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold

    return _a / _b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {

    assert(_b <= _a);

    return _a - _b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {

    c = _a + _b;

    assert(c >= _a);

    return c;

  }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

  address public owner;





  event OwnershipRenounced(address indexed previousOwner);

  event OwnershipTransferred(

    address indexed previousOwner,

    address indexed newOwner

  );





  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  constructor() public {

    owner = msg.sender;

  }



  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  /**

   * @dev Allows the current owner to relinquish control of the contract.

   * @notice Renouncing to ownership will leave the contract without an owner.

   * It will not be possible to call the functions with the `onlyOwner`

   * modifier anymore.

   */

  function renounceOwnership() public onlyOwner {

    emit OwnershipRenounced(owner);

    owner = address(0);

  }



  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function transferOwnership(address _newOwner) public onlyOwner {

    _transferOwnership(_newOwner);

  }



  /**

   * @dev Transfers control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function _transferOwnership(address _newOwner) internal {

    require(_newOwner != address(0));

    emit OwnershipTransferred(owner, _newOwner);

    owner = _newOwner;

  }

}



// File: openzeppelin-solidity/contracts/access/rbac/Roles.sol



/**

 * @title Roles

 * @author Francisco Giordano (@frangio)

 * @dev Library for managing addresses assigned to a Role.

 * See RBAC.sol for example usage.

 */

library Roles {

  struct Role {

    mapping (address => bool) bearer;

  }



  /**

   * @dev give an address access to this role

   */

  function add(Role storage _role, address _addr)

    internal

  {

    _role.bearer[_addr] = true;

  }



  /**

   * @dev remove an address' access to this role

   */

  function remove(Role storage _role, address _addr)

    internal

  {

    _role.bearer[_addr] = false;

  }



  /**

   * @dev check if an address has this role

   * // reverts

   */

  function check(Role storage _role, address _addr)

    internal

    view

  {

    require(has(_role, _addr));

  }



  /**

   * @dev check if an address has this role

   * @return bool

   */

  function has(Role storage _role, address _addr)

    internal

    view

    returns (bool)

  {

    return _role.bearer[_addr];

  }

}



// File: openzeppelin-solidity/contracts/access/rbac/RBAC.sol



/**

 * @title RBAC (Role-Based Access Control)

 * @author Matt Condon (@Shrugs)

 * @dev Stores and provides setters and getters for roles and addresses.

 * Supports unlimited numbers of roles and addresses.

 * See //contracts/mocks/RBACMock.sol for an example of usage.

 * This RBAC method uses strings to key roles. It may be beneficial

 * for you to write your own implementation of this interface using Enums or similar.

 */

contract RBAC {

  using Roles for Roles.Role;



  mapping (string => Roles.Role) private roles;



  event RoleAdded(address indexed operator, string role);

  event RoleRemoved(address indexed operator, string role);



  /**

   * @dev reverts if addr does not have role

   * @param _operator address

   * @param _role the name of the role

   * // reverts

   */

  function checkRole(address _operator, string _role)

    public

    view

  {

    roles[_role].check(_operator);

  }



  /**

   * @dev determine if addr has role

   * @param _operator address

   * @param _role the name of the role

   * @return bool

   */

  function hasRole(address _operator, string _role)

    public

    view

    returns (bool)

  {

    return roles[_role].has(_operator);

  }



  /**

   * @dev add a role to an address

   * @param _operator address

   * @param _role the name of the role

   */

  function addRole(address _operator, string _role)

    internal

  {

    roles[_role].add(_operator);

    emit RoleAdded(_operator, _role);

  }



  /**

   * @dev remove a role from an address

   * @param _operator address

   * @param _role the name of the role

   */

  function removeRole(address _operator, string _role)

    internal

  {

    roles[_role].remove(_operator);

    emit RoleRemoved(_operator, _role);

  }



  /**

   * @dev modifier to scope access to a single role (uses msg.sender as addr)

   * @param _role the name of the role

   * // reverts

   */

  modifier onlyRole(string _role)

  {

    checkRole(msg.sender, _role);

    _;

  }



  /**

   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)

   * @param _roles the names of the roles to scope access to

   * // reverts

   *

   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this

   *  see: https://github.com/ethereum/solidity/issues/2467

   */

  // modifier onlyRoles(string[] _roles) {

  //     bool hasAnyRole = false;

  //     for (uint8 i = 0; i < _roles.length; i++) {

  //         if (hasRole(msg.sender, _roles[i])) {

  //             hasAnyRole = true;

  //             break;

  //         }

  //     }



  //     require(hasAnyRole);



  //     _;

  // }

}



// File: openzeppelin-solidity/contracts/access/Whitelist.sol



/**

 * @title Whitelist

 * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.

 * This simplifies the implementation of "user permissions".

 */

contract Whitelist is Ownable, RBAC {

  string public constant ROLE_WHITELISTED = "whitelist";



  /**

   * @dev Throws if operator is not whitelisted.

   * @param _operator address

   */

  modifier onlyIfWhitelisted(address _operator) {

    checkRole(_operator, ROLE_WHITELISTED);

    _;

  }



  /**

   * @dev add an address to the whitelist

   * @param _operator address

   * @return true if the address was added to the whitelist, false if the address was already in the whitelist

   */

  function addAddressToWhitelist(address _operator)

    public

    onlyOwner

  {

    addRole(_operator, ROLE_WHITELISTED);

  }



  /**

   * @dev getter to determine if address is in whitelist

   */

  function whitelist(address _operator)

    public

    view

    returns (bool)

  {

    return hasRole(_operator, ROLE_WHITELISTED);

  }



  /**

   * @dev add addresses to the whitelist

   * @param _operators addresses

   * @return true if at least one address was added to the whitelist,

   * false if all addresses were already in the whitelist

   */

  function addAddressesToWhitelist(address[] _operators)

    public

    onlyOwner

  {

    for (uint256 i = 0; i < _operators.length; i++) {

      addAddressToWhitelist(_operators[i]);

    }

  }



  /**

   * @dev remove an address from the whitelist

   * @param _operator address

   * @return true if the address was removed from the whitelist,

   * false if the address wasn't in the whitelist in the first place

   */

  function removeAddressFromWhitelist(address _operator)

    public

    onlyOwner

  {

    removeRole(_operator, ROLE_WHITELISTED);

  }



  /**

   * @dev remove addresses from the whitelist

   * @param _operators addresses

   * @return true if at least one address was removed from the whitelist,

   * false if all addresses weren't in the whitelist in the first place

   */

  function removeAddressesFromWhitelist(address[] _operators)

    public

    onlyOwner

  {

    for (uint256 i = 0; i < _operators.length; i++) {

      removeAddressFromWhitelist(_operators[i]);

    }

  }



}



// File: openzeppelin-solidity/contracts/introspection/ERC165.sol



/**

 * @title ERC165

 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md

 */

interface ERC165 {



  /**

   * @notice Query if a contract implements an interface

   * @param _interfaceId The interface identifier, as specified in ERC-165

   * @dev Interface identification is specified in ERC-165. This function

   * uses less than 30,000 gas.

   */

  function supportsInterface(bytes4 _interfaceId)

    external

    view

    returns (bool);

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol



/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721Basic is ERC165 {



  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;

  /*

   * 0x80ac58cd ===

   *   bytes4(keccak256('balanceOf(address)')) ^

   *   bytes4(keccak256('ownerOf(uint256)')) ^

   *   bytes4(keccak256('approve(address,uint256)')) ^

   *   bytes4(keccak256('getApproved(uint256)')) ^

   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^

   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^

   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^

   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^

   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))

   */



  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;

  /*

   * 0x4f558e79 ===

   *   bytes4(keccak256('exists(uint256)'))

   */



  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;

  /**

   * 0x780e9d63 ===

   *   bytes4(keccak256('totalSupply()')) ^

   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^

   *   bytes4(keccak256('tokenByIndex(uint256)'))

   */



  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;

  /**

   * 0x5b5e139f ===

   *   bytes4(keccak256('name()')) ^

   *   bytes4(keccak256('symbol()')) ^

   *   bytes4(keccak256('tokenURI(uint256)'))

   */



  event Transfer(

    address indexed _from,

    address indexed _to,

    uint256 indexed _tokenId

  );

  event Approval(

    address indexed _owner,

    address indexed _approved,

    uint256 indexed _tokenId

  );

  event ApprovalForAll(

    address indexed _owner,

    address indexed _operator,

    bool _approved

  );



  function balanceOf(address _owner) public view returns (uint256 _balance);

  function ownerOf(uint256 _tokenId) public view returns (address _owner);

  function exists(uint256 _tokenId) public view returns (bool _exists);



  function approve(address _to, uint256 _tokenId) public;

  function getApproved(uint256 _tokenId)

    public view returns (address _operator);



  function setApprovalForAll(address _operator, bool _approved) public;

  function isApprovedForAll(address _owner, address _operator)

    public view returns (bool);



  function transferFrom(address _from, address _to, uint256 _tokenId) public;

  function safeTransferFrom(address _from, address _to, uint256 _tokenId)

    public;



  function safeTransferFrom(

    address _from,

    address _to,

    uint256 _tokenId,

    bytes _data

  )

    public;

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol



/**

 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension

 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721Enumerable is ERC721Basic {

  function totalSupply() public view returns (uint256);

  function tokenOfOwnerByIndex(

    address _owner,

    uint256 _index

  )

    public

    view

    returns (uint256 _tokenId);



  function tokenByIndex(uint256 _index) public view returns (uint256);

}





/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721Metadata is ERC721Basic {

  function name() external view returns (string _name);

  function symbol() external view returns (string _symbol);

  function tokenURI(uint256 _tokenId) public view returns (string);

}





/**

 * @title ERC-721 Non-Fungible Token Standard, full implementation interface

 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Receiver.sol



/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract ERC721Receiver {

  /**

   * @dev Magic value to be returned upon successful reception of an NFT

   *  Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`,

   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`

   */

  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;



  /**

   * @notice Handle the receipt of an NFT

   * @dev The ERC721 smart contract calls this function on the recipient

   * after a `safetransfer`. This function MAY throw to revert and reject the

   * transfer. Return of other than the magic value MUST result in the

   * transaction being reverted.

   * Note: the contract address is always the message sender.

   * @param _operator The address which called `safeTransferFrom` function

   * @param _from The address which previously owned the token

   * @param _tokenId The NFT identifier which is being transferred

   * @param _data Additional data with no specified format

   * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

   */

  function onERC721Received(

    address _operator,

    address _from,

    uint256 _tokenId,

    bytes _data

  )

    public

    returns(bytes4);

}



// File: openzeppelin-solidity/contracts/AddressUtils.sol



/**

 * Utility library of inline functions on addresses

 */

library AddressUtils {



  /**

   * Returns whether the target address is a contract

   * @dev This function will return false if invoked during the constructor of a contract,

   * as the code is not actually created until after the constructor finishes.

   * @param _addr address to check

   * @return whether the target address is a contract

   */

  function isContract(address _addr) internal view returns (bool) {

    uint256 size;

    // XXX Currently there is no better way to check if there is a contract in an address

    // than to check the size of the code at that address.

    // See https://ethereum.stackexchange.com/a/14016/36603

    // for more details about how this works.

    // TODO Check this again before the Serenity release, because all addresses will be

    // contracts then.

    // solium-disable-next-line security/no-inline-assembly

    assembly { size := extcodesize(_addr) }

    return size > 0;

  }



}



// File: openzeppelin-solidity/contracts/introspection/SupportsInterfaceWithLookup.sol



/**

 * @title SupportsInterfaceWithLookup

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract SupportsInterfaceWithLookup is ERC165 {



  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;

  /**

   * 0x01ffc9a7 ===

   *   bytes4(keccak256('supportsInterface(bytes4)'))

   */



  /**

   * @dev a mapping of interface id to whether or not it's supported

   */

  mapping(bytes4 => bool) internal supportedInterfaces;



  /**

   * @dev A contract implementing SupportsInterfaceWithLookup

   * implement ERC165 itself

   */

  constructor()

    public

  {

    _registerInterface(InterfaceId_ERC165);

  }



  /**

   * @dev implement supportsInterface(bytes4) using a lookup table

   */

  function supportsInterface(bytes4 _interfaceId)

    external

    view

    returns (bool)

  {

    return supportedInterfaces[_interfaceId];

  }



  /**

   * @dev private method for registering an interface

   */

  function _registerInterface(bytes4 _interfaceId)

    internal

  {

    require(_interfaceId != 0xffffffff);

    supportedInterfaces[_interfaceId] = true;

  }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721BasicToken.sol



/**

 * @title ERC721 Non-Fungible Token Standard basic implementation

 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {



  using SafeMath for uint256;

  using AddressUtils for address;



  // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`

  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;



  // Mapping from token ID to owner

  mapping (uint256 => address) internal tokenOwner;



  // Mapping from token ID to approved address

  mapping (uint256 => address) internal tokenApprovals;



  // Mapping from owner to number of owned token

  mapping (address => uint256) internal ownedTokensCount;



  // Mapping from owner to operator approvals

  mapping (address => mapping (address => bool)) internal operatorApprovals;



  constructor()

    public

  {

    // register the supported interfaces to conform to ERC721 via ERC165

    _registerInterface(InterfaceId_ERC721);

    _registerInterface(InterfaceId_ERC721Exists);

  }



  /**

   * @dev Gets the balance of the specified address

   * @param _owner address to query the balance of

   * @return uint256 representing the amount owned by the passed address

   */

  function balanceOf(address _owner) public view returns (uint256) {

    require(_owner != address(0));

    return ownedTokensCount[_owner];

  }



  /**

   * @dev Gets the owner of the specified token ID

   * @param _tokenId uint256 ID of the token to query the owner of

   * @return owner address currently marked as the owner of the given token ID

   */

  function ownerOf(uint256 _tokenId) public view returns (address) {

    address owner = tokenOwner[_tokenId];

    require(owner != address(0));

    return owner;

  }



  /**

   * @dev Returns whether the specified token exists

   * @param _tokenId uint256 ID of the token to query the existence of

   * @return whether the token exists

   */

  function exists(uint256 _tokenId) public view returns (bool) {

    address owner = tokenOwner[_tokenId];

    return owner != address(0);

  }



  /**

   * @dev Approves another address to transfer the given token ID

   * The zero address indicates there is no approved address.

   * There can only be one approved address per token at a given time.

   * Can only be called by the token owner or an approved operator.

   * @param _to address to be approved for the given token ID

   * @param _tokenId uint256 ID of the token to be approved

   */

  function approve(address _to, uint256 _tokenId) public {

    address owner = ownerOf(_tokenId);

    require(_to != owner);

    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));



    tokenApprovals[_tokenId] = _to;

    emit Approval(owner, _to, _tokenId);

  }



  /**

   * @dev Gets the approved address for a token ID, or zero if no address set

   * @param _tokenId uint256 ID of the token to query the approval of

   * @return address currently approved for the given token ID

   */

  function getApproved(uint256 _tokenId) public view returns (address) {

    return tokenApprovals[_tokenId];

  }



  /**

   * @dev Sets or unsets the approval of a given operator

   * An operator is allowed to transfer all tokens of the sender on their behalf

   * @param _to operator address to set the approval

   * @param _approved representing the status of the approval to be set

   */

  function setApprovalForAll(address _to, bool _approved) public {

    require(_to != msg.sender);

    operatorApprovals[msg.sender][_to] = _approved;

    emit ApprovalForAll(msg.sender, _to, _approved);

  }



  /**

   * @dev Tells whether an operator is approved by a given owner

   * @param _owner owner address which you want to query the approval of

   * @param _operator operator address which you want to query the approval of

   * @return bool whether the given operator is approved by the given owner

   */

  function isApprovedForAll(

    address _owner,

    address _operator

  )

    public

    view

    returns (bool)

  {

    return operatorApprovals[_owner][_operator];

  }



  /**

   * @dev Transfers the ownership of a given token ID to another address

   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible

   * Requires the msg sender to be the owner, approved, or operator

   * @param _from current owner of the token

   * @param _to address to receive the ownership of the given token ID

   * @param _tokenId uint256 ID of the token to be transferred

  */

  function transferFrom(

    address _from,

    address _to,

    uint256 _tokenId

  )

    public

  {

    require(isApprovedOrOwner(msg.sender, _tokenId));

    require(_from != address(0));

    require(_to != address(0));



    clearApproval(_from, _tokenId);

    removeTokenFrom(_from, _tokenId);

    addTokenTo(_to, _tokenId);



    emit Transfer(_from, _to, _tokenId);

  }



  /**

   * @dev Safely transfers the ownership of a given token ID to another address

   * If the target address is a contract, it must implement `onERC721Received`,

   * which is called upon a safe transfer, and return the magic value

   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

   * the transfer is reverted.

   *

   * Requires the msg sender to be the owner, approved, or operator

   * @param _from current owner of the token

   * @param _to address to receive the ownership of the given token ID

   * @param _tokenId uint256 ID of the token to be transferred

  */

  function safeTransferFrom(

    address _from,

    address _to,

    uint256 _tokenId

  )

    public

  {

    // solium-disable-next-line arg-overflow

    safeTransferFrom(_from, _to, _tokenId, "");

  }



  /**

   * @dev Safely transfers the ownership of a given token ID to another address

   * If the target address is a contract, it must implement `onERC721Received`,

   * which is called upon a safe transfer, and return the magic value

   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

   * the transfer is reverted.

   * Requires the msg sender to be the owner, approved, or operator

   * @param _from current owner of the token

   * @param _to address to receive the ownership of the given token ID

   * @param _tokenId uint256 ID of the token to be transferred

   * @param _data bytes data to send along with a safe transfer check

   */

  function safeTransferFrom(

    address _from,

    address _to,

    uint256 _tokenId,

    bytes _data

  )

    public

  {

    transferFrom(_from, _to, _tokenId);

    // solium-disable-next-line arg-overflow

    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));

  }



  /**

   * @dev Returns whether the given spender can transfer a given token ID

   * @param _spender address of the spender to query

   * @param _tokenId uint256 ID of the token to be transferred

   * @return bool whether the msg.sender is approved for the given token ID,

   *  is an operator of the owner, or is the owner of the token

   */

  function isApprovedOrOwner(

    address _spender,

    uint256 _tokenId

  )

    internal

    view

    returns (bool)

  {

    address owner = ownerOf(_tokenId);

    // Disable solium check because of

    // https://github.com/duaraghav8/Solium/issues/175

    // solium-disable-next-line operator-whitespace

    return (

      _spender == owner ||

      getApproved(_tokenId) == _spender ||

      isApprovedForAll(owner, _spender)

    );

  }



  /**

   * @dev Internal function to mint a new token

   * Reverts if the given token ID already exists

   * @param _to The address that will own the minted token

   * @param _tokenId uint256 ID of the token to be minted by the msg.sender

   */

  function _mint(address _to, uint256 _tokenId) internal {

    require(_to != address(0));

    addTokenTo(_to, _tokenId);

    emit Transfer(address(0), _to, _tokenId);

  }



  /**

   * @dev Internal function to burn a specific token

   * Reverts if the token does not exist

   * @param _tokenId uint256 ID of the token being burned by the msg.sender

   */

  function _burn(address _owner, uint256 _tokenId) internal {

    clearApproval(_owner, _tokenId);

    removeTokenFrom(_owner, _tokenId);

    emit Transfer(_owner, address(0), _tokenId);

  }



  /**

   * @dev Internal function to clear current approval of a given token ID

   * Reverts if the given address is not indeed the owner of the token

   * @param _owner owner of the token

   * @param _tokenId uint256 ID of the token to be transferred

   */

  function clearApproval(address _owner, uint256 _tokenId) internal {

    require(ownerOf(_tokenId) == _owner);

    if (tokenApprovals[_tokenId] != address(0)) {

      tokenApprovals[_tokenId] = address(0);

    }

  }



  /**

   * @dev Internal function to add a token ID to the list of a given address

   * @param _to address representing the new owner of the given token ID

   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address

   */

  function addTokenTo(address _to, uint256 _tokenId) internal {

    require(tokenOwner[_tokenId] == address(0));

    tokenOwner[_tokenId] = _to;

    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);

  }



  /**

   * @dev Internal function to remove a token ID from the list of a given address

   * @param _from address representing the previous owner of the given token ID

   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address

   */

  function removeTokenFrom(address _from, uint256 _tokenId) internal {

    require(ownerOf(_tokenId) == _from);

    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);

    tokenOwner[_tokenId] = address(0);

  }



  /**

   * @dev Internal function to invoke `onERC721Received` on a target address

   * The call is not executed if the target address is not a contract

   * @param _from address representing the previous owner of the given token ID

   * @param _to target address that will receive the tokens

   * @param _tokenId uint256 ID of the token to be transferred

   * @param _data bytes optional data to send along with the call

   * @return whether the call correctly returned the expected magic value

   */

  function checkAndCallSafeTransfer(

    address _from,

    address _to,

    uint256 _tokenId,

    bytes _data

  )

    internal

    returns (bool)

  {

    if (!_to.isContract()) {

      return true;

    }

    bytes4 retval = ERC721Receiver(_to).onERC721Received(

      msg.sender, _from, _tokenId, _data);

    return (retval == ERC721_RECEIVED);

  }

}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Token.sol



/**

 * @title Full ERC721 Token

 * This implementation includes all the required and some optional functionality of the ERC721 standard

 * Moreover, it includes approve all functionality using operator terminology

 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {



  // Token name

  string internal name_;



  // Token symbol

  string internal symbol_;



  // Mapping from owner to list of owned token IDs

  mapping(address => uint256[]) internal ownedTokens;



  // Mapping from token ID to index of the owner tokens list

  mapping(uint256 => uint256) internal ownedTokensIndex;



  // Array with all token ids, used for enumeration

  uint256[] internal allTokens;



  // Mapping from token id to position in the allTokens array

  mapping(uint256 => uint256) internal allTokensIndex;



  // Optional mapping for token URIs

  mapping(uint256 => string) internal tokenURIs;



  /**

   * @dev Constructor function

   */

  constructor(string _name, string _symbol) public {

    name_ = _name;

    symbol_ = _symbol;



    // register the supported interfaces to conform to ERC721 via ERC165

    _registerInterface(InterfaceId_ERC721Enumerable);

    _registerInterface(InterfaceId_ERC721Metadata);

  }



  /**

   * @dev Gets the token name

   * @return string representing the token name

   */

  function name() external view returns (string) {

    return name_;

  }



  /**

   * @dev Gets the token symbol

   * @return string representing the token symbol

   */

  function symbol() external view returns (string) {

    return symbol_;

  }



  /**

   * @dev Returns an URI for a given token ID

   * Throws if the token ID does not exist. May return an empty string.

   * @param _tokenId uint256 ID of the token to query

   */

  function tokenURI(uint256 _tokenId) public view returns (string) {

    require(exists(_tokenId));

    return tokenURIs[_tokenId];

  }



  /**

   * @dev Gets the token ID at a given index of the tokens list of the requested owner

   * @param _owner address owning the tokens list to be accessed

   * @param _index uint256 representing the index to be accessed of the requested tokens list

   * @return uint256 token ID at the given index of the tokens list owned by the requested address

   */

  function tokenOfOwnerByIndex(

    address _owner,

    uint256 _index

  )

    public

    view

    returns (uint256)

  {

    require(_index < balanceOf(_owner));

    return ownedTokens[_owner][_index];

  }



  /**

   * @dev Gets the total amount of tokens stored by the contract

   * @return uint256 representing the total amount of tokens

   */

  function totalSupply() public view returns (uint256) {

    return allTokens.length;

  }



  /**

   * @dev Gets the token ID at a given index of all the tokens in this contract

   * Reverts if the index is greater or equal to the total number of tokens

   * @param _index uint256 representing the index to be accessed of the tokens list

   * @return uint256 token ID at the given index of the tokens list

   */

  function tokenByIndex(uint256 _index) public view returns (uint256) {

    require(_index < totalSupply());

    return allTokens[_index];

  }



  /**

   * @dev Internal function to set the token URI for a given token

   * Reverts if the token ID does not exist

   * @param _tokenId uint256 ID of the token to set its URI

   * @param _uri string URI to assign

   */

  function _setTokenURI(uint256 _tokenId, string _uri) internal {

    require(exists(_tokenId));

    tokenURIs[_tokenId] = _uri;

  }



  /**

   * @dev Internal function to add a token ID to the list of a given address

   * @param _to address representing the new owner of the given token ID

   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address

   */

  function addTokenTo(address _to, uint256 _tokenId) internal {

    super.addTokenTo(_to, _tokenId);

    uint256 length = ownedTokens[_to].length;

    ownedTokens[_to].push(_tokenId);

    ownedTokensIndex[_tokenId] = length;

  }



  /**

   * @dev Internal function to remove a token ID from the list of a given address

   * @param _from address representing the previous owner of the given token ID

   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address

   */

  function removeTokenFrom(address _from, uint256 _tokenId) internal {

    super.removeTokenFrom(_from, _tokenId);



    // To prevent a gap in the array, we store the last token in the index of the token to delete, and

    // then delete the last slot.

    uint256 tokenIndex = ownedTokensIndex[_tokenId];

    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);

    uint256 lastToken = ownedTokens[_from][lastTokenIndex];



    ownedTokens[_from][tokenIndex] = lastToken;

    // This also deletes the contents at the last position of the array

    ownedTokens[_from].length--;



    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to

    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping

    // the lastToken to the first position, and then dropping the element placed in the last position of the list



    ownedTokensIndex[_tokenId] = 0;

    ownedTokensIndex[lastToken] = tokenIndex;

  }



  /**

   * @dev Internal function to mint a new token

   * Reverts if the given token ID already exists

   * @param _to address the beneficiary that will own the minted token

   * @param _tokenId uint256 ID of the token to be minted by the msg.sender

   */

  function _mint(address _to, uint256 _tokenId) internal {

    super._mint(_to, _tokenId);



    allTokensIndex[_tokenId] = allTokens.length;

    allTokens.push(_tokenId);

  }



  /**

   * @dev Internal function to burn a specific token

   * Reverts if the token does not exist

   * @param _owner owner of the token to burn

   * @param _tokenId uint256 ID of the token being burned by the msg.sender

   */

  function _burn(address _owner, uint256 _tokenId) internal {

    super._burn(_owner, _tokenId);



    // Clear metadata (if any)

    if (bytes(tokenURIs[_tokenId]).length != 0) {

      delete tokenURIs[_tokenId];

    }



    // Reorg all tokens array

    uint256 tokenIndex = allTokensIndex[_tokenId];

    uint256 lastTokenIndex = allTokens.length.sub(1);

    uint256 lastToken = allTokens[lastTokenIndex];



    allTokens[tokenIndex] = lastToken;

    allTokens[lastTokenIndex] = 0;



    allTokens.length--;

    allTokensIndex[_tokenId] = 0;

    allTokensIndex[lastToken] = tokenIndex;

  }



}



// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Holder.sol



contract ERC721Holder is ERC721Receiver {

  function onERC721Received(

    address,

    address,

    uint256,

    bytes

  )

    public

    returns(bytes4)

  {

    return ERC721_RECEIVED;

  }

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol



/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * See https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address _who) public view returns (uint256);

  function transfer(address _to, uint256 _value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}



// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol



/**

 * @title Basic token

 * @dev Basic version of StandardToken, with no allowances.

 */

contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) internal balances;



  uint256 internal totalSupply_;



  /**

  * @dev Total number of tokens in existence

  */

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  /**

  * @dev Transfer token for a specified address

  * @param _to The address to transfer to.

  * @param _value The amount to be transferred.

  */

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_value <= balances[msg.sender]);

    require(_to != address(0));



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  /**

  * @dev Gets the balance of the specified address.

  * @param _owner The address to query the the balance of.

  * @return An uint256 representing the amount owned by the passed address.

  */

  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }



}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

  function allowance(address _owner, address _spender)

    public view returns (uint256);



  function transferFrom(address _from, address _to, uint256 _value)

    public returns (bool);



  function approve(address _spender, uint256 _value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}



// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol



/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * https://github.com/ethereum/EIPs/issues/20

 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 */

contract StandardToken is ERC20, BasicToken {



  mapping (address => mapping (address => uint256)) internal allowed;





  /**

   * @dev Transfer tokens from one address to another

   * @param _from address The address which you want to send tokens from

   * @param _to address The address which you want to transfer to

   * @param _value uint256 the amount of tokens to be transferred

   */

  function transferFrom(

    address _from,

    address _to,

    uint256 _value

  )

    public

    returns (bool)

  {

    require(_value <= balances[_from]);

    require(_value <= allowed[_from][msg.sender]);

    require(_to != address(0));



    balances[_from] = balances[_from].sub(_value);

    balances[_to] = balances[_to].add(_value);

    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

    emit Transfer(_from, _to, _value);

    return true;

  }



  /**

   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

   * Beware that changing an allowance with this method brings the risk that someone may use both the old

   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

   * @param _spender The address which will spend the funds.

   * @param _value The amount of tokens to be spent.

   */

  function approve(address _spender, uint256 _value) public returns (bool) {

    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);

    return true;

  }



  /**

   * @dev Function to check the amount of tokens that an owner allowed to a spender.

   * @param _owner address The address which owns the funds.

   * @param _spender address The address which will spend the funds.

   * @return A uint256 specifying the amount of tokens still available for the spender.

   */

  function allowance(

    address _owner,

    address _spender

   )

    public

    view

    returns (uint256)

  {

    return allowed[_owner][_spender];

  }



  /**

   * @dev Increase the amount of tokens that an owner allowed to a spender.

   * approve should be called when allowed[_spender] == 0. To increment

   * allowed value is better to use this function to avoid 2 calls (and wait until

   * the first transaction is mined)

   * From MonolithDAO Token.sol

   * @param _spender The address which will spend the funds.

   * @param _addedValue The amount of tokens to increase the allowance by.

   */

  function increaseApproval(

    address _spender,

    uint256 _addedValue

  )

    public

    returns (bool)

  {

    allowed[msg.sender][_spender] = (

      allowed[msg.sender][_spender].add(_addedValue));

    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  }



  /**

   * @dev Decrease the amount of tokens that an owner allowed to a spender.

   * approve should be called when allowed[_spender] == 0. To decrement

   * allowed value is better to use this function to avoid 2 calls (and wait until

   * the first transaction is mined)

   * From MonolithDAO Token.sol

   * @param _spender The address which will spend the funds.

   * @param _subtractedValue The amount of tokens to decrease the allowance by.

   */

  function decreaseApproval(

    address _spender,

    uint256 _subtractedValue

  )

    public

    returns (bool)

  {

    uint256 oldValue = allowed[msg.sender][_spender];

    if (_subtractedValue >= oldValue) {

      allowed[msg.sender][_spender] = 0;

    } else {

      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

    }

    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  }



}



// File: contracts/Strings.sol



library Strings {

  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol

  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {

    bytes memory _ba = bytes(_a);

    bytes memory _bb = bytes(_b);

    bytes memory _bc = bytes(_c);

    bytes memory _bd = bytes(_d);

    bytes memory _be = bytes(_e);

    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);

    bytes memory babcde = bytes(abcde);

    uint k = 0;

    for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];

    for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];

    for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];

    for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];

    for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];

    return string(babcde);

  }



  function strConcat(string _a, string _b) internal pure returns (string) {

    return strConcat(_a, _b, "", "", "");

  }

}



// File: contracts/Medianizer.sol



// This is the original medianizer implementation used by MakerDAO. we use this

// contract to fetch the latest ether price by calling the read() function.

// public deployed instances of  this contract can be found here:

//1) kovan: https://kovan.etherscan.io/address/0x9FfFE440258B79c5d6604001674A4722FfC0f7Bc#code

//2) mainnet: https://etherscan.io/address/0x729D19f657BD0614b4985Cf1D82531c67569197B#readContract



/// return median value of feeds



// Copyright (C) 2017  DappHub, LLC



// Licensed under the Apache License, Version 2.0 (the "License").

// You may not use this file except in compliance with the License.



// Unless required by applicable law or agreed to in writing, software

// distributed under the License is distributed on an "AS IS" BASIS,

// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).



pragma solidity ^0.4.8;



contract DSAuthority {

    function canCall(

        address src, address dst, bytes4 sig

    ) constant returns (bool);

}



contract DSAuthEvents {

    event LogSetAuthority (address indexed authority);

    event LogSetOwner     (address indexed owner);

}



contract DSAuth is DSAuthEvents {

    DSAuthority  public  authority;

    address      public  owner;



    function DSAuth() {

        owner = msg.sender;

        LogSetOwner(msg.sender);

    }



    function setOwner(address owner_)

        auth

    {

        owner = owner_;

        LogSetOwner(owner);

    }



    function setAuthority(DSAuthority authority_)

        auth

    {

        authority = authority_;

        LogSetAuthority(authority);

    }



    modifier auth {

        assert(isAuthorized(msg.sender, msg.sig));

        _;

    }



    modifier authorized(bytes4 sig) {

        assert(isAuthorized(msg.sender, sig));

        _;

    }



    function isAuthorized(address src, bytes4 sig) internal returns (bool) {

        if (src == address(this)) {

            return true;

        } else if (src == owner) {

            return true;

        } else if (authority == DSAuthority(0)) {

            return false;

        } else {

            return authority.canCall(src, this, sig);

        }

    }



    function assert(bool x) internal {

        if (!x) throw;

    }

}



contract DSNote {

    event LogNote(

        bytes4   indexed  sig,

        address  indexed  guy,

        bytes32  indexed  foo,

        bytes32  indexed  bar,

	uint	 	  wad,

        bytes             fax

    ) anonymous;



    modifier note {

        bytes32 foo;

        bytes32 bar;



        assembly {

            foo := calldataload(4)

            bar := calldataload(36)

        }



        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);



        _;

    }

}



contract DSMath {



    /*

    standard uint256 functions

     */



    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {

        assert((z = x + y) >= x);

    }



    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {

        assert((z = x - y) <= x);

    }



    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {

        assert((z = x * y) >= x);

    }



    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {

        z = x / y;

    }



    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {

        return x <= y ? x : y;

    }

    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {

        return x >= y ? x : y;

    }



    /*

    uint128 functions (h is for half)

     */





    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {

        assert((z = x + y) >= x);

    }



    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {

        assert((z = x - y) <= x);

    }



    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {

        assert((z = x * y) >= x);

    }



    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {

        z = x / y;

    }



    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {

        return x <= y ? x : y;

    }

    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {

        return x >= y ? x : y;

    }





    /*

    int256 functions

     */



    function imin(int256 x, int256 y) constant internal returns (int256 z) {

        return x <= y ? x : y;

    }

    function imax(int256 x, int256 y) constant internal returns (int256 z) {

        return x >= y ? x : y;

    }



    /*

    WAD math

     */



    uint128 constant WAD = 10 ** 18;



    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {

        return hadd(x, y);

    }



    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {

        return hsub(x, y);

    }



    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {

        z = cast((uint256(x) * y + WAD / 2) / WAD);

    }



    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {

        z = cast((uint256(x) * WAD + y / 2) / y);

    }



    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {

        return hmin(x, y);

    }

    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {

        return hmax(x, y);

    }



    /*

    RAY math

     */



    uint128 constant RAY = 10 ** 27;



    function radd(uint128 x, uint128 y) constant internal returns (uint128) {

        return hadd(x, y);

    }



    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {

        return hsub(x, y);

    }



    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {

        z = cast((uint256(x) * y + RAY / 2) / RAY);

    }



    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {

        z = cast((uint256(x) * RAY + y / 2) / y);

    }



    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {

        // This famous algorithm is called "exponentiation by squaring"

        // and calculates x^n with x as fixed-point and n as regular unsigned.

        //

        // It's O(log n), instead of O(n) for naive repeated multiplication.

        //

        // These facts are why it works:

        //

        //  If n is even, then x^n = (x^2)^(n/2).

        //  If n is odd,  then x^n = x * x^(n-1),

        //   and applying the equation for even x gives

        //    x^n = x * (x^2)^((n-1) / 2).

        //

        //  Also, EVM division is flooring and

        //    floor[(n-1) / 2] = floor[n / 2].



        z = n % 2 != 0 ? x : RAY;



        for (n /= 2; n != 0; n /= 2) {

            x = rmul(x, x);



            if (n % 2 != 0) {

                z = rmul(z, x);

            }

        }

    }



    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {

        return hmin(x, y);

    }

    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {

        return hmax(x, y);

    }



    function cast(uint256 x) constant internal returns (uint128 z) {

        assert((z = uint128(x)) == x);

    }



}



contract DSThing is DSAuth, DSNote, DSMath {

}



contract DSValue is DSThing {

    bool    has;

    bytes32 val;

    function peek() constant returns (bytes32, bool) {

        return (val,has);

    }

    function read() constant returns (bytes32) {

        var (wut, has) = peek();

        assert(has);

        return wut;

    }

    function poke(bytes32 wut) note auth {

        val = wut;

        has = true;

    }

    function void() note auth { // unset the value

        has = false;

    }

}



contract Medianizer is DSValue {

    mapping (bytes12 => address) public values;

    mapping (address => bytes12) public indexes;

    bytes12 public next = 0x1;



    uint96 public min = 0x1;



    function set(address wat) auth {

        bytes12 nextId = bytes12(uint96(next) + 1);

        assert(nextId != 0x0);

        set(next, wat);

        next = nextId;

    }



    function set(bytes12 pos, address wat) note auth {

        if (pos == 0x0) throw;



        if (wat != 0 && indexes[wat] != 0) throw;



        indexes[values[pos]] = 0; // Making sure to remove a possible existing address in that position



        if (wat != 0) {

            indexes[wat] = pos;

        }



        values[pos] = wat;

    }



    function setMin(uint96 min_) note auth {

        if (min_ == 0x0) throw;

        min = min_;

    }



    function setNext(bytes12 next_) note auth {

        if (next_ == 0x0) throw;

        next = next_;

    }



    function unset(bytes12 pos) {

        set(pos, 0);

    }



    function unset(address wat) {

        set(indexes[wat], 0);

    }



    function poke() {

        poke(0);

    }



    function poke(bytes32) note {

        (val, has) = compute();

    }



    function compute() constant returns (bytes32, bool) {

        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);

        uint96 ctr = 0;

        for (uint96 i = 1; i < uint96(next); i++) {

            if (values[bytes12(i)] != 0) {

                var (wut, wuz) = DSValue(values[bytes12(i)]).peek();

                if (wuz) {

                    if (ctr == 0 || wut >= wuts[ctr - 1]) {

                        wuts[ctr] = wut;

                    } else {

                        uint96 j = 0;

                        while (wut >= wuts[j]) {

                            j++;

                        }

                        for (uint96 k = ctr; k > j; k--) {

                            wuts[k] = wuts[k - 1];

                        }

                        wuts[j] = wut;

                    }

                    ctr++;

                }

            }

        }



        if (ctr < min) return (val, false);



        bytes32 value;

        if (ctr % 2 == 0) {

            uint128 val1 = uint128(wuts[(ctr / 2) - 1]);

            uint128 val2 = uint128(wuts[ctr / 2]);

            value = bytes32(wdiv(hadd(val1, val2), 2 ether));

        } else {

            value = wuts[(ctr - 1) / 2];

        }



        return (value, true);

    }



}



// File: contracts/RadiCards.sol



/**

* @title Radi.Cards

* This is the main Radi Cards NFT (ERC721) contract. It allows for the minting of

* cards(NFTs) that can be sent to either a known EOA or to a claimable link.

* ETH or DAI can be sent along with the card and the sender can choose a ratio

* between a participating benefactor and the recipient, with no restriction.

* Predefined cards can be added, with the artwork stored on IPFS.

* The card message is stored within the smart contract. Cards can have a defined max

* quantity that can be minted and a minimum purchase price. The claimable link sender

* generates a public/private key pair that is used to take the NFT out of escrow (held within

* this contract). The private key can then be sent to the recipient by email,

* telergram, wechat ect. and is embedded within a URL to a claim page. When the user

* opens the claim URL the private key is used to redeem the NFT and any associated gift (ETH/DAI).



* @author blockrocket.tech (smart contracts)

* @author cryptodecks.co

* @author knownorigin.io

* @author pheme.app

* @author d1labs.com

* @author mbdoesthings.com

* @author chrismaree.io (smart contracts v2 update)

*/

contract RadiCards is ERC721Token, ERC721Holder, Whitelist {

    using SafeMath for uint256;



    // dai support

    StandardToken daiContract;

    Medianizer medianizerContract;



    string public tokenBaseURI = "https://ipfs.infura.io/ipfs/";

    uint256 public tokenIdPointer = 0;



    struct Benefactor {

        address ethAddress;

        string name;

        string website;

        string logo;

    }



    struct CardDesign {

        string tokenURI;

        bool active;

        uint minted;

        uint maxQnty; //set to zero for unlimited

        //minimum price per card set in Atto (SI prefix for 1x10-18 dai)

        uint256 minPrice; //set to zero to default to the minimumContribution

    }



    // claimable link support

    enum Statuses { Empty, Deposited, Claimed, Cancelled }

    uint256 public EPHEMERAL_ADDRESS_FEE = 0.01 ether;

    mapping(address => uint256) public ephemeralWalletCards; // ephemeral wallet => tokenId



    struct RadiCard {

        address gifter;

        string message;

        bool daiDonation;

        uint256 giftAmount;

        uint256 donationAmount;

        Statuses status;

        uint256 cardIndex;

        uint256 benefactorIndex;

    }



    mapping(uint256 => Benefactor) public benefactors;

    uint256[] internal benefactorsIndex;



    mapping(uint256 => CardDesign) public cards;

    uint256[] internal cardsIndex;



    mapping(uint256 => RadiCard) public tokenIdToRadiCardIndex;



    //total gifted/donated in ETH

    uint256 public totalGiftedInWei;

    uint256 public totalDonatedInWei;



    //total gifted/donated in DAI

    uint256 public totalGiftedInAtto; //SI prefix for 1x10-18 dai is Atto.

    uint256 public totalDonatedInAtto;



    event CardGifted(

        address indexed _to,

        uint256 indexed _benefactorIndex,

        uint256 indexed _cardIndex,

        address _from,

        uint256 _tokenId,

        bool daiDonation,

        uint256 giftAmount,

        uint256 donationAmount,

        Statuses status

    );



    event LogClaimGift(

            address indexed ephemeralAddress,

            address indexed sender,

            uint tokenId,

            address receiver,

            uint giftAmount,

        bool daiDonation

    );



    event LogCancelGift(

        address indexed ephemeralAddress,

        address indexed sender,

        uint tokenId

    );





    event BenefactorAdded(

        uint256 indexed _benefactorIndex

    );



    event CardAdded(

        uint256 indexed _cardIndex

    );



    constructor () public ERC721Token("RadiCards", "RADI") {

        addAddressToWhitelist(msg.sender);

    }



    function gift(address _to, uint256 _benefactorIndex, uint256 _cardIndex, string _message, uint256 _donationAmount, uint256 _giftAmount, bool _claimableLink) payable public returns (bool) {

        require(_to != address(0), "Must be a valid address");

        if(_donationAmount > 0){

            require(benefactors[_benefactorIndex].ethAddress != address(0), "Must specify existing benefactor");

        }



        require(bytes(cards[_cardIndex].tokenURI).length != 0, "Must specify existing card");

        require(cards[_cardIndex].active, "Must be an active card");



        Statuses _giftStatus;

        address _sentToAddress;



        if(_claimableLink){

            require(_donationAmount + _giftAmount + EPHEMERAL_ADDRESS_FEE == msg.value, "Can only request to donate and gift the amount of ether sent + Ephemeral fee");

            _giftStatus = Statuses.Deposited;

            _sentToAddress = this;

            ephemeralWalletCards[_to] = tokenIdPointer;

            _to.transfer(EPHEMERAL_ADDRESS_FEE);

        }



        else {

            require(_donationAmount + _giftAmount == msg.value,"Can only request to donate and gift the amount of ether sent");

            _giftStatus = Statuses.Claimed;

            _sentToAddress = _to;

        }



        if (cards[_cardIndex].maxQnty > 0){ //the max quantity is set to zero to indicate no limit. Only need to check that can mint if limited

            require(cards[_cardIndex].minted < cards[_cardIndex].maxQnty, "Can't exceed maximum quantity of card type");

        }



        if(cards[_cardIndex].minPrice > 0){ //if the card has a minimum price check that enough has been sent

        // Convert the current value of the eth send to a USD value of atto (1 usd = 10^18 atto).

        // require(getEthUsdValue(msg.value) >= (cards[_cardIndex].minPrice), "Must send at least the minimum amount");

            require (getMinCardPriceInWei(_cardIndex) <= msg.value,"Must send at least the minimum amount to buy card");

        }



        tokenIdToRadiCardIndex[tokenIdPointer] = RadiCard({

            gifter: msg.sender,

            message: _message,

            daiDonation: false,

            giftAmount: _giftAmount,

            donationAmount: _donationAmount,

            status: _giftStatus,

            cardIndex: _cardIndex,

            benefactorIndex: _benefactorIndex

        });



        // Card is minted to the _sentToAddress. This is either this radicards contract(if claimableLink==true)

        // and the creator chose to use the escrow for a claimable link or to the recipient EOA directly

        uint256 _tokenId = _mint(_sentToAddress, cards[_cardIndex].tokenURI);

        cards[_cardIndex].minted++;



        // transfer the ETH to the benefactor

        if(_donationAmount > 0){

            benefactors[_benefactorIndex].ethAddress.transfer(_donationAmount);

            totalDonatedInWei = totalDonatedInWei.add(_donationAmount);

        }

        // transfer gift to recipient.



        if(_giftAmount > 0){

            totalGiftedInWei = totalGiftedInWei.add(_giftAmount);

        // note that we only do the transfer if the link is not claimable as if it is the eth sits in escrow within this contract

            if(!_claimableLink){

                _sentToAddress.transfer(_giftAmount);

            }

        }

        emit CardGifted(_sentToAddress, _benefactorIndex, _cardIndex, msg.sender, _tokenId, false, _giftAmount, _donationAmount, _giftStatus);

        return true;

    }



    function giftInDai(address _to, uint256 _benefactorIndex, uint256 _cardIndex, string _message, uint256 _donationAmount, uint256 _giftAmount, bool _claimableLink) public payable returns (bool) {

        require(_to != address(0), "Must be a valid address");

        if (_donationAmount > 0){

            require(benefactors[_benefactorIndex].ethAddress != address(0), "Must specify existing benefactor");

        }



        require(bytes(cards[_cardIndex].tokenURI).length != 0, "Must specify existing card");

        require(cards[_cardIndex].active, "Must be an active card");



        require((_donationAmount + _giftAmount) <= daiContract.allowance(msg.sender, this), "Must have provided high enough alowance to Radicard contract");

        require((_donationAmount + _giftAmount) <= daiContract.balanceOf(msg.sender), "Must have enough token balance of dai to pay for donation and gift amount");



        if (cards[_cardIndex].maxQnty > 0){ //the max quantity is set to zero to indicate no limit. Only need to check that can mint if limited

            require(cards[_cardIndex].minted < cards[_cardIndex].maxQnty, "Can't exceed maximum quantity of card type");

        }



        if(cards[_cardIndex].minPrice > 0){ //if the card has a minimum price check that enough has been sent

            require((_donationAmount + _giftAmount) >= cards[_cardIndex].minPrice, "The total dai sent with the transaction is less than the min price of the token");

        }



        //parameters that change based on the if the card is setup as with a claimable link

        Statuses _giftStatus;

        address _sentToAddress;



        if(_claimableLink){

            require(msg.value == EPHEMERAL_ADDRESS_FEE, "A claimable link was generated but not enough ephemeral ether was sent!");

            _giftStatus = Statuses.Deposited;

            _sentToAddress = this;

            // need to store the address of the ephemeral account and the card that it owns for claimable link functionality

            ephemeralWalletCards[_to] = tokenIdPointer;

            _to.transfer(EPHEMERAL_ADDRESS_FEE);

        }



        else {

            _giftStatus = Statuses.Claimed;

            _sentToAddress = _to;

        }



        tokenIdToRadiCardIndex[tokenIdPointer] = RadiCard({

            gifter: msg.sender,

            message: _message,

            daiDonation: true,

            giftAmount: _giftAmount,

            donationAmount: _donationAmount,

            status: _giftStatus,

            cardIndex: _cardIndex,

            benefactorIndex: _benefactorIndex

        });



        // Card is minted to the _sentToAddress. This is either this radicards contract(if claimableLink==true)

        // and the creator chose to use the escrow for a claimable link or to the recipient EOA directly

        uint256 _tokenId = _mint(_sentToAddress, cards[_cardIndex].tokenURI);



        cards[_cardIndex].minted++;



        // transfer the DAI to the benefactor

        if(_donationAmount > 0){

            address _benefactorAddress = benefactors[_benefactorIndex].ethAddress;

            require(daiContract.transferFrom(msg.sender, _benefactorAddress, _donationAmount),"Sending to benefactor failed");

            totalDonatedInAtto = totalDonatedInAtto.add(_donationAmount);

        }



        // transfer gift to recipient. note that this pattern is slightly different from the eth case as irrespective of

        // if it is a claimable link or not we preform the transaction. if it is indeed a claimable link the dai is sent

        // to the contract and held in escrow

        if(_giftAmount > 0){

            require(daiContract.transferFrom(msg.sender, _sentToAddress, _giftAmount),"Sending to recipient failed");

            totalGiftedInAtto = totalGiftedInAtto.add(_giftAmount);

        }



        emit CardGifted(_sentToAddress, _benefactorIndex, _cardIndex, msg.sender, _tokenId, true, _giftAmount, _donationAmount, _giftStatus);

        return true;

    }



    function _mint(address to, string tokenURI) internal returns (uint256 _tokenId) {

        uint256 tokenId = tokenIdPointer;



        super._mint(to, tokenId);

        _setTokenURI(tokenId, tokenURI);



        tokenIdPointer = tokenIdPointer.add(1);



        return tokenId;

    }



    function cancelGift(address _ephemeralAddress) public returns (bool) {

        uint256 tokenId = ephemeralWalletCards[_ephemeralAddress];

        require(tokenId != 0, "Can only call this function on an address that was used as an ephemeral");

        RadiCard storage card = tokenIdToRadiCardIndex[tokenId];



        // is deposited and wasn't claimed or cancelled before

        require(card.status == Statuses.Deposited, "can only cancel gifts that are unclaimed (deposited)");



        // only gifter can cancel transfer;

        require(msg.sender == card.gifter, "only the gifter of the card can cancel a gift");



        // update status to cancelled

        card.status = Statuses.Cancelled;



        // transfer optional ether or dai back to creators address

        if (card.giftAmount > 0) {

            if(card.daiDonation){

                require(daiContract.transfer(msg.sender, card.giftAmount),"Sending to recipient after cancel gift failed");

            }

            else{

                msg.sender.transfer(card.giftAmount);

            }

        }



        // send nft to buyer. for this we use a custom transfer function to take the nft out of escrow and

        // send it back to the buyer.

        transferFromEscrow(msg.sender, tokenId);



        // log cancel event

        emit LogCancelGift(_ephemeralAddress, msg.sender, tokenId);

        return true;

    }



    function claimGift(address _receiver) public returns (bool success) {

        // only holder of ephemeral private key can claim gift

        address _ephemeralAddress = msg.sender;



        uint256 tokenId = ephemeralWalletCards[_ephemeralAddress];



        require(tokenId != 0, "The calling address does not have an ephemeral card associated with it");



        RadiCard storage card = tokenIdToRadiCardIndex[tokenId];



        // is deposited and wasn't claimed or cancelled before

        require(card.status == Statuses.Deposited, "Can only claim a gift that is unclaimed");



        // update gift status to claimed

        card.status = Statuses.Claimed;



        // send nft to receiver

        transferFromEscrow(_receiver, tokenId);



        // transfer optional ether & dai to receiver's address

        if (card.giftAmount > 0) {

            if(card.daiDonation){

                require(daiContract.transfer(_receiver, card.giftAmount),"Sending to recipient after cancel gift failed");

        }

            else{

                _receiver.transfer(card.giftAmount);

            }

        }



        // log claim event

        emit LogClaimGift(

            _ephemeralAddress,

            card.gifter,

            tokenId,

            _receiver,

            card.giftAmount,

            card.daiDonation

        );

        return true;

    }



    function burn(uint256 _tokenId) public pure  {

        revert("Radi.Cards are censorship resistant!");

    }



    function tokenURI(uint256 _tokenId) public view returns (string) {

        require(exists(_tokenId), "token does not exist");



        return Strings.strConcat(tokenBaseURI, tokenURIs[_tokenId]);

    }



    function tokenDetails(uint256 _tokenId)

    public view

    returns (

        address _gifter,

        string _message,

        bool _daiDonation,

        uint256 _giftAmount,

        uint256 _donationAmount,

        Statuses status,

        uint256 _cardIndex,

        uint256 _benefactorIndex

    ) {

        require(exists(_tokenId), "token does not exist");

        RadiCard memory _radiCard = tokenIdToRadiCardIndex[_tokenId];

        return (

        _radiCard.gifter,

        _radiCard.message,

        _radiCard.daiDonation,

        _radiCard.giftAmount,

        _radiCard.donationAmount,

        _radiCard.status,

        _radiCard.cardIndex,

        _radiCard.benefactorIndex

        );

    }



    function tokenBenefactor(uint256 _tokenId)

    public view

    returns (

        address _ethAddress,

        string _name,

        string _website,

        string _logo

    ) {

        require(exists(_tokenId),"Card must exist");

        RadiCard memory _radiCard = tokenIdToRadiCardIndex[_tokenId];

        Benefactor memory _benefactor = benefactors[_radiCard.benefactorIndex];

        return (

        _benefactor.ethAddress,

        _benefactor.name,

        _benefactor.website,

        _benefactor.logo

        );

    }



    function tokensOf(address _owner) public view returns (uint256[] _tokenIds) {

        return ownedTokens[_owner];

    }



    function benefactorsKeys() public view returns (uint256[] _keys) {

        return benefactorsIndex;

    }



    function cardsKeys() public view returns (uint256[] _keys) {

        return cardsIndex;

    }



    function addBenefactor(uint256 _benefactorIndex, address _ethAddress, string _name, string _website, string _logo)

    public onlyIfWhitelisted(msg.sender)

    returns (bool) {

        require(address(_ethAddress) != address(0), "Invalid address");

        require(bytes(_name).length != 0, "Invalid name");

        require(bytes(_website).length != 0, "Invalid name");

        require(bytes(_logo).length != 0, "Invalid name");



        benefactors[_benefactorIndex] = Benefactor(

            _ethAddress,

            _name,

            _website,

            _logo

        );

        benefactorsIndex.push(_benefactorIndex);



        emit BenefactorAdded(_benefactorIndex);

        return true;

    }



    function addCard(uint256 _cardIndex, string _tokenURI, bool _active, uint256 _maxQnty, uint256 _minPrice)

    public onlyIfWhitelisted(msg.sender)

    returns (bool) {

        require(bytes(_tokenURI).length != 0, "Invalid token URI");



        cards[_cardIndex] = CardDesign(

            _tokenURI,

            _active,

            0,

            _maxQnty,

            _minPrice

        );

        cardsIndex.push(_cardIndex);



        emit CardAdded(_cardIndex);

        return true;

    }



    function setTokenBaseURI(string _newBaseURI) external onlyIfWhitelisted(msg.sender) {

        require(bytes(_newBaseURI).length != 0, "Base URI invalid");



        tokenBaseURI = _newBaseURI;

    }



    function setActive(uint256 _cardIndex, bool _active) external onlyIfWhitelisted(msg.sender) {

        require(bytes(cards[_cardIndex].tokenURI).length != 0, "Must specify existing card");

        cards[_cardIndex].active = _active;

    }



    function setMaxQuantity(uint256 _cardIndex, uint256 _maxQnty) external onlyIfWhitelisted(msg.sender) {

        require(bytes(cards[_cardIndex].tokenURI).length != 0, "Must specify existing card");

        require(cards[_cardIndex].minted <= _maxQnty, "Can't set the max quantity less than the current total minted");

        cards[_cardIndex].maxQnty = _maxQnty;

    }



    function setMinPrice(uint256 _cardIndex, uint256 _minPrice) external onlyIfWhitelisted(msg.sender) {

        require(bytes(cards[_cardIndex].tokenURI).length != 0, "Must specify existing card");

        cards[_cardIndex].minPrice = _minPrice;

    }



    function setDaiContractAddress(address _daiERC20ContractAddress) external onlyIfWhitelisted(msg.sender){

        require(_daiERC20ContractAddress != address(0), "Must be a valid address");

        daiContract = StandardToken(_daiERC20ContractAddress);

    }



    // sets the medianizer contract for the makerdao implementation used as a price oracle

    function setMedianizerContractAddress(address _MedianizerContractAddress) external onlyIfWhitelisted(msg.sender){

        require(_MedianizerContractAddress != address(0), "Must be a valid address");

        medianizerContract = Medianizer(_MedianizerContractAddress);

    }



    // returns the current ether price in usd. 18 decimal point precision used

    function getEtherPrice() public view returns(uint256){

        return uint256(medianizerContract.read());

    }



    // returns the value of ether in atto  (1 usd of ether = 10^18 atto)

    function getEthUsdValue(uint256 _ether) public view returns(uint256){

        return ((_ether*getEtherPrice())/(1 ether));

    }



    // returns the minimum required in wei for a particular card given the card min price in dai

    function getMinCardPriceInWei(uint256 _cardIndex) public view returns(uint256){

        return ((cards[_cardIndex].minPrice * 1 ether)/getEtherPrice());

    }

    // transfer tokens held by this contract in escrow to the recipient. Used when either claiming or cancelling gifts

    function transferFromEscrow(address _recipient,uint256 _tokenId) internal{

        require(super.ownerOf(_tokenId) == address(this),"The card must be owned by the contract for it to be in escrow");

        super.clearApproval(this, _tokenId);

        super.removeTokenFrom(this, _tokenId);

        super.addTokenTo(_recipient, _tokenId);

        emit Transfer(this, _recipient, _tokenId);

    }

}