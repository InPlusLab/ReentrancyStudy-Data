/**
 *Submitted for verification at Etherscan.io on 2021-05-26
*/

// SPDX-License-Identifier: MIT

pragma solidity 0.7.6;          

pragma experimental ABIEncoderV2;

contract DSMath {
    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x + y) >= x, "");
    }

    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x - y) <= x, "");
    }

    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(y == 0 || (z = x * y) / y == x, "");
    }

    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {
        return x / y;
    }

    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
        return x <= y ? x : y;
    }

    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {
        return x >= y ? x : y;
    }

    function imin(int256 x, int256 y) internal pure returns (int256 z) {
        return x <= y ? x : y;
    }

    function imax(int256 x, int256 y) internal pure returns (int256 z) {
        return x >= y ? x : y;
    }

    uint256 constant WAD = 10**18;
    uint256 constant RAY = 10**27;

    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = add(mul(x, y), WAD / 2) / WAD;
    }

    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = add(mul(x, y), RAY / 2) / RAY;
    }

    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = add(mul(x, WAD), y / 2) / y;
    }

    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = add(mul(x, RAY), y / 2) / y;
    }

    // This famous algorithm is called "exponentiation by squaring"
    // and calculates x^n with x as fixed-point and n as regular unsigned.
    //
    // It's O(log n), instead of O(n) for naive repeated multiplication.
    //
    // These facts are why it works:
    //
    //  If n is even, then x^n = (x^2)^(n/2).
    //  If n is odd,  then x^n = x * x^(n-1),
    //   and applying the equation for even x gives
    //    x^n = x * (x^2)^((n-1) / 2).
    //
    //  Also, EVM division is flooring and
    //    floor[(n-1) / 2] = floor[n / 2].
    //
    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {
        z = n % 2 != 0 ? x : RAY;

        for (n /= 2; n != 0; n /= 2) {
            x = rmul(x, x);

            if (n % 2 != 0) {
                z = rmul(z, x);
            }
        }
    }
}          



abstract contract IGetSafes {
    function getSafesAsc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);
    function getSafesDesc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);

}          



abstract contract ISAFEEngine {

    struct SAFE {
        uint256 lockedCollateral;
        uint256 generatedDebt;
    }

    struct CollateralType {
        // Total debt issued for this specific collateral type
        uint256 debtAmount;        // [wad]
        // Accumulator for interest accrued on this collateral type
        uint256 accumulatedRate;   // [ray]
        // Floor price at which a SAFE is allowed to generate debt
        uint256 safetyPrice;       // [ray]
        // Maximum amount of debt that can be generated with this collateral type
        uint256 debtCeiling;       // [rad]
        // Minimum amount of debt that must be generated by a SAFE using this collateral
        uint256 debtFloor;         // [rad]
        // Price at which a SAFE gets liquidated
        uint256 liquidationPrice;  // [ray]
    }

    mapping (bytes32 => mapping (address => SAFE )) public safes;
    mapping (bytes32 => CollateralType) public collateralTypes;
    mapping (bytes32 => mapping (address => uint)) public tokenCollateral;

    function safeRights(address, address) virtual public view returns (uint);
    function coinBalance(address) virtual public view returns (uint);
    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;
    function approveSAFEModification(address) virtual public;
    function transferInternalCoins(address, address, uint) virtual public;
    function transferSAFECollateralAndDebt(bytes32, address, address, int, int) virtual public;
}          



abstract contract ISAFEManager {

    function lastSAFEID(address) virtual public view returns (uint);
    function safeCan(address, uint, address) virtual public view returns (uint);
    function collateralTypes(uint) virtual public view returns (bytes32);
    function ownsSAFE(uint) virtual public view returns (address);
    function safes(uint) virtual public view returns (address);
    function safeEngine() virtual public view returns (address);
    function openSAFE(bytes32, address) virtual public returns (uint);
    function transferSAFEOwnership(uint, address) virtual public;
    function allowSAFE(uint, address, uint) virtual public;
    function handlerAllowed(address, uint) virtual public;
    function modifySAFECollateralization(uint, int, int) virtual public;
    function transferCollateral(uint, address, uint) virtual public;
    function transferInternalCoins(uint, address, uint) virtual public;
    function quitSystem(uint, address) virtual public;
    function enterSystem(address, uint) virtual public;
    function moveSAFE(uint, uint) virtual public;
    function safeCount(address) virtual public view returns (uint);
    function safei() virtual public view returns (uint);
}          



abstract contract IOracleRelayer {
    struct CollateralType {
        address orcl;
        uint256 safetyCRatio;
    }

    mapping (bytes32 => CollateralType) public collateralTypes;

    function redemptionPrice() public virtual returns (uint256);
    uint256 public redemptionRate;
}          



abstract contract IMedianOracle {
    function read() external virtual view returns (uint256);
}          



abstract contract ITaxCollector {
    struct CollateralType {
        uint256 stabilityFee;
        uint256 updateTime;
    }

    mapping (bytes32 => CollateralType) public collateralTypes;

    function taxSingle(bytes32) public virtual returns (uint);
}          










contract RaiLoanInfo is DSMath {
    // mainnet
    address public constant GET_SAFES_ADDR = 0xdf4BC9aA98cC8eCd90Ba2BEe73aD4a1a9C8d202B;
    address public constant MANAGER_ADDR = 0xEfe0B4cA532769a3AE758fD82E1426a03A94F185;
    address public constant SAFE_ENGINE_ADDRESS = 0xCC88a9d330da1133Df3A7bD823B95e52511A6962;
    address public constant ORACLE_RELAYER_ADDRESS = 0x4ed9C0dCa0479bC64d8f4EB3007126D5791f7851;
    address public constant MEDIAN_ORACLE_ADDRESS = 0xFbF4849a06F6e6F53EcB31D2f8BD61aA7874b268;
    address public constant TAX_COLLECTOR_ADDRESS = 0xcDB05aEda142a1B0D6044C09C64e4226c1a281EB;

    // kovan
    // address public constant GET_SAFES_ADDR = 0x702dcf4a8C3bBBd243477D5704fc45F2762D3826;
    // address public constant MANAGER_ADDR = 0x807C8eCb73d9c8203d2b1369E678098B9370F2EA;
    // address public constant SAFE_ENGINE_ADDRESS = 0x7f63fE955fFF8EA474d990f1Fc8979f2C650edbE;
    // address public constant ORACLE_RELAYER_ADDRESS = 0xE5Ae4E49bEA485B5E5172EE6b1F99243cB15225c;
    // address public constant MEDIAN_ORACLE_ADDRESS = 0x82bEAd00751EFA3286c9Dd17e4Ea2570916B3944;
    // address public constant TAX_COLLECTOR_ADDRESS = 0xc1a94C5ad9FCD79b03F79B34d8C0B0C8192fdc16;

    struct SafeInfo {
        uint256 safeId;
        uint256 coll;
        uint256 debt;
        address safeAddr;
        bytes32 collType;
    }

    struct CollInfo {
        uint256 debtCeiling;
        uint256 currDebtAmount;
        uint256 currRate;
        uint256 dust;
        uint256 safetyPrice;
        uint256 liqPrice;
        uint256 assetPrice;
        uint256 liqRatio;
        uint256 stabilityFee;
    }

    struct RaiInfo {
        uint256 redemptionPrice;
        uint256 currRaiPrice;
        uint256 redemptionRate;
    }

    function getCollateralTypeInfo(bytes32 _collType)
        public
        returns (CollInfo memory collInfo)
    {
        (
            uint256 debtAmount,
            uint256 accumulatedRates,
            uint256 safetyPrice,
            uint256 debtCeiling,
            uint256 debtFloor,
            uint256 liquidationPrice
        ) = ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);

        (, uint liqRatio) = IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);

        (uint stabilityFee,) = ITaxCollector(TAX_COLLECTOR_ADDRESS).collateralTypes(_collType);


        collInfo = CollInfo({
            debtCeiling: debtCeiling,
            currDebtAmount: debtAmount,
            currRate: accumulatedRates,
            dust: debtFloor,
            safetyPrice: safetyPrice,
            liqPrice: liquidationPrice,
            assetPrice: getPrice(_collType),
            liqRatio: liqRatio,
            stabilityFee: stabilityFee
        });
    }

    function getCollAndRaiInfo(bytes32 _collType)
        public
        returns (CollInfo memory collInfo, RaiInfo memory raiInfo) {
            collInfo = getCollateralTypeInfo(_collType);
            raiInfo = getRaiInfo();
        }

    function getPrice(bytes32 _collType) public returns (uint256) {
        (, uint256 safetyCRatio) =
            IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);
        (, , uint256 safetyPrice, , , ) =
            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);

        uint256 redemptionPrice = IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice();

        return rmul(rmul(safetyPrice, redemptionPrice), safetyCRatio);
    }

    function getRaiInfo() public returns (RaiInfo memory raiInfo) {
        uint medianPrice = 0;
        
        try IMedianOracle(MEDIAN_ORACLE_ADDRESS).read() returns (uint p) {
            medianPrice = p;
        } catch(bytes memory) {}
        
        raiInfo = RaiInfo({
            redemptionPrice: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice(),
            currRaiPrice: medianPrice,
            redemptionRate: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionRate()
        });
    }

    function getSafeInfo(uint256 _safeId) public view returns (SafeInfo memory safeInfo) {
        address safeAddr = ISAFEManager(MANAGER_ADDR).safes(_safeId);
        bytes32 collType = ISAFEManager(MANAGER_ADDR).collateralTypes(_safeId);

        (uint256 coll, uint256 debt) = ISAFEEngine(SAFE_ENGINE_ADDRESS).safes(collType, safeAddr);

        safeInfo = SafeInfo({
            safeId: _safeId,
            coll: coll,
            debt: debt,
            safeAddr: safeAddr,
            collType: collType
        });
    }

    function getUserSafes(address _user)
        public
        view
        returns (
            uint256[] memory ids,
            address[] memory safes,
            bytes32[] memory collateralTypes
        )
    {
        return IGetSafes(GET_SAFES_ADDR).getSafesAsc(MANAGER_ADDR, _user);
    }

    function getUserSafesFullInfo(address _user) public view returns (SafeInfo[] memory safeInfos) {
        (uint256[] memory ids, , ) = getUserSafes(_user);

        safeInfos = new SafeInfo[](ids.length);

        for (uint256 i = 0; i < ids.length; ++i) {
            safeInfos[i] = getSafeInfo(ids[i]);
        }
    }

    function getFullInfo(address _user, bytes32 _collType)
        public
        returns (
            CollInfo memory collInfo,
            RaiInfo memory raiInfo,
            SafeInfo[] memory safeInfos
        )
    {
        collInfo = getCollateralTypeInfo(_collType);
        raiInfo = getRaiInfo();
        safeInfos = getUserSafesFullInfo(_user);
    }
}