pragma solidity ^0.5.2;



import "./SafeMath.sol";

import "./IERC20.sol";

import "./Ownable.sol";

import "./MinterRole.sol";



contract EUCXToken is IERC20, Ownable, MinterRole {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowed;

    uint256 private _totalSupply;

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    constructor() Ownable() public {

        _name = "EUCX Token";

        _symbol = "EUCX";

        _decimals = 18;

        _totalSupply = 1000000000 * uint(10**18);

        _balances[msg.sender] = _totalSupply;

    }



    function name() public view returns (string memory) {

        return _name;

    }



    function symbol() public view returns (string memory) {

        return _symbol;

    }



    function decimals() public view returns (uint8) {

        return _decimals;

    }



    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _transfer(from, to, value);

        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));

        return true;

    }



    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));

        return true;

    }



    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    function mint(address to, uint256 value) public onlyMinter returns (bool) {

        _mint(to, value);

        return true;

    }



    function burn(uint256 value) public onlyMinter {

        _burn(msg.sender, value);

    }



    function burnFrom(address from, uint256 value) public onlyMinter {

        _burnFrom(from, value);

    }



    function _transfer(address from, address to, uint256 value) private {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    function _mint(address account, uint256 value) private {

        require(account != address(0));

        require(_totalSupply.add(value) <= 1000000000 * uint(10**18));



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }



    function _burn(address account, uint256 value) private {

        require(account != address(0));



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    function _burnFrom(address account, uint256 value) private {

        _burn(account, value);

        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));

    }



    function _approve(address owner, address spender, uint256 value) private {

        require(spender != address(0));

        require(owner != address(0));



        _allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }

}