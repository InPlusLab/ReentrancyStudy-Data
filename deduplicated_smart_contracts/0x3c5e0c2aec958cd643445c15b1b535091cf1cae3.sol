/**

 *Submitted for verification at Etherscan.io on 2018-12-26

*/



pragma solidity ^0.4.25;



/* Real Estate Token . §¨§Ö§ä§à§ß§í §ß§Ö§Õ§Ó§Ú§Ø§Ú§Þ§à§ã§ä§Ú

 ¨€ REAL ESTATE BLOCKCHAIN INNOVATIONS ¨€ §¢§­§°§¬§¹§¦§«§¯ §¯§¦§¥§£§ª§¨§ª§®§°§³§´§ª §ª§¯§¯§°§£§¡§¸§ª§ª ¨€

 

 Long-term and short-term investments ¨€ §¥§à§Ý§Ô§à§ã§â§à§é§ß§í§Ö §Ú §Ü§â§Ñ§ä§Ü§à§ã§â§à§é§ß§í§Ö §Ú§ß§Ó§Ö§ã§ä§Ú§è§Ú§Ú

 Benefits from 10% to 200%            ¨€ §±§â§Ö§Ú§Þ§å§ë§Ö§ã§ä§Ó§Ñ §à§ä 10% §Õ§à 200%

 Invest in the ETH blockchain         ¨€ §ª§ß§Ó§Ö§ã§ä§Ú§â§å§Û§ä§Ö §Ó §Ò§Ý§à§Ü§é§Ö§Û§ß ETH

 Can be withdrawn at any time         ¨€ §®§à§Ø§Ö§ä §Ò§í§ä§î §à§ä§à§Ù§Ó§Ñ§ß §Ó §Ý§ð§Ò§à§Ö §Ó§â§Ö§Þ§ñ

 

 How to invest? ¨€ §¬§Ñ§Ü §Ú§ß§Ó§Ö§ã§ä§Ú§â§à§Ó§Ñ§ä§î?

 

 Send minimum 0.01 ETH to Smart Contract ¨€ §°§ä§á§â§Ñ§Ó§î§ä§Ö §ß§Ö §Þ§Ö§ß§Ö§Ö 0,01 ETH §ß§Ñ Smart Contract

 

 You have invested 0.01 ETH and got a Real Estate Token (RET) of 20,000

 §£§í §Ó§Ý§à§Ø§Ú§Ý§Ú 0,01 ETH §Ú §á§à§Ý§å§é§Ú§Ý§Ú §Ø§Ö§ä§à§ß §ß§Ö§Õ§Ó§Ú§Ø§Ú§Þ§à§ã§ä§Ú (RET) §Ó §â§Ñ§Ù§Þ§Ö§â§Ö 20 000

 

How to withdraw?

Send 0 ETH to Contract after you get 20,000 RET



§¬§Ñ§Ü §ã§ß§ñ§ä§î?

§°§ä§á§â§Ñ§Ó§î§ä§Ö 0 ETH §ß§Ñ §Ü§à§ß§ä§â§Ñ§Ü§ä §á§à§ã§Ý§Ö §á§à§Ý§å§é§Ö§ß§Ú§ñ 20 000 RET



Where is the office located? ¨€ §¤§Õ§Ö §ß§Ñ§ç§à§Õ§Ú§ä§ã§ñ §à§æ§Ú§ã?



REAL is an initiative of Real Estate Token Pte. Ltd. UEN 201720446Z	

REAL §ñ§Ó§Ý§ñ§Ö§ä§ã§ñ §Ú§ß§Ú§è§Ú§Ñ§ä§Ú§Ó§à§Û Real Estate Token Pte. Ltd. UEN 201720446Z

 







contract Multiplier {

    //Address for promo expences

    address constant private PROMO = 0x0000000000000000000000000000000000000000;

    //Percent for promo expences

    uint constant public PROMO_PERCENT = 7; //6 for advertizing, 1 for techsupport

    //How many percent for your deposit to be multiplied

    uint constant public MULTIPLIER = 121;



    //The deposit structure holds all the info about the deposit made

    struct Deposit {

        address depositor; //The depositor address

        uint128 deposit;   //The deposit amount

        uint128 expect;    //How much we should pay out (initially it is 121% of deposit)

    }



    Deposit[] private queue;  //The queue

    uint public currentReceiverIndex = 0; //The index of the first depositor in the queue. The receiver of investments!



    //This function receives all the deposits

    //stores them and make immediate payouts

    function () public payable {

        if(msg.value > 0){

            require(gasleft() >= 220000, "We require more gas!"); //We need gas to process queue

            require(msg.value <= 10 ether); //Do not allow too big investments to stabilize payouts



            //Add the investor into the queue. Mark that he expects to receive 121% of deposit back

            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100)));



            //Send some promo to enable this contract to leave long-long time

            uint promo = msg.value*PROMO_PERCENT/100;

            PROMO.send(promo);



            //Pay to first investors in line

            pay();

        }

    }



    //Used to pay to current investors

    //Each new transaction processes 1 - 4+ investors in the head of queue 

    //depending on balance and gas left

    function pay() private {

        //Try to send all the money on contract to the first investors in line

        uint128 money = uint128(address(this).balance);



        //We will do cycle on the queue

        for(uint i=0; i<queue.length; i++){



            uint idx = currentReceiverIndex + i;  //get the index of the currently first investor



            Deposit storage dep = queue[idx]; //get the info of the first investor



            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor

                dep.depositor.send(dep.expect); //Send money to him

                money -= dep.expect;            //update money left



                //this investor is fully paid, so remove him

                delete queue[idx];

            }else{

                //Here we don't have enough money so partially pay to investor

                dep.depositor.send(money); //Send to him everything we have

                dep.expect -= money;       //Update the expected amount

                break;                     //Exit cycle

            }



            if(gasleft() <= 50000)         //Check the gas left. If it is low, exit the cycle

                break;                     //The next investor will process the line further

        }



        currentReceiverIndex += i; //Update the index of the current first investor

    }



    //Get the deposit info by its index

    //You can get deposit index from

    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){

        Deposit storage dep = queue[idx];

        return (dep.depositor, dep.deposit, dep.expect);

    }



    //Get the count of deposits of specific investor

    function getDepositsCount(address depositor) public view returns (uint) {

        uint c = 0;

        for(uint i=currentReceiverIndex; i<queue.length; ++i){

            if(queue[i].depositor == depositor)

                c++;

        }

        return c;

    }



    //Get all deposits (index, deposit, expect) of a specific investor

    function getDeposits(address depositor) public view returns (uint[] idxs, uint128[] deposits, uint128[] expects) {

        uint c = getDepositsCount(depositor);



        idxs = new uint[](c);

        deposits = new uint128[](c);

        expects = new uint128[](c);



        if(c > 0) {

            uint j = 0;

            for(uint i=currentReceiverIndex; i<queue.length; ++i){

                Deposit storage dep = queue[i];

                if(dep.depositor == depositor){

                    idxs[j] = i;

                    deposits[j] = dep.deposit;

                    expects[j] = dep.expect;

                    j++;

                }

            }

        }

    }

    

    //Get current queue size

    function getQueueLength() public view returns (uint) {

        return queue.length - currentReceiverIndex;

    }



}



*/



contract Token {



    

    function totalSupply() constant returns (uint256 supply) {}



    

    function balanceOf(address _owner) constant returns (uint256 balance) {}



    function transfer(address _to, uint256 _value) returns (bool success) {}



    

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}



    

    function approve(address _spender, uint256 _value) returns (bool success) {}



    

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}



    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);



}



contract StandardToken is Token {



    function transfer(address _to, uint256 _value) returns (bool success) {

        //Default assumes totalSupply can't be over max (2^256 - 1).

        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.

        //Replace the if with this one instead.

        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {

        if (balances[msg.sender] >= _value && _value > 0) {

            balances[msg.sender] -= _value;

            balances[_to] += _value;

            Transfer(msg.sender, _to, _value);

            return true;

        } else { return false; }

    }



    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        //same as above. Replace this line with the following if you want to protect against wrapping uints.

        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {

            balances[_to] += _value;

            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            Transfer(_from, _to, _value);

            return true;

        } else { return false; }

    }



    function balanceOf(address _owner) constant returns (uint256 balance) {

        return balances[_owner];

    }



    function approve(address _spender, uint256 _value) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;

    }



    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {

      return allowed[_owner][_spender];

    }



    mapping (address => uint256) balances;

    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalSupply;

}



contract RealEstateToken is StandardToken { 

    string public name;                   

    uint8 public decimals;                

    string public symbol;                 

    string public version = 'H1.0'; 

    uint256 public unitsOneEthCanBuy;     

    uint256 public totalEthInWei;           

    address public fundsWallet;          



    

    function RealEstateToken() {

        balances[msg.sender] = 201009982000000000000000000;               

        name = "Real Estate Token";                                   

        decimals = 18;                                              

        symbol = "RET";                                             

        unitsOneEthCanBuy = 2000000;                                      

        fundsWallet = msg.sender;                                 

    }



    function() payable{

        totalEthInWei = totalEthInWei + msg.value;

        uint256 amount = msg.value * unitsOneEthCanBuy;

        if (balances[fundsWallet] < amount) {

            return;

        }



        balances[fundsWallet] = balances[fundsWallet] - amount;

        balances[msg.sender] = balances[msg.sender] + amount;



        Transfer(fundsWallet, msg.sender, amount); 



        

        fundsWallet.transfer(msg.value);                               

    }



    

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);



        

        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { throw; }

        return true;

    }

}