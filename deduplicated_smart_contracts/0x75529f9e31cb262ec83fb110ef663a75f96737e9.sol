// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

/// @author The Cache Gold Team
/// @title This contract is polled by the keepers in the Chainlink keepers network and if upKeep is required calls LockedCacheGoldAPIConsumer.sol
interface KeeperCompatibleInterface {
    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);
    function performUpkeep(bytes calldata performData) external;
}


contract CacheGoldLockedDataCronKeeper is KeeperCompatibleInterface {
    address private immutable _cacheGoldLockedOracle;
    uint256 private _lockedGold;
    address private immutable _cacheGoldLockedDataAPIConsumer;

    /**
     * @param cacheGoldLockedOracleParam This is the address of the cache gold oracle which is updated by the gramchain.net service
     * @param cacheGoldLockedDataAPIConsumerParam This is the address of the Chain Link Cache Locked Data API fetch contract
     */
    constructor(address cacheGoldLockedOracleParam, address cacheGoldLockedDataAPIConsumerParam) {
      require(cacheGoldLockedOracleParam != address(0)); //Check that it is not the zeroth address
      require(cacheGoldLockedDataAPIConsumerParam != address(0)); //Check that it is not the zeroth address
      _cacheGoldLockedOracle = cacheGoldLockedOracleParam;
      _cacheGoldLockedDataAPIConsumer = cacheGoldLockedDataAPIConsumerParam;
    }

    /**
     *  @notice Check Upkeep called by keepers to check if upkeep is required
     *  @dev If there is a change in the stored lockedAmount vs the actual in the Cache Gramchain Locked Gold Contract then perform upkeep
     */ 
    function checkUpkeep(bytes calldata checkData) external view override returns  (bool upkeepNeeded, bytes memory performData)   {
        
        (bool success, bytes memory callData) = address(_cacheGoldLockedOracle).staticcall(abi.encodeWithSignature("lockedGold()"));
        require(success, "Unable to fetch locked gold oracle data");
        (uint256 lockedGoldInCacheOracle) = abi.decode(callData, (uint256));
        if(lockedGoldInCacheOracle != _lockedGold){
            return(true, abi.encodeWithSignature("requestedLockedData(string)", "grams_locked")); 
        }
        else{
            return (false, checkData);
        }
    }

    /**
     * @notice Perform the upkeep required
     * @param performData The upkeep that needs to be performed address(_cacheGoldLockedOracle).call(abi.encodeWithSignature("lockedGold()"));
     */ 
    function performUpkeep(bytes calldata performData) external override {
        (bool success, bytes memory callData) = address(_cacheGoldLockedOracle).staticcall(abi.encodeWithSignature("lockedGold()"));
        require(success, "Unable to fetch locked gold oracle data");
        (uint256 lockedGoldInCacheOracle) = abi.decode(callData, (uint256));
        _lockedGold = lockedGoldInCacheOracle;

        // performData is generated by the Keeper's call to your `checkUpkeep` function
        (bool successPerformData,) = address(_cacheGoldLockedDataAPIConsumer).call(performData);
        require(successPerformData, "Unable to perform upkeep");
    }

    /**
     * @notice Retrieve the Cache Gold Locked Oracle Address
     */ 
    function cacheGoldContractAddress() external view returns(address) {
        return _cacheGoldLockedOracle;
    }

    /**
     * @notice  Retrieve the cache Cache Gold Locked Data APIConsumer Address
     */ 
    function cacheGoldLockedDataAPIConsumer() external view returns(address) {
        return _cacheGoldLockedDataAPIConsumer;
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {

  function decimals()
    external
    view
    returns (
      uint8
    );

  function description()
    external
    view
    returns (
      string memory
    );

  function version()
    external
    view
    returns (
      uint256
    );

  // getRoundData and latestRoundData should both raise "No data present"
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(
    uint80 _roundId
  )
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

}

{
  "optimizer": {
    "enabled": true,
    "runs": 1000
  },
  "outputSelection": {
    "*": {
      "*": [
        "evm.bytecode",
        "evm.deployedBytecode",
        "abi"
      ]
    }
  },
  "libraries": {}
}