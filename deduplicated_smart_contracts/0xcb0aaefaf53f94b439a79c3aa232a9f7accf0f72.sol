/**
 *Submitted for verification at Etherscan.io on 2021-08-01
*/

/* @author zefram.eth */ pragma solidity 0.8.6; interface IR { function onERC721Received(address op, address fr, uint256 id, bytes calldata dt) external returns (bytes4); } contract Quine { event Transfer(address indexed fr, address indexed to, uint256 indexed id); event Approval(address indexed ow, address indexed ad, uint256 indexed id); event ApprovalForAll(address indexed ow, address indexed op, bool ad); string public constant name = "Quine NFT"; string public constant symbol = "QUINE"; mapping(uint256 => address) private _os; mapping(address => uint256) private _bs; mapping(uint256 => address) private _ta; mapping(address => mapping(address => bool)) private _oa; constructor() { _sm(msg.sender, 1); } function supportsInterface(bytes4 ii) public pure returns (bool) { return ii == 0x80ac58cd || ii == 0x5b5e139f || ii == 0x01ffc9a7; } function balanceOf(address ow) public view returns (uint256) { require(ow != address(0)); return _bs[ow]; } function ownerOf(uint256 id) public view returns (address) { address ow = _os[id]; require(ow != address(0)); return ow; } function approve(address to, uint256 id) public { address ow = ownerOf(id); require(to != ow); require(msg.sender == ow || isApprovedForAll(ow, msg.sender)); _ap(to, id); } function getApproved(uint256 id) public view returns (address) { require(_ex(id)); return _ta[id]; } function setApprovalForAll(address op, bool ad) public { require(op != msg.sender); _oa[msg.sender][op] = ad; emit ApprovalForAll(msg.sender, op, ad); } function isApprovedForAll(address ow, address op) public view returns (bool) { return _oa[ow][op]; } function transferFrom(address fr,address to,uint256 id) public { require(_ao(msg.sender, id)); _tr(fr, to, id); } function safeTransferFrom(address fr,address to,uint256 id) public { safeTransferFrom(fr, to, id, ""); } function safeTransferFrom(address fr,address to,uint256 id,bytes memory _dt) public { require(_ao(msg.sender, id)); _st(fr, to, id, _dt); } function _st(address fr,address to,uint256 id,bytes memory _dt) internal { _tr(fr, to, id); require(_cr(fr, to, id, _dt)); } function _ex(uint256 id) internal view returns (bool) { return _os[id] != address(0); } function _ao(address sp, uint256 id) internal view returns (bool) { require(_ex(id)); address ow = ownerOf(id); return (sp == ow || getApproved(id) == sp || isApprovedForAll(ow, sp)); } function _sm(address to, uint256 id) internal { require(to != address(0)); require(!_ex(id)); _bs[to] += 1; _os[id] = to; emit Transfer(address(0), to, id); require(_cr(address(0), to, id, "")); } function _tr(address fr,address to,uint256 id) internal { require(ownerOf(id) == fr); require(to != address(0)); _ap(address(0), id); _bs[fr] -= 1; _bs[to] += 1; _os[id] = to; emit Transfer(fr, to, id); } function _ap(address to, uint256 id) internal { _ta[id] = to; emit Approval(ownerOf(id), to, id); } function _cr(address fr,address to,uint256 id,bytes memory _dt) private returns (bool) { uint256 sz; assembly { sz := extcodesize(to) } if (sz > 0) { try IR(to).onERC721Received(msg.sender, fr, id, _dt) returns (bytes4 rv) { return rv == IR.onERC721Received.selector; } catch (bytes memory rs) { if (rs.length == 0) { revert(); } else { assembly { revert(add(32, rs), mload(rs)) } } } } else { return true; } } string internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; function encode(bytes memory data) internal pure returns (string memory) { if (data.length == 0) return ''; string memory table = TABLE; uint256 encodedLen = 4 * ((data.length + 2) / 3); string memory result = new string(encodedLen + 32); assembly { mstore(result, encodedLen) let tablePtr := add(table, 1) let dataPtr := data let endPtr := add(dataPtr, mload(data)) let resultPtr := add(result, 32) for {} lt(dataPtr, endPtr) {} { dataPtr := add(dataPtr, 3) let input := mload(dataPtr) mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))) resultPtr := add(resultPtr, 1) mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))) resultPtr := add(resultPtr, 1) mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F))))) resultPtr := add(resultPtr, 1) mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F))))) resultPtr := add(resultPtr, 1) } switch mod(mload(data), 3) case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) } case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) } } return result; } function draw(string memory i) public pure returns (bytes memory) { return abi.encodePacked(hex"3c7376672077696474683d223138303022206865696768743d22313437352220786d6c6e733d22687474703a2f2f7777772e77332e6f72672f323030302f7376672220786d6c6e733a786c696e6b3d22687474703a2f2f7777772e77332e6f72672f313939392f786c696e6b223e3c7377697463683e3c666f726569676e4f626a6563742077696474683d223138303022206865696768743d22313437352220726571756972656446656174757265733d22687474703a2f2f7777772e77332e6f72672f54522f53564731312f6665617475726523457874656e736962696c697479223e3c64697620786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c22207374796c653d2270616464696e673a31656d2031656d2031656d2031656d3b776f72642d777261703a20627265616b2d776f72643b6261636b67726f756e642d636f6c6f723a626c61636b3b636f6c6f723a677265656e3b666f6e742d66616d696c793a27436f7572696572204e6577272c6d6f6e6f73706163653b223e3c215b43444154415b", i, hex"5d5d3e3c2f6469763e3c2f666f726569676e4f626a6563743e3c2f7377697463683e3c2f7376673e"); } function tokenURI(uint256 id) public view returns (string memory s) { require(_ex(id));
s = '/* @author zefram.eth */ pragma solidity 0.8.6; interface IR { function onERC721Received(address op, address fr, uint256 id, bytes calldata dt) external returns (bytes4); } contract Quine { event Transfer(address indexed fr, address indexed to, uint256 indexed id); event Approval(address indexed ow, address indexed ad, uint256 indexed id); event ApprovalForAll(address indexed ow, address indexed op, bool ad); string public constant name = "Quine NFT"; string public constant symbol = "QUINE"; mapping(uint256 => address) private _os; mapping(address => uint256) private _bs; mapping(uint256 => address) private _ta; mapping(address => mapping(address => bool)) private _oa; constructor() { _sm(msg.sender, 1); } function supportsInterface(bytes4 ii) public pure returns (bool) { return ii == 0x80ac58cd || ii == 0x5b5e139f || ii == 0x01ffc9a7; } function balanceOf(address ow) public view returns (uint256) { require(ow != address(0)); return _bs[ow]; } function ownerOf(uint256 id) public view returns (address) { address ow = _os[id]; require(ow != address(0)); return ow; } function approve(address to, uint256 id) public { address ow = ownerOf(id); require(to != ow); require(msg.sender == ow || isApprovedForAll(ow, msg.sender)); _ap(to, id); } function getApproved(uint256 id) public view returns (address) { require(_ex(id)); return _ta[id]; } function setApprovalForAll(address op, bool ad) public { require(op != msg.sender); _oa[msg.sender][op] = ad; emit ApprovalForAll(msg.sender, op, ad); } function isApprovedForAll(address ow, address op) public view returns (bool) { return _oa[ow][op]; } function transferFrom(address fr,address to,uint256 id) public { require(_ao(msg.sender, id)); _tr(fr, to, id); } function safeTransferFrom(address fr,address to,uint256 id) public { safeTransferFrom(fr, to, id, ""); } function safeTransferFrom(address fr,address to,uint256 id,bytes memory _dt) public { require(_ao(msg.sender, id)); _st(fr, to, id, _dt); } function _st(address fr,address to,uint256 id,bytes memory _dt) internal { _tr(fr, to, id); require(_cr(fr, to, id, _dt)); } function _ex(uint256 id) internal view returns (bool) { return _os[id] != address(0); } function _ao(address sp, uint256 id) internal view returns (bool) { require(_ex(id)); address ow = ownerOf(id); return (sp == ow || getApproved(id) == sp || isApprovedForAll(ow, sp)); } function _sm(address to, uint256 id) internal { require(to != address(0)); require(!_ex(id)); _bs[to] += 1; _os[id] = to; emit Transfer(address(0), to, id); require(_cr(address(0), to, id, "")); } function _tr(address fr,address to,uint256 id) internal { require(ownerOf(id) == fr); require(to != address(0)); _ap(address(0), id); _bs[fr] -= 1; _bs[to] += 1; _os[id] = to; emit Transfer(fr, to, id); } function _ap(address to, uint256 id) internal { _ta[id] = to; emit Approval(ownerOf(id), to, id); } function _cr(address fr,address to,uint256 id,bytes memory _dt) private returns (bool) { uint256 sz; assembly { sz := extcodesize(to) } if (sz > 0) { try IR(to).onERC721Received(msg.sender, fr, id, _dt) returns (bytes4 rv) { return rv == IR.onERC721Received.selector; } catch (bytes memory rs) { if (rs.length == 0) { revert(); } else { assembly { revert(add(32, rs), mload(rs)) } } } } else { return true; } } string internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; function encode(bytes memory data) internal pure returns (string memory) { if (data.length == 0) return ''; string memory table = TABLE; uint256 encodedLen = 4 * ((data.length + 2) / 3); string memory result = new string(encodedLen + 32); assembly { mstore(result, encodedLen) let tablePtr := add(table, 1) let dataPtr := data let endPtr := add(dataPtr, mload(data)) let resultPtr := add(result, 32) for {} lt(dataPtr, endPtr) {} { dataPtr := add(dataPtr, 3) let input := mload(dataPtr) mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))) resultPtr := add(resultPtr, 1) mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))) resultPtr := add(resultPtr, 1) mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F))))) resultPtr := add(resultPtr, 1) mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F))))) resultPtr := add(resultPtr, 1) } switch mod(mload(data), 3) case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) } case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) } } return result; } function draw(string memory i) public pure returns (bytes memory) { return abi.encodePacked(hex"3c7376672077696474683d223138303022206865696768743d22313437352220786d6c6e733d22687474703a2f2f7777772e77332e6f72672f323030302f7376672220786d6c6e733a786c696e6b3d22687474703a2f2f7777772e77332e6f72672f313939392f786c696e6b223e3c7377697463683e3c666f726569676e4f626a6563742077696474683d223138303022206865696768743d22313437352220726571756972656446656174757265733d22687474703a2f2f7777772e77332e6f72672f54522f53564731312f6665617475726523457874656e736962696c697479223e3c64697620786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c22207374796c653d2270616464696e673a31656d2031656d2031656d2031656d3b776f72642d777261703a20627265616b2d776f72643b6261636b67726f756e642d636f6c6f723a626c61636b3b636f6c6f723a677265656e3b666f6e742d66616d696c793a27436f7572696572204e6577272c6d6f6e6f73706163653b223e3c215b43444154415b", i, hex"5d5d3e3c2f6469763e3c2f666f726569676e4f626a6563743e3c2f7377697463683e3c2f7376673e"); } function tokenURI(uint256 id) public view returns (string memory s) { require(_ex(id));';
string memory t0 = "73203d20737472696e67286162692e656e636f64655061636b65642822646174613a6170706c69636174696f6e2f6a736f6e3b6261736536342c222c20656e636f6465286162692e656e636f64655061636b656428277b226e616d65223a22272c206e616d652c2027222c20226465736372697074696f6e223a2241207175696e6520697320612070726f6772616d2074686174206f75747075747320697473206f776e20736f7572636520636f64652e2054686973204e46542067656e65726174657320697473656c662e222c2022696d6167655f64617461223a2022272c2027646174613a696d6167652f7376672b786d6c3b6261736536342c272c20656e636f6465286279746573286472617728737472696e67286162692e656e636f64655061636b656428732c20225c6e73203d2027222c20732c2022273b5c6e737472696e67206d656d6f7279207430203d205c22222c2074302c20225c223b5c6e6279746573206d656d6f7279207431203d206865785c22222c2074302c20225c223b5c6e222c2074312929292929202c2027227d27292929293b7d7d";
bytes memory t1 = hex"73203d20737472696e67286162692e656e636f64655061636b65642822646174613a6170706c69636174696f6e2f6a736f6e3b6261736536342c222c20656e636f6465286162692e656e636f64655061636b656428277b226e616d65223a22272c206e616d652c2027222c20226465736372697074696f6e223a2241207175696e6520697320612070726f6772616d2074686174206f75747075747320697473206f776e20736f7572636520636f64652e2054686973204e46542067656e65726174657320697473656c662e222c2022696d6167655f64617461223a2022272c2027646174613a696d6167652f7376672b786d6c3b6261736536342c272c20656e636f6465286279746573286472617728737472696e67286162692e656e636f64655061636b656428732c20225c6e73203d2027222c20732c2022273b5c6e737472696e67206d656d6f7279207430203d205c22222c2074302c20225c223b5c6e6279746573206d656d6f7279207431203d206865785c22222c2074302c20225c223b5c6e222c2074312929292929202c2027227d27292929293b7d7d";
s = string(abi.encodePacked("data:application/json;base64,", encode(abi.encodePacked('{"name":"', name, '", "description":"A quine is a program that outputs its own source code. This NFT contract outputs itself.", "image_data": "', 'data:image/svg+xml;base64,', encode(bytes(draw(string(abi.encodePacked(s, "\ns = '", s, "';\nstring memory t0 = \"", t0, "\";\nbytes memory t1 = hex\"", t0, "\";\n", t1))))) , '"}'))));}}