/**

 *Submitted for verification at Etherscan.io on 2019-08-29

*/



// File: contracts/Reversi.sol



pragma solidity ^0.4.18;



library Reversi {

    // event DebugBool(bool boolean);

    // event DebugBoard(bytes16 board);

    // event DebugUint(uint u);

    uint8 constant BLACK = 1; //0b01 //0x1

    uint8 constant WHITE = 2; //0b10 //0x2

    uint8 constant EMPTY = 3; //0b11 //0x3



    struct Game {

        bool error;

        bool complete;

        bool symmetrical;

        bool RotSym;

        bool Y0Sym;

        bool X0Sym;

        bool XYSym;

        bool XnYSym;

        bytes16 board;

        bytes28 first32Moves;

        bytes28 lastMoves;



        uint8 currentPlayer;

        uint8 moveKey;

        uint8 blackScore;

        uint8 whiteScore;

        // string msg;

    }





    function isValid (bytes28[2] moves) public pure returns (bool) {

        Game memory game = playGame(moves);

        if (game.error) {

            return false;

        } else if (!game.complete) {

            return false;

        } else {

            return true;

        }

    }



    function getGame (bytes28[2] moves) public pure returns (bool error, bool complete, bool symmetrical, bytes16 board, uint8 currentPlayer, uint8 moveKey) {

      Game memory game = playGame(moves);

        return (

            game.error,

            game.complete,

            game.symmetrical,

            game.board,

            game.currentPlayer,

            game.moveKey

            // game.msg

        );

    }



    function showColors () public pure returns(uint8, uint8, uint8) {

        return (EMPTY, BLACK, WHITE);

    }



    function playGame (bytes28[2] moves) internal pure returns (Game)  {

        Game memory game;



        game.first32Moves = moves[0];

        game.lastMoves = moves[1];

        game.moveKey = 0;

        game.blackScore = 2;

        game.whiteScore = 2;



        game.error = false;

        game.complete = false;

        game.currentPlayer = BLACK;





        // game.board = bytes16(10625432672847758622720); // completely empty board

        game.board = bytes16(340282366920938456379662753540715053055); // empty board except for center pieces



        bool skip;

        uint8 move;

        uint8 col;

        uint8 row;

        uint8 i;

        bytes28 currentMoves;



        for (i = 0; i < 60 && !skip; i++) {

            currentMoves = game.moveKey < 32 ? game.first32Moves : game.lastMoves;

            move = readMove(currentMoves, game.moveKey % 32, 32);

            (col, row) = convertMove(move);

            skip = !validMove(move);

            if (i == 0 && (col != 2 || row != 3)) {

                skip = true; // this is to force the first move to always be C4 to avoid repeatable boards via mirroring translations

                game.error = true;

            }

            if (!skip && col < 8 && row < 8 && col >= 0 && row >= 0) {

                // game.msg = "make a move";

                game = makeMove(game, col, row);

                game.moveKey = game.moveKey + 1;

                if (game.error) {

                    game.error = false;

                    // maybe player has no valid moves and must pass

                    if (game.currentPlayer == BLACK) {

                        game.currentPlayer = WHITE;

                    } else {

                        game.currentPlayer = BLACK;

                    }

                    game = makeMove(game, col, row);

                    if (game.error) {

                        game.error = true;

                        skip = true;

                    }

                }

            }

        }

        if (!game.error) {

            game.error = false;

            game = isComplete(game);

            game = isSymmetrical(game);

        }

        return game;

    }



    function makeMove (Game memory game, uint8 col, uint8 row) internal pure returns (Game)  {

        // square is already occupied

        if (returnTile(game.board, col, row) != EMPTY){

            game.error = true;

            // game.msg = "Invalid Game (square is already occupied)";

            return game;

        }

        int8[2][8] memory possibleDirections;

        uint8  possibleDirectionsLength;

        (possibleDirections, possibleDirectionsLength) = getPossibleDirections(game, col, row);

        // no valid directions

        if (possibleDirectionsLength == 0) {

            game.error = true;

            // game.msg = "Invalid Game (doesnt border other tiles)";

            return game;

        }



        bytes28 newFlips;

        uint8 newFlipsLength;

        uint8 newFlipCol;

        uint8 newFlipRow;

        uint8 j;

        bool valid = false;

        for (uint8 i = 0; i < possibleDirectionsLength; i++) {

            delete newFlips;

            delete newFlipsLength;

            (newFlips, newFlipsLength) = traverseDirection(game, possibleDirections[i], col, row);

            for (j = 0; j < newFlipsLength; j++) {

                if (!valid) valid = true;

                (newFlipCol, newFlipRow) = convertMove(readMove(newFlips, j, newFlipsLength));

                game.board = turnTile(game.board, game.currentPlayer, newFlipCol, newFlipRow);

                if (game.currentPlayer == WHITE) {

                    game.whiteScore += 1;

                    game.blackScore -= 1;

                } else {

                    game.whiteScore -= 1;

                    game.blackScore += 1;

                }

            }

        }



        //no valid flips in directions

        if (valid) {

            game.board = turnTile(game.board, game.currentPlayer, col, row);

            if (game.currentPlayer == WHITE) {

                game.whiteScore += 1;

            } else {

                game.blackScore += 1;

            }

        } else {

            game.error = true;

            // game.msg = "Invalid Game (doesnt flip any other tiles)";

            return game;

        }



        // switch players

        if (game.currentPlayer == BLACK) {

            game.currentPlayer = WHITE;

        } else {

            game.currentPlayer = BLACK;

        }

        return game;

    }



    function getPossibleDirections (Game memory game, uint8 col, uint8 row) internal pure returns(int8[2][8], uint8){



        int8[2][8] memory possibleDirections;

        uint8 possibleDirectionsLength = 0;

        int8[2][8] memory dirs = [

            [int8(-1), int8(0)], // W

            [int8(-1), int8(1)], // SW

            [int8(0), int8(1)], // S

            [int8(1), int8(1)], // SE

            [int8(1), int8(0)], // E

            [int8(1), int8(-1)], // NE

            [int8(0), int8(-1)], // N

            [int8(-1), int8(-1)] // NW

        ];

        int8 focusedRowPos;

        int8 focusedColPos;

        int8[2] memory dir;

        uint8 testSquare;



        for (uint8 i = 0; i < 8; i++) {

            dir = dirs[i];

            focusedColPos = int8(col) + dir[0];

            focusedRowPos = int8(row) + dir[1];



            // if tile is off the board it is not a valid move

            if (!(focusedRowPos > 7 || focusedRowPos < 0 || focusedColPos > 7 || focusedColPos < 0)) {

                testSquare = returnTile(game.board, uint8(focusedColPos), uint8(focusedRowPos));



                // if the surrounding tile is current color or no color it can"t be part of a capture

                if (testSquare != game.currentPlayer) {

                    if (testSquare != EMPTY) {

                        possibleDirections[possibleDirectionsLength] = dir;

                        possibleDirectionsLength++;

                    }

                }

            }

        }

        return (possibleDirections, possibleDirectionsLength);

    }



    function traverseDirection (Game memory game, int8[2] dir, uint8 col, uint8 row) internal pure returns(bytes28, uint8) {

        bytes28 potentialFlips;

        uint8 potentialFlipsLength = 0;



        if (game.currentPlayer == BLACK) {

            uint8 opponentColor = WHITE;

        } else {

            opponentColor = BLACK;

        }



        // take one step at a time in this direction

        // ignoring the first step look for the same color as your tile

        bool skip = false;

        int8 testCol;

        int8 testRow;

        uint8 tile;

        for (uint8 j = 1; j < 9; j++) {

            if (!skip) {

                testCol = (int8(j) * dir[0]) + int8(col);

                testRow = (int8(j) * dir[1]) + int8(row);

                // ran off the board before hitting your own tile

                if (testCol > 7 || testCol < 0 || testRow > 7 || testRow < 0) {

                    delete potentialFlips;

                    potentialFlipsLength = 0;

                    skip = true;

                } else{



                    tile = returnTile(game.board, uint8(testCol), uint8(testRow));



                    if (tile == opponentColor) {

                        // if tile is opposite color it could be flipped, so add to potential flip array

                        (potentialFlips, potentialFlipsLength) = addMove(potentialFlips, potentialFlipsLength, uint8(testCol), uint8(testRow));

                    } else if (tile == game.currentPlayer && j > 1) {

                        // hit current players tile which means capture is complete

                        skip = true;

                    } else {

                        // either hit current players own color before hitting an opponent"s

                        // or hit an empty space

                        delete potentialFlips;

                        delete potentialFlipsLength;

                        skip = true;

                    }

                }

            }

        }

        return (potentialFlips, potentialFlipsLength);

    }



    function isComplete (Game memory game) internal pure returns (Game) {



        if (game.moveKey == 60) {

            // game.msg = "good game";

            game.complete = true;

            return game;

        } else {

            uint8[2][60] memory empties;

            uint8 emptiesLength = 0;

            for (uint8 i = 0; i < 64; i++) {

                uint8 tile = returnTile(game.board, ((i - (i % 8)) / 8), (i % 8));

                if (tile == EMPTY) {

                    empties[emptiesLength] = [((i - (i % 8)) / 8), (i % 8)];

                    emptiesLength++;

                }

            }

            bool validMovesRemains = false;

            if (emptiesLength > 0) {

                bytes16 board = game.board;

                uint8[2] memory move;

                for (i = 0; i < emptiesLength && !validMovesRemains; i++) {

                    move = empties[i];



                    game.currentPlayer = BLACK;

                    game.error = false;

                    game.board = board;

                    game = makeMove(game, move[0], move[1]);

                    if (!game.error) {

                        validMovesRemains = true;

                    }

                    game.currentPlayer = WHITE;

                    game.error = false;

                    game.board = board;

                    game = makeMove(game, move[0], move[1]);

                    if (!game.error) {

                        validMovesRemains = true;

                    }

                }

                game.board = board;

            }

            if (validMovesRemains) {

                game.error = true;

                // game.msg = "Invalid Game (moves still available)";

            } else {

                // game.msg = "good game";

                game.complete = true;

                game.error = false;

            }

        }

        return game;

    }



    function isSymmetrical (Game memory game) internal pure returns (Game) {

        bool RotSym = true;

        bool Y0Sym = true;

        bool X0Sym = true;

        bool XYSym = true;

        bool XnYSym = true;

        for (uint8 i = 0; i < 8 && (RotSym || Y0Sym || X0Sym || XYSym || XnYSym); i++) {

            for (uint8 j = 0; j < 8 && (RotSym || Y0Sym || X0Sym || XYSym || XnYSym); j++) {



                // rotational symmetry

                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - i), (7 - j))) {

                    RotSym = false;

                }

                // symmetry on y = 0

                if (returnBytes(game.board, i, j) != returnBytes(game.board, i, (7 - j))) {

                    Y0Sym = false;

                }

                // symmetry on x = 0

                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - i), j)) {

                    X0Sym = false;

                }

                // symmetry on x = y

                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - j), (7 - i))) {

                    XYSym = false;

                }

                // symmetry on x = -y

                if (returnBytes(game.board, i, j) != returnBytes(game.board, j, i)) {

                    XnYSym = false;

                }

            }

        }

        if (RotSym || Y0Sym || X0Sym || XYSym || XnYSym) {

            game.symmetrical = true;

            game.RotSym = RotSym;

            game.Y0Sym = Y0Sym;

            game.X0Sym = X0Sym;

            game.XYSym = XYSym;

            game.XnYSym = XnYSym;

        }

        return game;

    }







    // Utilities



    function returnSymmetricals (bool RotSym, bool Y0Sym, bool X0Sym, bool XYSym, bool XnYSym) public view returns (uint256) {

        uint256 symmetries = (RotSym ? 1  : 0) << 1;

        symmetries = (symmetries & (Y0Sym ? 1 : 0)) << 1;

        symmetries = (symmetries & (X0Sym ? 1 : 0)) << 1;

        symmetries = (symmetries & (XYSym ? 1 : 0)) << 1;

        symmetries = symmetries & (XnYSym ? 1 : 0);

        return symmetries;

    }





    function returnBytes (bytes16 board, uint8 col, uint8 row) internal pure returns (bytes16) {

        uint128 push = posToPush(col, row);

        return (board >> push) & bytes16(3);

    }



    function turnTile (bytes16 board, uint8 color, uint8 col, uint8 row) internal pure returns (bytes16){

        if (col > 7) revert();

        if (row > 7) revert();

        uint128 push = posToPush(col, row);

        bytes16 mask = bytes16(3) << push;// 0b00000011 (ones)



        board = ((board ^ mask) & board);



        return board | (bytes16(color) << push);

    }



    function returnTile (bytes16 board, uint8 col, uint8 row) internal pure returns (uint8){

        uint128 push = posToPush(col, row);

        bytes16 tile = (board >> push ) & bytes16(3);

        return uint8(tile); // returns 2

    }



    function posToPush (uint8 col, uint8 row) internal pure returns (uint128){

        return uint128(((64) - ((8 * col) + row + 1)) * 2);

    }



    function readMove (bytes28 moveSequence, uint8 moveKey, uint8 movesLength) public pure returns(uint8) {

        bytes28 mask = bytes28(127);

        uint8 push = (movesLength * 7) - (moveKey * 7) - 7;

        return uint8((moveSequence >> push) & mask);

    }



    function addMove (bytes28 moveSequence, uint8 movesLength, uint8 col, uint8 row) internal pure returns (bytes28, uint8) {

        bytes28 move = bytes28(col + (row * 8) + 64);

        moveSequence = moveSequence << 7;

        moveSequence = moveSequence | move;

        movesLength++;

        return (moveSequence, movesLength);

    }



    function validMove (uint8 move) internal pure returns(bool) {

        return move >= 64;

    }



    function convertMove (uint8 move) public pure returns(uint8, uint8) {

        move = move - 64;

        uint8 col = move % 8;

        uint8 row = (move - col) / 8;

        return (col, row);

    }





}



// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol



pragma solidity ^0.4.24;





/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * See https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}



// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.4.24;







/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 is ERC20Basic {

  function allowance(address owner, address spender)

    public view returns (uint256);



  function transferFrom(address from, address to, uint256 value)

    public returns (bool);



  function approve(address spender, uint256 value) public returns (bool);

  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}



// File: zeppelin-solidity/contracts/introspection/ERC165.sol



pragma solidity ^0.4.24;





/**

 * @title ERC165

 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md

 */

interface ERC165 {



  /**

   * @notice Query if a contract implements an interface

   * @param _interfaceId The interface identifier, as specified in ERC-165

   * @dev Interface identification is specified in ERC-165. This function

   * uses less than 30,000 gas.

   */

  function supportsInterface(bytes4 _interfaceId)

    external

    view

    returns (bool);

}



// File: zeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol



pragma solidity ^0.4.24;







/**

 * @title ERC721 Non-Fungible Token Standard basic interface

 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721Basic is ERC165 {

  event Transfer(

    address indexed _from,

    address indexed _to,

    uint256 indexed _tokenId

  );

  event Approval(

    address indexed _owner,

    address indexed _approved,

    uint256 indexed _tokenId

  );

  event ApprovalForAll(

    address indexed _owner,

    address indexed _operator,

    bool _approved

  );



  function balanceOf(address _owner) public view returns (uint256 _balance);

  function ownerOf(uint256 _tokenId) public view returns (address _owner);

  function exists(uint256 _tokenId) public view returns (bool _exists);



  function approve(address _to, uint256 _tokenId) public;

  function getApproved(uint256 _tokenId)

    public view returns (address _operator);



  function setApprovalForAll(address _operator, bool _approved) public;

  function isApprovedForAll(address _owner, address _operator)

    public view returns (bool);



  function transferFrom(address _from, address _to, uint256 _tokenId) public;

  function safeTransferFrom(address _from, address _to, uint256 _tokenId)

    public;



  function safeTransferFrom(

    address _from,

    address _to,

    uint256 _tokenId,

    bytes _data

  )

    public;

}



// File: zeppelin-solidity/contracts/token/ERC721/ERC721.sol



pragma solidity ^0.4.24;







/**

 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension

 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721Enumerable is ERC721Basic {

  function totalSupply() public view returns (uint256);

  function tokenOfOwnerByIndex(

    address _owner,

    uint256 _index

  )

    public

    view

    returns (uint256 _tokenId);



  function tokenByIndex(uint256 _index) public view returns (uint256);

}





/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721Metadata is ERC721Basic {

  function name() external view returns (string _name);

  function symbol() external view returns (string _symbol);

  function tokenURI(uint256 _tokenId) public view returns (string);

}





/**

 * @title ERC-721 Non-Fungible Token Standard, full implementation interface

 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {

}



// File: zeppelin-solidity/contracts/token/ERC721/ERC721Receiver.sol



pragma solidity ^0.4.24;





/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

contract ERC721Receiver {

  /**

   * @dev Magic value to be returned upon successful reception of an NFT

   *  Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`,

   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`

   */

  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;



  /**

   * @notice Handle the receipt of an NFT

   * @dev The ERC721 smart contract calls this function on the recipient

   * after a `safetransfer`. This function MAY throw to revert and reject the

   * transfer. Return of other than the magic value MUST result in the 

   * transaction being reverted.

   * Note: the contract address is always the message sender.

   * @param _operator The address which called `safeTransferFrom` function

   * @param _from The address which previously owned the token

   * @param _tokenId The NFT identifier which is being transfered

   * @param _data Additional data with no specified format

   * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

   */

  function onERC721Received(

    address _operator,

    address _from,

    uint256 _tokenId,

    bytes _data

  )

    public

    returns(bytes4);

}



// File: zeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.4.24;





/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (a == 0) {

      return 0;

    }



    c = a * b;

    assert(c / a == b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    // assert(b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return a / b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {

    c = a + b;

    assert(c >= a);

    return c;

  }

}



// File: zeppelin-solidity/contracts/AddressUtils.sol



pragma solidity ^0.4.24;





/**

 * Utility library of inline functions on addresses

 */

library AddressUtils {



  /**

   * Returns whether the target address is a contract

   * @dev This function will return false if invoked during the constructor of a contract,

   * as the code is not actually created until after the constructor finishes.

   * @param addr address to check

   * @return whether the target address is a contract

   */

  function isContract(address addr) internal view returns (bool) {

    uint256 size;

    // XXX Currently there is no better way to check if there is a contract in an address

    // than to check the size of the code at that address.

    // See https://ethereum.stackexchange.com/a/14016/36603

    // for more details about how this works.

    // TODO Check this again before the Serenity release, because all addresses will be

    // contracts then.

    // solium-disable-next-line security/no-inline-assembly

    assembly { size := extcodesize(addr) }

    return size > 0;

  }



}



// File: zeppelin-solidity/contracts/introspection/SupportsInterfaceWithLookup.sol



pragma solidity ^0.4.24;







/**

 * @title SupportsInterfaceWithLookup

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract SupportsInterfaceWithLookup is ERC165 {

  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;

  /**

   * 0x01ffc9a7 ===

   *   bytes4(keccak256('supportsInterface(bytes4)'))

   */



  /**

   * @dev a mapping of interface id to whether or not it's supported

   */

  mapping(bytes4 => bool) internal supportedInterfaces;



  /**

   * @dev A contract implementing SupportsInterfaceWithLookup

   * implement ERC165 itself

   */

  constructor()

    public

  {

    _registerInterface(InterfaceId_ERC165);

  }



  /**

   * @dev implement supportsInterface(bytes4) using a lookup table

   */

  function supportsInterface(bytes4 _interfaceId)

    external

    view

    returns (bool)

  {

    return supportedInterfaces[_interfaceId];

  }



  /**

   * @dev private method for registering an interface

   */

  function _registerInterface(bytes4 _interfaceId)

    internal

  {

    require(_interfaceId != 0xffffffff);

    supportedInterfaces[_interfaceId] = true;

  }

}



// File: zeppelin-solidity/contracts/token/ERC721/ERC721BasicToken.sol



pragma solidity ^0.4.24;















/**

 * @title ERC721 Non-Fungible Token Standard basic implementation

 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {



  bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;

  /*

   * 0x80ac58cd ===

   *   bytes4(keccak256('balanceOf(address)')) ^

   *   bytes4(keccak256('ownerOf(uint256)')) ^

   *   bytes4(keccak256('approve(address,uint256)')) ^

   *   bytes4(keccak256('getApproved(uint256)')) ^

   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^

   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^

   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^

   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^

   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))

   */



  bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79;

  /*

   * 0x4f558e79 ===

   *   bytes4(keccak256('exists(uint256)'))

   */



  using SafeMath for uint256;

  using AddressUtils for address;



  // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`

  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`

  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;



  // Mapping from token ID to owner

  mapping (uint256 => address) internal tokenOwner;



  // Mapping from token ID to approved address

  mapping (uint256 => address) internal tokenApprovals;



  // Mapping from owner to number of owned token

  mapping (address => uint256) internal ownedTokensCount;



  // Mapping from owner to operator approvals

  mapping (address => mapping (address => bool)) internal operatorApprovals;



  /**

   * @dev Guarantees msg.sender is owner of the given token

   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender

   */

  modifier onlyOwnerOf(uint256 _tokenId) {

    require(ownerOf(_tokenId) == msg.sender);

    _;

  }



  /**

   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator

   * @param _tokenId uint256 ID of the token to validate

   */

  modifier canTransfer(uint256 _tokenId) {

    require(isApprovedOrOwner(msg.sender, _tokenId));

    _;

  }



  constructor()

    public

  {

    // register the supported interfaces to conform to ERC721 via ERC165

    _registerInterface(InterfaceId_ERC721);

    _registerInterface(InterfaceId_ERC721Exists);

  }



  /**

   * @dev Gets the balance of the specified address

   * @param _owner address to query the balance of

   * @return uint256 representing the amount owned by the passed address

   */

  function balanceOf(address _owner) public view returns (uint256) {

    require(_owner != address(0));

    return ownedTokensCount[_owner];

  }



  /**

   * @dev Gets the owner of the specified token ID

   * @param _tokenId uint256 ID of the token to query the owner of

   * @return owner address currently marked as the owner of the given token ID

   */

  function ownerOf(uint256 _tokenId) public view returns (address) {

    address owner = tokenOwner[_tokenId];

    require(owner != address(0));

    return owner;

  }



  /**

   * @dev Returns whether the specified token exists

   * @param _tokenId uint256 ID of the token to query the existence of

   * @return whether the token exists

   */

  function exists(uint256 _tokenId) public view returns (bool) {

    address owner = tokenOwner[_tokenId];

    return owner != address(0);

  }



  /**

   * @dev Approves another address to transfer the given token ID

   * The zero address indicates there is no approved address.

   * There can only be one approved address per token at a given time.

   * Can only be called by the token owner or an approved operator.

   * @param _to address to be approved for the given token ID

   * @param _tokenId uint256 ID of the token to be approved

   */

  function approve(address _to, uint256 _tokenId) public {

    address owner = ownerOf(_tokenId);

    require(_to != owner);

    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));



    tokenApprovals[_tokenId] = _to;

    emit Approval(owner, _to, _tokenId);

  }



  /**

   * @dev Gets the approved address for a token ID, or zero if no address set

   * @param _tokenId uint256 ID of the token to query the approval of

   * @return address currently approved for the given token ID

   */

  function getApproved(uint256 _tokenId) public view returns (address) {

    return tokenApprovals[_tokenId];

  }



  /**

   * @dev Sets or unsets the approval of a given operator

   * An operator is allowed to transfer all tokens of the sender on their behalf

   * @param _to operator address to set the approval

   * @param _approved representing the status of the approval to be set

   */

  function setApprovalForAll(address _to, bool _approved) public {

    require(_to != msg.sender);

    operatorApprovals[msg.sender][_to] = _approved;

    emit ApprovalForAll(msg.sender, _to, _approved);

  }



  /**

   * @dev Tells whether an operator is approved by a given owner

   * @param _owner owner address which you want to query the approval of

   * @param _operator operator address which you want to query the approval of

   * @return bool whether the given operator is approved by the given owner

   */

  function isApprovedForAll(

    address _owner,

    address _operator

  )

    public

    view

    returns (bool)

  {

    return operatorApprovals[_owner][_operator];

  }



  /**

   * @dev Transfers the ownership of a given token ID to another address

   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible

   * Requires the msg sender to be the owner, approved, or operator

   * @param _from current owner of the token

   * @param _to address to receive the ownership of the given token ID

   * @param _tokenId uint256 ID of the token to be transferred

  */

  function transferFrom(

    address _from,

    address _to,

    uint256 _tokenId

  )

    public

    canTransfer(_tokenId)

  {

    require(_from != address(0));

    require(_to != address(0));



    clearApproval(_from, _tokenId);

    removeTokenFrom(_from, _tokenId);

    addTokenTo(_to, _tokenId);



    emit Transfer(_from, _to, _tokenId);

  }



  /**

   * @dev Safely transfers the ownership of a given token ID to another address

   * If the target address is a contract, it must implement `onERC721Received`,

   * which is called upon a safe transfer, and return the magic value

   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

   * the transfer is reverted.

   *

   * Requires the msg sender to be the owner, approved, or operator

   * @param _from current owner of the token

   * @param _to address to receive the ownership of the given token ID

   * @param _tokenId uint256 ID of the token to be transferred

  */

  function safeTransferFrom(

    address _from,

    address _to,

    uint256 _tokenId

  )

    public

    canTransfer(_tokenId)

  {

    // solium-disable-next-line arg-overflow

    safeTransferFrom(_from, _to, _tokenId, "");

  }



  /**

   * @dev Safely transfers the ownership of a given token ID to another address

   * If the target address is a contract, it must implement `onERC721Received`,

   * which is called upon a safe transfer, and return the magic value

   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,

   * the transfer is reverted.

   * Requires the msg sender to be the owner, approved, or operator

   * @param _from current owner of the token

   * @param _to address to receive the ownership of the given token ID

   * @param _tokenId uint256 ID of the token to be transferred

   * @param _data bytes data to send along with a safe transfer check

   */

  function safeTransferFrom(

    address _from,

    address _to,

    uint256 _tokenId,

    bytes _data

  )

    public

    canTransfer(_tokenId)

  {

    transferFrom(_from, _to, _tokenId);

    // solium-disable-next-line arg-overflow

    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));

  }



  /**

   * @dev Returns whether the given spender can transfer a given token ID

   * @param _spender address of the spender to query

   * @param _tokenId uint256 ID of the token to be transferred

   * @return bool whether the msg.sender is approved for the given token ID,

   *  is an operator of the owner, or is the owner of the token

   */

  function isApprovedOrOwner(

    address _spender,

    uint256 _tokenId

  )

    internal

    view

    returns (bool)

  {

    address owner = ownerOf(_tokenId);

    // Disable solium check because of

    // https://github.com/duaraghav8/Solium/issues/175

    // solium-disable-next-line operator-whitespace

    return (

      _spender == owner ||

      getApproved(_tokenId) == _spender ||

      isApprovedForAll(owner, _spender)

    );

  }



  /**

   * @dev Internal function to mint a new token

   * Reverts if the given token ID already exists

   * @param _to The address that will own the minted token

   * @param _tokenId uint256 ID of the token to be minted by the msg.sender

   */

  function _mint(address _to, uint256 _tokenId) internal {

    require(_to != address(0));

    addTokenTo(_to, _tokenId);

    emit Transfer(address(0), _to, _tokenId);

  }



  /**

   * @dev Internal function to burn a specific token

   * Reverts if the token does not exist

   * @param _tokenId uint256 ID of the token being burned by the msg.sender

   */

  function _burn(address _owner, uint256 _tokenId) internal {

    clearApproval(_owner, _tokenId);

    removeTokenFrom(_owner, _tokenId);

    emit Transfer(_owner, address(0), _tokenId);

  }



  /**

   * @dev Internal function to clear current approval of a given token ID

   * Reverts if the given address is not indeed the owner of the token

   * @param _owner owner of the token

   * @param _tokenId uint256 ID of the token to be transferred

   */

  function clearApproval(address _owner, uint256 _tokenId) internal {

    require(ownerOf(_tokenId) == _owner);

    if (tokenApprovals[_tokenId] != address(0)) {

      tokenApprovals[_tokenId] = address(0);

    }

  }



  /**

   * @dev Internal function to add a token ID to the list of a given address

   * @param _to address representing the new owner of the given token ID

   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address

   */

  function addTokenTo(address _to, uint256 _tokenId) internal {

    require(tokenOwner[_tokenId] == address(0));

    tokenOwner[_tokenId] = _to;

    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);

  }



  /**

   * @dev Internal function to remove a token ID from the list of a given address

   * @param _from address representing the previous owner of the given token ID

   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address

   */

  function removeTokenFrom(address _from, uint256 _tokenId) internal {

    require(ownerOf(_tokenId) == _from);

    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);

    tokenOwner[_tokenId] = address(0);

  }



  /**

   * @dev Internal function to invoke `onERC721Received` on a target address

   * The call is not executed if the target address is not a contract

   * @param _from address representing the previous owner of the given token ID

   * @param _to target address that will receive the tokens

   * @param _tokenId uint256 ID of the token to be transferred

   * @param _data bytes optional data to send along with the call

   * @return whether the call correctly returned the expected magic value

   */

  function checkAndCallSafeTransfer(

    address _from,

    address _to,

    uint256 _tokenId,

    bytes _data

  )

    internal

    returns (bool)

  {

    if (!_to.isContract()) {

      return true;

    }

    bytes4 retval = ERC721Receiver(_to).onERC721Received(

      msg.sender, _from, _tokenId, _data);

    return (retval == ERC721_RECEIVED);

  }

}



// File: zeppelin-solidity/contracts/token/ERC721/ERC721Token.sol



pragma solidity ^0.4.24;











/**

 * @title Full ERC721 Token

 * This implementation includes all the required and some optional functionality of the ERC721 standard

 * Moreover, it includes approve all functionality using operator terminology

 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

 */

contract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {



  bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;

  /**

   * 0x780e9d63 ===

   *   bytes4(keccak256('totalSupply()')) ^

   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^

   *   bytes4(keccak256('tokenByIndex(uint256)'))

   */



  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;

  /**

   * 0x5b5e139f ===

   *   bytes4(keccak256('name()')) ^

   *   bytes4(keccak256('symbol()')) ^

   *   bytes4(keccak256('tokenURI(uint256)'))

   */



  // Token name

  string internal name_;



  // Token symbol

  string internal symbol_;



  // Mapping from owner to list of owned token IDs

  mapping(address => uint256[]) internal ownedTokens;



  // Mapping from token ID to index of the owner tokens list

  mapping(uint256 => uint256) internal ownedTokensIndex;



  // Array with all token ids, used for enumeration

  uint256[] internal allTokens;



  // Mapping from token id to position in the allTokens array

  mapping(uint256 => uint256) internal allTokensIndex;



  // Optional mapping for token URIs

  mapping(uint256 => string) internal tokenURIs;



  /**

   * @dev Constructor function

   */

  constructor(string _name, string _symbol) public {

    name_ = _name;

    symbol_ = _symbol;



    // register the supported interfaces to conform to ERC721 via ERC165

    _registerInterface(InterfaceId_ERC721Enumerable);

    _registerInterface(InterfaceId_ERC721Metadata);

  }



  /**

   * @dev Gets the token name

   * @return string representing the token name

   */

  function name() external view returns (string) {

    return name_;

  }



  /**

   * @dev Gets the token symbol

   * @return string representing the token symbol

   */

  function symbol() external view returns (string) {

    return symbol_;

  }



  /**

   * @dev Returns an URI for a given token ID

   * Throws if the token ID does not exist. May return an empty string.

   * @param _tokenId uint256 ID of the token to query

   */

  function tokenURI(uint256 _tokenId) public view returns (string) {

    require(exists(_tokenId));

    return tokenURIs[_tokenId];

  }



  /**

   * @dev Gets the token ID at a given index of the tokens list of the requested owner

   * @param _owner address owning the tokens list to be accessed

   * @param _index uint256 representing the index to be accessed of the requested tokens list

   * @return uint256 token ID at the given index of the tokens list owned by the requested address

   */

  function tokenOfOwnerByIndex(

    address _owner,

    uint256 _index

  )

    public

    view

    returns (uint256)

  {

    require(_index < balanceOf(_owner));

    return ownedTokens[_owner][_index];

  }



  /**

   * @dev Gets the total amount of tokens stored by the contract

   * @return uint256 representing the total amount of tokens

   */

  function totalSupply() public view returns (uint256) {

    return allTokens.length;

  }



  /**

   * @dev Gets the token ID at a given index of all the tokens in this contract

   * Reverts if the index is greater or equal to the total number of tokens

   * @param _index uint256 representing the index to be accessed of the tokens list

   * @return uint256 token ID at the given index of the tokens list

   */

  function tokenByIndex(uint256 _index) public view returns (uint256) {

    require(_index < totalSupply());

    return allTokens[_index];

  }



  /**

   * @dev Internal function to set the token URI for a given token

   * Reverts if the token ID does not exist

   * @param _tokenId uint256 ID of the token to set its URI

   * @param _uri string URI to assign

   */

  function _setTokenURI(uint256 _tokenId, string _uri) internal {

    require(exists(_tokenId));

    tokenURIs[_tokenId] = _uri;

  }



  /**

   * @dev Internal function to add a token ID to the list of a given address

   * @param _to address representing the new owner of the given token ID

   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address

   */

  function addTokenTo(address _to, uint256 _tokenId) internal {

    super.addTokenTo(_to, _tokenId);

    uint256 length = ownedTokens[_to].length;

    ownedTokens[_to].push(_tokenId);

    ownedTokensIndex[_tokenId] = length;

  }



  /**

   * @dev Internal function to remove a token ID from the list of a given address

   * @param _from address representing the previous owner of the given token ID

   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address

   */

  function removeTokenFrom(address _from, uint256 _tokenId) internal {

    super.removeTokenFrom(_from, _tokenId);



    uint256 tokenIndex = ownedTokensIndex[_tokenId];

    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);

    uint256 lastToken = ownedTokens[_from][lastTokenIndex];



    ownedTokens[_from][tokenIndex] = lastToken;

    ownedTokens[_from][lastTokenIndex] = 0;

    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to

    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping

    // the lastToken to the first position, and then dropping the element placed in the last position of the list



    ownedTokens[_from].length--;

    ownedTokensIndex[_tokenId] = 0;

    ownedTokensIndex[lastToken] = tokenIndex;

  }



  /**

   * @dev Internal function to mint a new token

   * Reverts if the given token ID already exists

   * @param _to address the beneficiary that will own the minted token

   * @param _tokenId uint256 ID of the token to be minted by the msg.sender

   */

  function _mint(address _to, uint256 _tokenId) internal {

    super._mint(_to, _tokenId);



    allTokensIndex[_tokenId] = allTokens.length;

    allTokens.push(_tokenId);

  }



  /**

   * @dev Internal function to burn a specific token

   * Reverts if the token does not exist

   * @param _owner owner of the token to burn

   * @param _tokenId uint256 ID of the token being burned by the msg.sender

   */

  function _burn(address _owner, uint256 _tokenId) internal {

    super._burn(_owner, _tokenId);



    // Clear metadata (if any)

    if (bytes(tokenURIs[_tokenId]).length != 0) {

      delete tokenURIs[_tokenId];

    }



    // Reorg all tokens array

    uint256 tokenIndex = allTokensIndex[_tokenId];

    uint256 lastTokenIndex = allTokens.length.sub(1);

    uint256 lastToken = allTokens[lastTokenIndex];



    allTokens[tokenIndex] = lastToken;

    allTokens[lastTokenIndex] = 0;



    allTokens.length--;

    allTokensIndex[_tokenId] = 0;

    allTokensIndex[lastToken] = tokenIndex;

  }



}



// File: zeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.4.24;





/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

  address public owner;





  event OwnershipRenounced(address indexed previousOwner);

  event OwnershipTransferred(

    address indexed previousOwner,

    address indexed newOwner

  );





  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  constructor() public {

    owner = msg.sender;

  }



  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  /**

   * @dev Allows the current owner to relinquish control of the contract.

   * @notice Renouncing to ownership will leave the contract without an owner.

   * It will not be possible to call the functions with the `onlyOwner`

   * modifier anymore.

   */

  function renounceOwnership() public onlyOwner {

    emit OwnershipRenounced(owner);

    owner = address(0);

  }



  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function transferOwnership(address _newOwner) public onlyOwner {

    _transferOwnership(_newOwner);

  }



  /**

   * @dev Transfers control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function _transferOwnership(address _newOwner) internal {

    require(_newOwner != address(0));

    emit OwnershipTransferred(owner, _newOwner);

    owner = _newOwner;

  }

}



// File: contracts/helpers/Admin.sol



pragma solidity ^0.4.24;





/**

 * @title Ownable

 * @dev The Ownable contract has an admin address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Admin {

  mapping (address => bool) public admins;





  event AdminshipRenounced(address indexed previousAdmin);

  event AdminshipTransferred(

    address indexed previousAdmin,

    address indexed newAdmin

  );





  /**

   * @dev The Ownable constructor sets the original `admin` of the contract to the sender

   * account.

   */

  constructor() public {

    admins[msg.sender] = true;

  }



  /**

   * @dev Throws if called by any account other than the admin.

   */

  modifier onlyAdmin() {

    require(admins[msg.sender]);

    _;

  }



  function isAdmin(address _admin) public view returns(bool) {

    return admins[_admin];

  }



  /**

   * @dev Allows the current admin to relinquish control of the contract.

   * @notice Renouncing to adminship will leave the contract without an admin.

   * It will not be possible to call the functions with the `onlyAdmin`

   * modifier anymore.

   */

  function renounceAdminship(address _previousAdmin) public onlyAdmin {

    emit AdminshipRenounced(_previousAdmin);

    admins[_previousAdmin] = false;

  }



  /**

   * @dev Allows the current admin to transfer control of the contract to a newAdmin.

   * @param _newAdmin The address to transfer adminship to.

   */

  function transferAdminship(address _newAdmin) public onlyAdmin {

    _transferAdminship(_newAdmin);

  }



  /**

   * @dev Transfers control of the contract to a newAdmin.

   * @param _newAdmin The address to transfer adminship to.

   */

  function _transferAdminship(address _newAdmin) internal {

    require(_newAdmin != address(0));

    emit AdminshipTransferred(msg.sender, _newAdmin);

    admins[_newAdmin] = true;

  }

}



// File: contracts/helpers/strings.sol



/*

 * @title String & slice utility library for Solidity contracts.

 * @author Nick Johnson <[email protected]>

 *

 * @dev Functionality in this library is largely implemented using an

 *      abstraction called a 'slice'. A slice represents a part of a string -

 *      anything from the entire string to a single character, or even no

 *      characters at all (a 0-length slice). Since a slice only has to specify

 *      an offset and a length, copying and manipulating slices is a lot less

 *      expensive than copying and manipulating the strings they reference.

 *

 *      To further reduce gas costs, most functions on slice that need to return

 *      a slice modify the original one instead of allocating a new one; for

 *      instance, `s.split(".")` will return the text up to the first '.',

 *      modifying s to only contain the remainder of the string after the '.'.

 *      In situations where you do not want to modify the original slice, you

 *      can make a copy first with `.copy()`, for example:

 *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since

 *      Solidity has no memory management, it will result in allocating many

 *      short-lived slices that are later discarded.

 *

 *      Functions that return two slices come in two versions: a non-allocating

 *      version that takes the second slice as an argument, modifying it in

 *      place, and an allocating version that allocates and returns the second

 *      slice; see `nextRune` for example.

 *

 *      Functions that have to copy string data will return strings rather than

 *      slices; these can be cast back to slices for further processing if

 *      required.

 *

 *      For convenience, some functions are provided with non-modifying

 *      variants that create a new slice and return both; for instance,

 *      `s.splitNew('.')` leaves s unmodified, and returns two values

 *      corresponding to the left and right parts of the string.

 */



pragma solidity ^0.4.14;



library strings {

    struct slice {

        uint _len;

        uint _ptr;

    }



    function memcpy(uint dest, uint src, uint len) private pure{

        // Copy word-length chunks while possible

        for(; len >= 32; len -= 32) {

            assembly {

                mstore(dest, mload(src))

            }

            dest += 32;

            src += 32;

        }



        // Copy remaining bytes

        uint mask = 256 ** (32 - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }

    }



    /*

     * @dev Returns a slice containing the entire string.

     * @param self The string to make a slice from.

     * @return A newly allocated slice containing the entire string.

     */

    function toSlice(string self) internal pure returns (slice) {

        uint ptr;

        assembly {

            ptr := add(self, 0x20)

        }

        return slice(bytes(self).length, ptr);

    }



    /*

     * @dev Returns the length of a null-terminated bytes32 string.

     * @param self The value to find the length of.

     * @return The length of the string, from 0 to 32.

     */

    function len(bytes32 self) internal pure returns (uint) {

        uint ret;

        if (self == 0)

            return 0;

        if (self & 0xffffffffffffffffffffffffffffffff == 0) {

            ret += 16;

            self = bytes32(uint(self) / 0x100000000000000000000000000000000);

        }

        if (self & 0xffffffffffffffff == 0) {

            ret += 8;

            self = bytes32(uint(self) / 0x10000000000000000);

        }

        if (self & 0xffffffff == 0) {

            ret += 4;

            self = bytes32(uint(self) / 0x100000000);

        }

        if (self & 0xffff == 0) {

            ret += 2;

            self = bytes32(uint(self) / 0x10000);

        }

        if (self & 0xff == 0) {

            ret += 1;

        }

        return 32 - ret;

    }



    /*

     * @dev Returns a slice containing the entire bytes32, interpreted as a

     *      null-termintaed utf-8 string.

     * @param self The bytes32 value to convert to a slice.

     * @return A new slice containing the value of the input argument up to the

     *         first null.

     */

    function toSliceB32(bytes32 self) internal pure returns (slice ret) {

        // Allocate space for `self` in memory, copy it there, and point ret at it

        assembly {

            let ptr := mload(0x40)

            mstore(0x40, add(ptr, 0x20))

            mstore(ptr, self)

            mstore(add(ret, 0x20), ptr)

        }

        ret._len = len(self);

    }



    /*

     * @dev Returns a new slice containing the same data as the current slice.

     * @param self The slice to copy.

     * @return A new slice containing the same data as `self`.

     */

    function copy(slice self) internal pure returns (slice) {

        return slice(self._len, self._ptr);

    }



    /*

     * @dev Copies a slice to a new string.

     * @param self The slice to copy.

     * @return A newly allocated string containing the slice's text.

     */

    function toString(slice self) internal pure returns (string) {

        var ret = new string(self._len);

        uint retptr;

        assembly { retptr := add(ret, 32) }



        memcpy(retptr, self._ptr, self._len);

        return ret;

    }



    /*

     * @dev Returns the length in runes of the slice. Note that this operation

     *      takes time proportional to the length of the slice; avoid using it

     *      in loops, and call `slice.empty()` if you only need to know whether

     *      the slice is empty or not.

     * @param self The slice to operate on.

     * @return The length of the slice in runes.

     */

    function len(slice self) internal pure returns (uint l) {

        // Starting at ptr-31 means the LSB will be the byte we care about

        var ptr = self._ptr - 31;

        var end = ptr + self._len;

        for (l = 0; ptr < end; l++) {

            uint8 b;

            assembly { b := and(mload(ptr), 0xFF) }

            if (b < 0x80) {

                ptr += 1;

            } else if(b < 0xE0) {

                ptr += 2;

            } else if(b < 0xF0) {

                ptr += 3;

            } else if(b < 0xF8) {

                ptr += 4;

            } else if(b < 0xFC) {

                ptr += 5;

            } else {

                ptr += 6;

            }

        }

    }



    /*

     * @dev Returns true if the slice is empty (has a length of 0).

     * @param self The slice to operate on.

     * @return True if the slice is empty, False otherwise.

     */

    function empty(slice self) internal pure returns (bool) {

        return self._len == 0;

    }



    /*

     * @dev Returns a positive number if `other` comes lexicographically after

     *      `self`, a negative number if it comes before, or zero if the

     *      contents of the two slices are equal. Comparison is done per-rune,

     *      on unicode codepoints.

     * @param self The first slice to compare.

     * @param other The second slice to compare.

     * @return The result of the comparison.

     */

    function compare(slice self, slice other) internal pure returns (int) {

        uint shortest = self._len;

        if (other._len < self._len)

            shortest = other._len;



        var selfptr = self._ptr;

        var otherptr = other._ptr;

        for (uint idx = 0; idx < shortest; idx += 32) {

            uint a;

            uint b;

            assembly {

                a := mload(selfptr)

                b := mload(otherptr)

            }

            if (a != b) {

                // Mask out irrelevant bytes and check again

                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);

                var diff = (a & mask) - (b & mask);

                if (diff != 0)

                    return int(diff);

            }

            selfptr += 32;

            otherptr += 32;

        }

        return int(self._len) - int(other._len);

    }



    /*

     * @dev Returns true if the two slices contain the same text.

     * @param self The first slice to compare.

     * @param self The second slice to compare.

     * @return True if the slices are equal, false otherwise.

     */

    function equals(slice self, slice other) internal pure returns (bool) {

        return compare(self, other) == 0;

    }



    /*

     * @dev Extracts the first rune in the slice into `rune`, advancing the

     *      slice to point to the next rune and returning `self`.

     * @param self The slice to operate on.

     * @param rune The slice that will contain the first rune.

     * @return `rune`.

     */

    function nextRune(slice self, slice rune) internal pure returns (slice) {

        rune._ptr = self._ptr;



        if (self._len == 0) {

            rune._len = 0;

            return rune;

        }



        uint len;

        uint b;

        // Load the first byte of the rune into the LSBs of b

        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }

        if (b < 0x80) {

            len = 1;

        } else if(b < 0xE0) {

            len = 2;

        } else if(b < 0xF0) {

            len = 3;

        } else {

            len = 4;

        }



        // Check for truncated codepoints

        if (len > self._len) {

            rune._len = self._len;

            self._ptr += self._len;

            self._len = 0;

            return rune;

        }



        self._ptr += len;

        self._len -= len;

        rune._len = len;

        return rune;

    }



    /*

     * @dev Returns the first rune in the slice, advancing the slice to point

     *      to the next rune.

     * @param self The slice to operate on.

     * @return A slice containing only the first rune from `self`.

     */

    function nextRune(slice self) internal pure returns (slice ret) {

        nextRune(self, ret);

    }



    /*

     * @dev Returns the number of the first codepoint in the slice.

     * @param self The slice to operate on.

     * @return The number of the first codepoint in the slice.

     */

    function ord(slice self) internal pure returns (uint ret) {

        if (self._len == 0) {

            return 0;

        }



        uint word;

        uint length;

        uint divisor = 2 ** 248;



        // Load the rune into the MSBs of b

        assembly { word:= mload(mload(add(self, 32))) }

        var b = word / divisor;

        if (b < 0x80) {

            ret = b;

            length = 1;

        } else if(b < 0xE0) {

            ret = b & 0x1F;

            length = 2;

        } else if(b < 0xF0) {

            ret = b & 0x0F;

            length = 3;

        } else {

            ret = b & 0x07;

            length = 4;

        }



        // Check for truncated codepoints

        if (length > self._len) {

            return 0;

        }



        for (uint i = 1; i < length; i++) {

            divisor = divisor / 256;

            b = (word / divisor) & 0xFF;

            if (b & 0xC0 != 0x80) {

                // Invalid UTF-8 sequence

                return 0;

            }

            ret = (ret * 64) | (b & 0x3F);

        }



        return ret;

    }



    /*

     * @dev Returns the keccak-256 hash of the slice.

     * @param self The slice to hash.

     * @return The hash of the slice.

     */

    function keccak(slice self) internal pure returns (bytes32 ret) {

        assembly {

            ret := keccak256(mload(add(self, 32)), mload(self))

        }

    }



    /*

     * @dev Returns true if `self` starts with `needle`.

     * @param self The slice to operate on.

     * @param needle The slice to search for.

     * @return True if the slice starts with the provided text, false otherwise.

     */

    function startsWith(slice self, slice needle) internal pure returns (bool) {

        if (self._len < needle._len) {

            return false;

        }



        if (self._ptr == needle._ptr) {

            return true;

        }



        bool equal;

        assembly {

            let length := mload(needle)

            let selfptr := mload(add(self, 0x20))

            let needleptr := mload(add(needle, 0x20))

            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))

        }

        return equal;

    }



    /*

     * @dev If `self` starts with `needle`, `needle` is removed from the

     *      beginning of `self`. Otherwise, `self` is unmodified.

     * @param self The slice to operate on.

     * @param needle The slice to search for.

     * @return `self`

     */

    function beyond(slice self, slice needle) internal pure returns (slice) {

        if (self._len < needle._len) {

            return self;

        }



        bool equal = true;

        if (self._ptr != needle._ptr) {

            assembly {

                let length := mload(needle)

                let selfptr := mload(add(self, 0x20))

                let needleptr := mload(add(needle, 0x20))

                equal := eq(sha3(selfptr, length), sha3(needleptr, length))

            }

        }



        if (equal) {

            self._len -= needle._len;

            self._ptr += needle._len;

        }



        return self;

    }



    /*

     * @dev Returns true if the slice ends with `needle`.

     * @param self The slice to operate on.

     * @param needle The slice to search for.

     * @return True if the slice starts with the provided text, false otherwise.

     */

    function endsWith(slice self, slice needle) internal pure returns (bool) {

        if (self._len < needle._len) {

            return false;

        }



        var selfptr = self._ptr + self._len - needle._len;



        if (selfptr == needle._ptr) {

            return true;

        }



        bool equal;

        assembly {

            let length := mload(needle)

            let needleptr := mload(add(needle, 0x20))

            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))

        }



        return equal;

    }



    /*

     * @dev If `self` ends with `needle`, `needle` is removed from the

     *      end of `self`. Otherwise, `self` is unmodified.

     * @param self The slice to operate on.

     * @param needle The slice to search for.

     * @return `self`

     */

    function until(slice self, slice needle) internal pure returns (slice) {

        if (self._len < needle._len) {

            return self;

        }



        var selfptr = self._ptr + self._len - needle._len;

        bool equal = true;

        if (selfptr != needle._ptr) {

            assembly {

                let length := mload(needle)

                let needleptr := mload(add(needle, 0x20))

                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))

            }

        }



        if (equal) {

            self._len -= needle._len;

        }



        return self;

    }



    // Returns the memory address of the first byte of the first occurrence of

    // `needle` in `self`, or the first byte after `self` if not found.

    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {

        uint ptr;

        uint idx;



        if (needlelen <= selflen) {

            if (needlelen <= 32) {

                // Optimized assembly for 68 gas per byte on short strings

                assembly {

                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))

                    let needledata := and(mload(needleptr), mask)

                    let end := add(selfptr, sub(selflen, needlelen))

                    ptr := selfptr

                    loop:

                    jumpi(exit, eq(and(mload(ptr), mask), needledata))

                    ptr := add(ptr, 1)

                    jumpi(loop, lt(sub(ptr, 1), end))

                    ptr := add(selfptr, selflen)

                    exit:

                }

                return ptr;

            } else {

                // For long needles, use hashing

                bytes32 hash;

                assembly { hash := sha3(needleptr, needlelen) }

                ptr = selfptr;

                for (idx = 0; idx <= selflen - needlelen; idx++) {

                    bytes32 testHash;

                    assembly { testHash := sha3(ptr, needlelen) }

                    if (hash == testHash)

                        return ptr;

                    ptr += 1;

                }

            }

        }

        return selfptr + selflen;

    }



    // Returns the memory address of the first byte after the last occurrence of

    // `needle` in `self`, or the address of `self` if not found.

    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {

        uint ptr;



        if (needlelen <= selflen) {

            if (needlelen <= 32) {

                // Optimized assembly for 69 gas per byte on short strings

                assembly {

                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))

                    let needledata := and(mload(needleptr), mask)

                    ptr := add(selfptr, sub(selflen, needlelen))

                    loop:

                    jumpi(ret, eq(and(mload(ptr), mask), needledata))

                    ptr := sub(ptr, 1)

                    jumpi(loop, gt(add(ptr, 1), selfptr))

                    ptr := selfptr

                    jump(exit)

                    ret:

                    ptr := add(ptr, needlelen)

                    exit:

                }

                return ptr;

            } else {

                // For long needles, use hashing

                bytes32 hash;

                assembly { hash := sha3(needleptr, needlelen) }

                ptr = selfptr + (selflen - needlelen);

                while (ptr >= selfptr) {

                    bytes32 testHash;

                    assembly { testHash := sha3(ptr, needlelen) }

                    if (hash == testHash)

                        return ptr + needlelen;

                    ptr -= 1;

                }

            }

        }

        return selfptr;

    }



    /*

     * @dev Modifies `self` to contain everything from the first occurrence of

     *      `needle` to the end of the slice. `self` is set to the empty slice

     *      if `needle` is not found.

     * @param self The slice to search and modify.

     * @param needle The text to search for.

     * @return `self`.

     */

    function find(slice self, slice needle) internal returns (slice) {

        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);

        self._len -= ptr - self._ptr;

        self._ptr = ptr;

        return self;

    }



    /*

     * @dev Modifies `self` to contain the part of the string from the start of

     *      `self` to the end of the first occurrence of `needle`. If `needle`

     *      is not found, `self` is set to the empty slice.

     * @param self The slice to search and modify.

     * @param needle The text to search for.

     * @return `self`.

     */

    function rfind(slice self, slice needle) internal returns (slice) {

        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);

        self._len = ptr - self._ptr;

        return self;

    }



    /*

     * @dev Splits the slice, setting `self` to everything after the first

     *      occurrence of `needle`, and `token` to everything before it. If

     *      `needle` does not occur in `self`, `self` is set to the empty slice,

     *      and `token` is set to the entirety of `self`.

     * @param self The slice to split.

     * @param needle The text to search for in `self`.

     * @param token An output parameter to which the first token is written.

     * @return `token`.

     */

    function split(slice self, slice needle, slice token) internal returns (slice) {

        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);

        token._ptr = self._ptr;

        token._len = ptr - self._ptr;

        if (ptr == self._ptr + self._len) {

            // Not found

            self._len = 0;

        } else {

            self._len -= token._len + needle._len;

            self._ptr = ptr + needle._len;

        }

        return token;

    }



    /*

     * @dev Splits the slice, setting `self` to everything after the first

     *      occurrence of `needle`, and returning everything before it. If

     *      `needle` does not occur in `self`, `self` is set to the empty slice,

     *      and the entirety of `self` is returned.

     * @param self The slice to split.

     * @param needle The text to search for in `self`.

     * @return The part of `self` up to the first occurrence of `delim`.

     */

    function split(slice self, slice needle) internal returns (slice token) {

        split(self, needle, token);

    }



    /*

     * @dev Splits the slice, setting `self` to everything before the last

     *      occurrence of `needle`, and `token` to everything after it. If

     *      `needle` does not occur in `self`, `self` is set to the empty slice,

     *      and `token` is set to the entirety of `self`.

     * @param self The slice to split.

     * @param needle The text to search for in `self`.

     * @param token An output parameter to which the first token is written.

     * @return `token`.

     */

    function rsplit(slice self, slice needle, slice token) internal returns (slice) {

        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);

        token._ptr = ptr;

        token._len = self._len - (ptr - self._ptr);

        if (ptr == self._ptr) {

            // Not found

            self._len = 0;

        } else {

            self._len -= token._len + needle._len;

        }

        return token;

    }



    /*

     * @dev Splits the slice, setting `self` to everything before the last

     *      occurrence of `needle`, and returning everything after it. If

     *      `needle` does not occur in `self`, `self` is set to the empty slice,

     *      and the entirety of `self` is returned.

     * @param self The slice to split.

     * @param needle The text to search for in `self`.

     * @return The part of `self` after the last occurrence of `delim`.

     */

    function rsplit(slice self, slice needle) internal returns (slice token) {

        rsplit(self, needle, token);

    }



    /*

     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.

     * @param self The slice to search.

     * @param needle The text to search for in `self`.

     * @return The number of occurrences of `needle` found in `self`.

     */

    function count(slice self, slice needle) internal returns (uint cnt) {

        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;

        while (ptr <= self._ptr + self._len) {

            cnt++;

            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;

        }

    }



    /*

     * @dev Returns True if `self` contains `needle`.

     * @param self The slice to search.

     * @param needle The text to search for in `self`.

     * @return True if `needle` is found in `self`, false otherwise.

     */

    function contains(slice self, slice needle) internal returns (bool) {

        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;

    }



    /*

     * @dev Returns a newly allocated string containing the concatenation of

     *      `self` and `other`.

     * @param self The first slice to concatenate.

     * @param other The second slice to concatenate.

     * @return The concatenation of the two strings.

     */

    function concat(slice self, slice other) internal pure returns (string) {

        var ret = new string(self._len + other._len);

        uint retptr;

        assembly { retptr := add(ret, 32) }

        memcpy(retptr, self._ptr, self._len);

        memcpy(retptr + self._len, other._ptr, other._len);

        return ret;

    }



    /*

     * @dev Joins an array of slices, using `self` as a delimiter, returning a

     *      newly allocated string.

     * @param self The delimiter to use.

     * @param parts A list of slices to join.

     * @return A newly allocated string containing all the slices in `parts`,

     *         joined with `self`.

     */

    function join(slice self, slice[] parts) internal pure returns (string) {

        if (parts.length == 0)

            return "";



        uint length = self._len * (parts.length - 1);

        for(uint i = 0; i < parts.length; i++)

            length += parts[i]._len;



        var ret = new string(length);

        uint retptr;

        assembly { retptr := add(ret, 32) }



        for(i = 0; i < parts.length; i++) {

            memcpy(retptr, parts[i]._ptr, parts[i]._len);

            retptr += parts[i]._len;

            if (i < parts.length - 1) {

                memcpy(retptr, self._ptr, self._len);

                retptr += self._len;

            }

        }



        return ret;

    }

}



// File: contracts/CloversMetadata.sol



pragma solidity ^0.4.18;



/**

* CloversMetadata contract is upgradeable and returns metadata about Clovers

*/







contract CloversMetadata {

    using strings for *;



    function tokenURI(uint _tokenId) public view returns (string _infoUrl) {

        string memory base = "https://api.clovers.network/clovers/metadata/0x";

        string memory id = uint2hexstr(_tokenId);

        string memory suffix = "";

        return base.toSlice().concat(id.toSlice()).toSlice().concat(suffix.toSlice());

    }

    function uint2hexstr(uint i) internal pure returns (string) {

        if (i == 0) return "0";

        uint j = i;

        uint length;

        while (j != 0) {

            length++;

            j = j >> 4;

        }

        uint mask = 15;

        bytes memory bstr = new bytes(length);

        uint k = length - 1;

        while (i != 0){

            uint curr = (i & mask);

            bstr[k--] = curr > 9 ? byte(55 + curr) : byte(48 + curr); // 55 = 65 - 10

            i = i >> 4;

        }

        return string(bstr);

    }

}



// File: contracts/Clovers.sol



pragma solidity ^0.4.18;



/**

 * Digital Asset Registry for the Non Fungible Token Clover

 * with upgradeable contract reference for returning metadata.

 */















contract Clovers is ERC721Token, Admin, Ownable {



    address public cloversMetadata;

    uint256 public totalSymmetries;

    uint256[5] symmetries; // RotSym, Y0Sym, X0Sym, XYSym, XnYSym

    address public cloversController;

    address public clubTokenController;



    mapping (uint256 => Clover) public clovers;

    struct Clover {

        bool keep;

        uint256 symmetries;

        bytes28[2] cloverMoves;

        uint256 blockMinted;

        uint256 rewards;

    }



    modifier onlyOwnerOrController() {

        require(

            msg.sender == cloversController ||

            owner == msg.sender ||

            admins[msg.sender]

        );

        _;

    }





    /**

    * @dev Checks msg.sender can transfer a token, by being owner, approved, operator or cloversController

    * @param _tokenId uint256 ID of the token to validate

    */

    modifier canTransfer(uint256 _tokenId) {

        require(isApprovedOrOwner(msg.sender, _tokenId) || msg.sender == cloversController);

        _;

    }



    constructor(string name, string symbol) public

        ERC721Token(name, symbol)

    { }



    function () public payable {}



    function implementation() public view returns (address) {

        return cloversMetadata;

    }



    function tokenURI(uint _tokenId) public view returns (string _infoUrl) {

        return CloversMetadata(cloversMetadata).tokenURI(_tokenId);

    }

    function getHash(bytes28[2] moves) public pure returns (bytes32) {

        return keccak256(moves);

    }

    function getKeep(uint256 _tokenId) public view returns (bool) {

        return clovers[_tokenId].keep;

    }

    function getBlockMinted(uint256 _tokenId) public view returns (uint256) {

        return clovers[_tokenId].blockMinted;

    }

    function getCloverMoves(uint256 _tokenId) public view returns (bytes28[2]) {

        return clovers[_tokenId].cloverMoves;

    }

    function getReward(uint256 _tokenId) public view returns (uint256) {

        return clovers[_tokenId].rewards;

    }

    function getSymmetries(uint256 _tokenId) public view returns (uint256) {

        return clovers[_tokenId].symmetries;

    }

    function getAllSymmetries() public view returns (uint256, uint256, uint256, uint256, uint256, uint256) {

        return (

            totalSymmetries,

            symmetries[0], //RotSym,

            symmetries[1], //Y0Sym,

            symmetries[2], //X0Sym,

            symmetries[3], //XYSym,

            symmetries[4] //XnYSym

        );

    }



/* ---------------------------------------------------------------------------------------------------------------------- */



    /**

    * @dev Moves Eth to a certain address for use in the CloversController

    * @param _to The address to receive the Eth.

    * @param _amount The amount of Eth to be transferred.

    */

    function moveEth(address _to, uint256 _amount) public onlyOwnerOrController {

        require(_amount <= this.balance);

        _to.transfer(_amount);

    }

    /**

    * @dev Moves Token to a certain address for use in the CloversController

    * @param _to The address to receive the Token.

    * @param _amount The amount of Token to be transferred.

    * @param _token The address of the Token to be transferred.

    */

    function moveToken(address _to, uint256 _amount, address _token) public onlyOwnerOrController returns (bool) {

        require(_amount <= ERC20(_token).balanceOf(this));

        return ERC20(_token).transfer(_to, _amount);

    }

    /**

    * @dev Approves Tokens to a certain address for use in the CloversController

    * @param _to The address to receive the Token approval.

    * @param _amount The amount of Token to be approved.

    * @param _token The address of the Token to be approved.

    */

    function approveToken(address _to, uint256 _amount, address _token) public onlyOwnerOrController returns (bool) {

        return ERC20(_token).approve(_to, _amount);

    }



    /**

    * @dev Sets whether the minter will keep the clover

    * @param _tokenId The token Id.

    * @param value Whether the clover will be kept.

    */

    function setKeep(uint256 _tokenId, bool value) public onlyOwnerOrController {

        clovers[_tokenId].keep = value;

    }

    function setBlockMinted(uint256 _tokenId, uint256 value) public onlyOwnerOrController {

        clovers[_tokenId].blockMinted = value;

    }

    function setCloverMoves(uint256 _tokenId, bytes28[2] moves) public onlyOwnerOrController {

        clovers[_tokenId].cloverMoves = moves;

    }

    function setReward(uint256 _tokenId, uint256 _amount) public onlyOwnerOrController {

        clovers[_tokenId].rewards = _amount;

    }

    function setSymmetries(uint256 _tokenId, uint256 _symmetries) public onlyOwnerOrController {

        clovers[_tokenId].symmetries = _symmetries;

    }



    /**

    * @dev Sets total tallies of symmetry counts. For use by the controller to correct for invalid Clovers.

    * @param _totalSymmetries The total number of Symmetries.

    * @param RotSym The total number of RotSym Symmetries.

    * @param Y0Sym The total number of Y0Sym Symmetries.

    * @param X0Sym The total number of X0Sym Symmetries.

    * @param XYSym The total number of XYSym Symmetries.

    * @param XnYSym The total number of XnYSym Symmetries.

    */

    function setAllSymmetries(uint256 _totalSymmetries, uint256 RotSym, uint256 Y0Sym, uint256 X0Sym, uint256 XYSym, uint256 XnYSym) public onlyOwnerOrController {

        totalSymmetries = _totalSymmetries;

        symmetries[0] = RotSym;

        symmetries[1] = Y0Sym;

        symmetries[2] = X0Sym;

        symmetries[3] = XYSym;

        symmetries[4] = XnYSym;

    }



    /**

    * @dev Deletes data about a Clover.

    * @param _tokenId The Id of the clover token to be deleted.

    */

    function deleteClover(uint256 _tokenId) public onlyOwnerOrController {

        delete(clovers[_tokenId]);

        unmint(_tokenId);

    }

    /**

    * @dev Updates the CloversController contract address and approves that contract to manage the Clovers owned by the Clovers contract.

    * @param _cloversController The address of the new contract.

    */

    function updateCloversControllerAddress(address _cloversController) public onlyOwner {

        require(_cloversController != 0);

        cloversController = _cloversController;

    }







    /**

    * @dev Updates the CloversMetadata contract address.

    * @param _cloversMetadata The address of the new contract.

    */

    function updateCloversMetadataAddress(address _cloversMetadata) public onlyOwner {

        require(_cloversMetadata != 0);

        cloversMetadata = _cloversMetadata;

    }



    function updateClubTokenController(address _clubTokenController) public onlyOwner {

        require(_clubTokenController != 0);

        clubTokenController = _clubTokenController;

    }



    /**

    * @dev Mints new Clovers.

    * @param _to The address of the new clover owner.

    * @param _tokenId The Id of the new clover token.

    */

    function mint (address _to, uint256 _tokenId) public onlyOwnerOrController {

        super._mint(_to, _tokenId);

        setApprovalForAll(clubTokenController, true);

    }





    function mintMany(address[] _tos, uint256[] _tokenIds, bytes28[2][] memory _movess, uint256[] _symmetries) public onlyAdmin {

        require(_tos.length == _tokenIds.length && _tokenIds.length == _movess.length && _movess.length == _symmetries.length);

        for (uint256 i = 0; i < _tos.length; i++) {

            address _to = _tos[i];

            uint256 _tokenId = _tokenIds[i];

            bytes28[2] memory _moves = _movess[i];

            uint256 _symmetry = _symmetries[i];

            setCloverMoves(_tokenId, _moves);

            if (_symmetry > 0) {

                setSymmetries(_tokenId, _symmetry);

            }

            super._mint(_to, _tokenId);

            setApprovalForAll(clubTokenController, true);

        }

    }



    /**

    * @dev Unmints Clovers.

    * @param _tokenId The Id of the clover token to be destroyed.

    */

    function unmint (uint256 _tokenId) public onlyOwnerOrController {

        super._burn(ownerOf(_tokenId), _tokenId);

    }





}



// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol



pragma solidity ^0.4.24;









/**

 * @title Basic token

 * @dev Basic version of StandardToken, with no allowances.

 */

contract BasicToken is ERC20Basic {

  using SafeMath for uint256;



  mapping(address => uint256) balances;



  uint256 totalSupply_;



  /**

  * @dev Total number of tokens in existence

  */

  function totalSupply() public view returns (uint256) {

    return totalSupply_;

  }



  /**

  * @dev Transfer token for a specified address

  * @param _to The address to transfer to.

  * @param _value The amount to be transferred.

  */

  function transfer(address _to, uint256 _value) public returns (bool) {

    require(_to != address(0));

    require(_value <= balances[msg.sender]);



    balances[msg.sender] = balances[msg.sender].sub(_value);

    balances[_to] = balances[_to].add(_value);

    emit Transfer(msg.sender, _to, _value);

    return true;

  }



  /**

  * @dev Gets the balance of the specified address.

  * @param _owner The address to query the the balance of.

  * @return An uint256 representing the amount owned by the passed address.

  */

  function balanceOf(address _owner) public view returns (uint256) {

    return balances[_owner];

  }



}



// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol



pragma solidity ^0.4.24;









/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * https://github.com/ethereum/EIPs/issues/20

 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 */

contract StandardToken is ERC20, BasicToken {



  mapping (address => mapping (address => uint256)) internal allowed;





  /**

   * @dev Transfer tokens from one address to another

   * @param _from address The address which you want to send tokens from

   * @param _to address The address which you want to transfer to

   * @param _value uint256 the amount of tokens to be transferred

   */

  function transferFrom(

    address _from,

    address _to,

    uint256 _value

  )

    public

    returns (bool)

  {

    require(_to != address(0));

    require(_value <= balances[_from]);

    require(_value <= allowed[_from][msg.sender]);



    balances[_from] = balances[_from].sub(_value);

    balances[_to] = balances[_to].add(_value);

    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

    emit Transfer(_from, _to, _value);

    return true;

  }



  /**

   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

   * Beware that changing an allowance with this method brings the risk that someone may use both the old

   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

   * @param _spender The address which will spend the funds.

   * @param _value The amount of tokens to be spent.

   */

  function approve(address _spender, uint256 _value) public returns (bool) {

    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);

    return true;

  }



  /**

   * @dev Function to check the amount of tokens that an owner allowed to a spender.

   * @param _owner address The address which owns the funds.

   * @param _spender address The address which will spend the funds.

   * @return A uint256 specifying the amount of tokens still available for the spender.

   */

  function allowance(

    address _owner,

    address _spender

   )

    public

    view

    returns (uint256)

  {

    return allowed[_owner][_spender];

  }



  /**

   * @dev Increase the amount of tokens that an owner allowed to a spender.

   * approve should be called when allowed[_spender] == 0. To increment

   * allowed value is better to use this function to avoid 2 calls (and wait until

   * the first transaction is mined)

   * From MonolithDAO Token.sol

   * @param _spender The address which will spend the funds.

   * @param _addedValue The amount of tokens to increase the allowance by.

   */

  function increaseApproval(

    address _spender,

    uint256 _addedValue

  )

    public

    returns (bool)

  {

    allowed[msg.sender][_spender] = (

      allowed[msg.sender][_spender].add(_addedValue));

    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  }



  /**

   * @dev Decrease the amount of tokens that an owner allowed to a spender.

   * approve should be called when allowed[_spender] == 0. To decrement

   * allowed value is better to use this function to avoid 2 calls (and wait until

   * the first transaction is mined)

   * From MonolithDAO Token.sol

   * @param _spender The address which will spend the funds.

   * @param _subtractedValue The amount of tokens to decrease the allowance by.

   */

  function decreaseApproval(

    address _spender,

    uint256 _subtractedValue

  )

    public

    returns (bool)

  {

    uint256 oldValue = allowed[msg.sender][_spender];

    if (_subtractedValue > oldValue) {

      allowed[msg.sender][_spender] = 0;

    } else {

      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

    }

    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

    return true;

  }



}



// File: zeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol



pragma solidity ^0.4.24;







/**

 * @title DetailedERC20 token

 * @dev The decimals are only for visualization purposes.

 * All the operations are done using the smallest and indivisible token unit,

 * just as on Ethereum all the operations are done in wei.

 */

contract DetailedERC20 is ERC20 {

  string public name;

  string public symbol;

  uint8 public decimals;



  constructor(string _name, string _symbol, uint8 _decimals) public {

    name = _name;

    symbol = _symbol;

    decimals = _decimals;

  }

}



// File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol



pragma solidity ^0.4.24;









/**

 * @title Mintable token

 * @dev Simple ERC20 Token example, with mintable token creation

 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol

 */

contract MintableToken is StandardToken, Ownable {

  event Mint(address indexed to, uint256 amount);

  event MintFinished();



  bool public mintingFinished = false;





  modifier canMint() {

    require(!mintingFinished);

    _;

  }



  modifier hasMintPermission() {

    require(msg.sender == owner);

    _;

  }



  /**

   * @dev Function to mint tokens

   * @param _to The address that will receive the minted tokens.

   * @param _amount The amount of tokens to mint.

   * @return A boolean that indicates if the operation was successful.

   */

  function mint(

    address _to,

    uint256 _amount

  )

    hasMintPermission

    canMint

    public

    returns (bool)

  {

    totalSupply_ = totalSupply_.add(_amount);

    balances[_to] = balances[_to].add(_amount);

    emit Mint(_to, _amount);

    emit Transfer(address(0), _to, _amount);

    return true;

  }



  /**

   * @dev Function to stop minting new tokens.

   * @return True if the operation was successful.

   */

  function finishMinting() onlyOwner canMint public returns (bool) {

    mintingFinished = true;

    emit MintFinished();

    return true;

  }

}



// File: zeppelin-solidity/contracts/token/ERC20/BurnableToken.sol



pragma solidity ^0.4.24;







/**

 * @title Burnable Token

 * @dev Token that can be irreversibly burned (destroyed).

 */

contract BurnableToken is BasicToken {



  event Burn(address indexed burner, uint256 value);



  /**

   * @dev Burns a specific amount of tokens.

   * @param _value The amount of token to be burned.

   */

  function burn(uint256 _value) public {

    _burn(msg.sender, _value);

  }



  function _burn(address _who, uint256 _value) internal {

    require(_value <= balances[_who]);

    // no need to require value <= totalSupply, since that would imply the

    // sender's balance is greater than the totalSupply, which *should* be an assertion failure



    balances[_who] = balances[_who].sub(_value);

    totalSupply_ = totalSupply_.sub(_value);

    emit Burn(_who, _value);

    emit Transfer(_who, address(0), _value);

  }

}



// File: contracts/ClubToken.sol



pragma solidity ^0.4.18;



/**

 * ClubToken adheres to ERC20

 * it is a continuously mintable token administered by CloversController/ClubTokenController

 */











contract ClubToken is StandardToken, DetailedERC20, MintableToken, BurnableToken {



    address public cloversController;

    address public clubTokenController;



    modifier hasMintPermission() {

      require(

          msg.sender == clubTokenController ||

          msg.sender == cloversController ||

          msg.sender == owner

      );

      _;

    }



    /**

    * @dev constructor for the ClubTokens contract

    * @param _name The name of the token

    * @param _symbol The symbol of the token

    * @param _decimals The decimals of the token

    */

    constructor(string _name, string _symbol, uint8 _decimals) public

        DetailedERC20(_name, _symbol, _decimals)

    {}



    function () public payable {}



    function updateClubTokenControllerAddress(address _clubTokenController) public onlyOwner {

        require(_clubTokenController != 0);

        clubTokenController = _clubTokenController;

    }



    function updateCloversControllerAddress(address _cloversController) public onlyOwner {

        require(_cloversController != 0);

        cloversController = _cloversController;

    }





      /**

       * @dev Transfer tokens from one address to another

       * @param _from address The address which you want to send tokens from

       * @param _to address The address which you want to transfer to

       * @param _value uint256 the amount of tokens to be transferred

       */

      function transferFrom(

        address _from,

        address _to,

        uint256 _value

      )

        public

        returns (bool)

      {

        require(_to != address(0));

        require(_value <= balances[_from]);

        if (msg.sender != cloversController && msg.sender != clubTokenController) {

            require(_value <= allowed[_from][msg.sender]);

            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        }

        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;

      }



    /**

     * @dev Burns a specific amount of tokens.

     * @param _value The amount of token to be burned.

     * NOTE: Disabled as tokens should not be burned under circumstances beside selling tokens.

     */

    function burn(uint256 _value) public {

        _value;

        revert();

    }



    /**

     * @dev Burns a specific amount of tokens.

     * @param _burner The address of the token holder burning their tokens.

     * @param _value The amount of token to be burned.

     */

    function burn(address _burner, uint256 _value) public hasMintPermission {

      _burn(_burner, _value);

    }



    /**

    * @dev Moves Eth to a certain address for use in the ClubTokenController

    * @param _to The address to receive the Eth.

    * @param _amount The amount of Eth to be transferred.

    */

    function moveEth(address _to, uint256 _amount) public hasMintPermission {

        require(this.balance >= _amount);

        _to.transfer(_amount);

    }

    /**

    * @dev Moves Tokens to a certain address for use in the ClubTokenController

    * @param _to The address to receive the Tokens.

    * @param _amount The amount of Tokens to be transferred.

    * @param _token The address of the relevant token contract.

    * @return bool Whether or not the move was successful

    */

    function moveToken(address _to, uint256 _amount, address _token) public hasMintPermission returns (bool) {

        require(_amount <= StandardToken(_token).balanceOf(this));

        return StandardToken(_token).transfer(_to, _amount);

    }

    /**

    * @dev Approves Tokens to a certain address for use in the ClubTokenController

    * @param _to The address to be approved.

    * @param _amount The amount of Tokens to be approved.

    * @param _token The address of the relevant token contract.

    * @return bool Whether or not the approval was successful

    */

    function approveToken(address _to, uint256 _amount, address _token) public hasMintPermission returns (bool) {

        return StandardToken(_token).approve(_to, _amount);

    }

}



// File: bancor-contracts/solidity/contracts/converter/interfaces/IBancorFormula.sol



pragma solidity ^0.4.24;



/*

    Bancor Formula interface

*/

contract IBancorFormula {

    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256);

    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256);

    function calculateCrossConnectorReturn(uint256 _fromConnectorBalance, uint32 _fromConnectorWeight, uint256 _toConnectorBalance, uint32 _toConnectorWeight, uint256 _amount) public view returns (uint256);

}



// File: bancor-contracts/solidity/contracts/utility/Utils.sol



pragma solidity ^0.4.24;



/*

    Utilities & Common Modifiers

*/

contract Utils {

    /**

        constructor

    */

    constructor() public {

    }



    // verifies that an amount is greater than zero

    modifier greaterThanZero(uint256 _amount) {

        require(_amount > 0);

        _;

    }



    // validates an address - currently only checks that it isn't null

    modifier validAddress(address _address) {

        require(_address != address(0));

        _;

    }



    // verifies that the address is different than this contract address

    modifier notThis(address _address) {

        require(_address != address(this));

        _;

    }



    // Overflow protected math functions



    /**

        @dev returns the sum of _x and _y, asserts if the calculation overflows



        @param _x   value 1

        @param _y   value 2



        @return sum

    */

    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {

        uint256 z = _x + _y;

        assert(z >= _x);

        return z;

    }



    /**

        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number



        @param _x   minuend

        @param _y   subtrahend



        @return difference

    */

    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {

        assert(_x >= _y);

        return _x - _y;

    }



    /**

        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows



        @param _x   factor 1

        @param _y   factor 2



        @return product

    */

    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {

        uint256 z = _x * _y;

        assert(_x == 0 || z / _x == _y);

        return z;

    }

}



// File: bancor-contracts/solidity/contracts/converter/BancorFormula.sol



pragma solidity ^0.4.24;







contract BancorFormula is IBancorFormula, Utils {

    string public version = '0.3';



    uint256 private constant ONE = 1;

    uint32 private constant MAX_WEIGHT = 1000000;

    uint8 private constant MIN_PRECISION = 32;

    uint8 private constant MAX_PRECISION = 127;



    /**

        Auto-generated via 'PrintIntScalingFactors.py'

    */

    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;

    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;

    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;



    /**

        Auto-generated via 'PrintLn2ScalingFactors.py'

    */

    uint256 private constant LN2_NUMERATOR   = 0x3f80fe03f80fe03f80fe03f80fe03f8;

    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;



    /**

        Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'

    */

    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;

    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;



    /**

        Auto-generated via 'PrintFunctionConstructor.py'

    */

    uint256[128] private maxExpArray;

    constructor() public {

    //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;

    //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;

    //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;

    //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;

    //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;

    //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;

    //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;

    //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;

    //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;

    //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;

    //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;

    //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;

    //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;

    //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;

    //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;

    //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;

    //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;

    //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;

    //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;

    //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;

    //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;

    //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;

    //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;

    //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;

    //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;

    //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;

    //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;

    //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;

    //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;

    //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;

    //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;

    //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;

        maxExpArray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;

        maxExpArray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;

        maxExpArray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;

        maxExpArray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;

        maxExpArray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;

        maxExpArray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;

        maxExpArray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;

        maxExpArray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;

        maxExpArray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;

        maxExpArray[ 41] = 0x13545598e5c23fffffffffffffffffffff;

        maxExpArray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;

        maxExpArray[ 43] = 0x11c592761c666fffffffffffffffffffff;

        maxExpArray[ 44] = 0x110a688680a757ffffffffffffffffffff;

        maxExpArray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;

        maxExpArray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;

        maxExpArray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;

        maxExpArray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;

        maxExpArray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;

        maxExpArray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;

        maxExpArray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;

        maxExpArray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;

        maxExpArray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;

        maxExpArray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;

        maxExpArray[ 55] = 0x0abc25204e02828dffffffffffffffffff;

        maxExpArray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;

        maxExpArray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;

        maxExpArray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;

        maxExpArray[ 59] = 0x09131271922eaa606fffffffffffffffff;

        maxExpArray[ 60] = 0x08b380f3558668c46fffffffffffffffff;

        maxExpArray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;

        maxExpArray[ 62] = 0x07ffffffffffffffffffffffffffffffff;

        maxExpArray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;

        maxExpArray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;

        maxExpArray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;

        maxExpArray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;

        maxExpArray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;

        maxExpArray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;

        maxExpArray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;

        maxExpArray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;

        maxExpArray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;

        maxExpArray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;

        maxExpArray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;

        maxExpArray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;

        maxExpArray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;

        maxExpArray[ 76] = 0x0471649d87199aa990756fffffffffffff;

        maxExpArray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;

        maxExpArray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;

        maxExpArray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;

        maxExpArray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;

        maxExpArray[ 81] = 0x0399e96897690418f785257fffffffffff;

        maxExpArray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;

        maxExpArray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;

        maxExpArray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;

        maxExpArray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;

        maxExpArray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;

        maxExpArray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;

        maxExpArray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;

        maxExpArray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;

        maxExpArray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;

        maxExpArray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;

        maxExpArray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;

        maxExpArray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;

        maxExpArray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;

        maxExpArray[ 95] = 0x01ffffffffffffffffffffffffffffffff;

        maxExpArray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;

        maxExpArray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;

        maxExpArray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;

        maxExpArray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;

        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;

        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;

        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;

        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;

        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;

        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;

        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;

        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;

        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;

        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;

        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;

        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;

        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;

        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;

        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;

        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;

        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;

        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;

        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;

        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;

        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;

        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;

        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;

        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;

        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;

        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;

        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;

        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;

    }



    /**

        @dev given a token supply, connector balance, weight and a deposit amount (in the connector token),

        calculates the return for a given conversion (in the main token)



        Formula:

        Return = _supply * ((1 + _depositAmount / _connectorBalance) ^ (_connectorWeight / 1000000) - 1)



        @param _supply              token total supply

        @param _connectorBalance    total connector balance

        @param _connectorWeight     connector weight, represented in ppm, 1-1000000

        @param _depositAmount       deposit amount, in connector token



        @return purchase return amount

    */

    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256) {

        // validate input

        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT);



        // special case for 0 deposit amount

        if (_depositAmount == 0)

            return 0;



        // special case if the weight = 100%

        if (_connectorWeight == MAX_WEIGHT)

            return safeMul(_supply, _depositAmount) / _connectorBalance;



        uint256 result;

        uint8 precision;

        uint256 baseN = safeAdd(_depositAmount, _connectorBalance);

        (result, precision) = power(baseN, _connectorBalance, _connectorWeight, MAX_WEIGHT);

        uint256 temp = safeMul(_supply, result) >> precision;

        return temp - _supply;

    }



    /**

        @dev given a token supply, connector balance, weight and a sell amount (in the main token),

        calculates the return for a given conversion (in the connector token)



        Formula:

        Return = _connectorBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_connectorWeight / 1000000)))



        @param _supply              token total supply

        @param _connectorBalance    total connector

        @param _connectorWeight     constant connector Weight, represented in ppm, 1-1000000

        @param _sellAmount          sell amount, in the token itself



        @return sale return amount

    */

    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256) {

        // validate input

        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT && _sellAmount <= _supply);



        // special case for 0 sell amount

        if (_sellAmount == 0)

            return 0;



        // special case for selling the entire supply

        if (_sellAmount == _supply)

            return _connectorBalance;



        // special case if the weight = 100%

        if (_connectorWeight == MAX_WEIGHT)

            return safeMul(_connectorBalance, _sellAmount) / _supply;



        uint256 result;

        uint8 precision;

        uint256 baseD = _supply - _sellAmount;

        (result, precision) = power(_supply, baseD, MAX_WEIGHT, _connectorWeight);

        uint256 temp1 = safeMul(_connectorBalance, result);

        uint256 temp2 = _connectorBalance << precision;

        return (temp1 - temp2) / result;

    }



    /**

        @dev given two connector balances/weights and a sell amount (in the first connector token),

        calculates the return for a conversion from the first connector token to the second connector token (in the second connector token)



        Formula:

        Return = _toConnectorBalance * (1 - (_fromConnectorBalance / (_fromConnectorBalance + _amount)) ^ (_fromConnectorWeight / _toConnectorWeight))



        @param _fromConnectorBalance    input connector balance

        @param _fromConnectorWeight     input connector weight, represented in ppm, 1-1000000

        @param _toConnectorBalance      output connector balance

        @param _toConnectorWeight       output connector weight, represented in ppm, 1-1000000

        @param _amount                  input connector amount



        @return second connector amount

    */

    function calculateCrossConnectorReturn(uint256 _fromConnectorBalance, uint32 _fromConnectorWeight, uint256 _toConnectorBalance, uint32 _toConnectorWeight, uint256 _amount) public view returns (uint256) {

        // validate input

        require(_fromConnectorBalance > 0 && _fromConnectorWeight > 0 && _fromConnectorWeight <= MAX_WEIGHT && _toConnectorBalance > 0 && _toConnectorWeight > 0 && _toConnectorWeight <= MAX_WEIGHT);



        // special case for equal weights

        if (_fromConnectorWeight == _toConnectorWeight)

            return safeMul(_toConnectorBalance, _amount) / safeAdd(_fromConnectorBalance, _amount);



        uint256 result;

        uint8 precision;

        uint256 baseN = safeAdd(_fromConnectorBalance, _amount);

        (result, precision) = power(baseN, _fromConnectorBalance, _fromConnectorWeight, _toConnectorWeight);

        uint256 temp1 = safeMul(_toConnectorBalance, result);

        uint256 temp2 = _toConnectorBalance << precision;

        return (temp1 - temp2) / result;

    }



    /**

        General Description:

            Determine a value of precision.

            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.

            Return the result along with the precision used.



        Detailed Description:

            Instead of calculating "base ^ exp", we calculate "e ^ (log(base) * exp)".

            The value of "log(base)" is represented with an integer slightly smaller than "log(base) * 2 ^ precision".

            The larger "precision" is, the more accurately this value represents the real value.

            However, the larger "precision" is, the more bits are required in order to store this value.

            And the exponentiation function, which takes "x" and calculates "e ^ x", is limited to a maximum exponent (maximum value of "x").

            This maximum exponent depends on the "precision" used, and it is given by "maxExpArray[precision] >> (MAX_PRECISION - precision)".

            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.

            This allows us to compute "base ^ exp" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.

            This functions assumes that "_expN < 2 ^ 256 / log(MAX_NUM - 1)", otherwise the multiplication should be replaced with a "safeMul".

    */

    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal view returns (uint256, uint8) {

        require(_baseN < MAX_NUM);



        uint256 baseLog;

        uint256 base = _baseN * FIXED_1 / _baseD;

        if (base < OPT_LOG_MAX_VAL) {

            baseLog = optimalLog(base);

        }

        else {

            baseLog = generalLog(base);

        }



        uint256 baseLogTimesExp = baseLog * _expN / _expD;

        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {

            return (optimalExp(baseLogTimesExp), MAX_PRECISION);

        }

        else {

            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);

            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);

        }

    }



    /**

        Compute log(x / FIXED_1) * FIXED_1.

        This functions assumes that "x >= FIXED_1", because the output would be negative otherwise.

    */

    function generalLog(uint256 x) internal pure returns (uint256) {

        uint256 res = 0;



        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.

        if (x >= FIXED_2) {

            uint8 count = floorLog2(x / FIXED_1);

            x >>= count; // now x < 2

            res = count * FIXED_1;

        }



        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.

        if (x > FIXED_1) {

            for (uint8 i = MAX_PRECISION; i > 0; --i) {

                x = (x * x) / FIXED_1; // now 1 < x < 4

                if (x >= FIXED_2) {

                    x >>= 1; // now 1 < x < 2

                    res += ONE << (i - 1);

                }

            }

        }



        return res * LN2_NUMERATOR / LN2_DENOMINATOR;

    }



    /**

        Compute the largest integer smaller than or equal to the binary logarithm of the input.

    */

    function floorLog2(uint256 _n) internal pure returns (uint8) {

        uint8 res = 0;



        if (_n < 256) {

            // At most 8 iterations

            while (_n > 1) {

                _n >>= 1;

                res += 1;

            }

        }

        else {

            // Exactly 8 iterations

            for (uint8 s = 128; s > 0; s >>= 1) {

                if (_n >= (ONE << s)) {

                    _n >>= s;

                    res |= s;

                }

            }

        }



        return res;

    }



    /**

        The global "maxExpArray" is sorted in descending order, and therefore the following statements are equivalent:

        - This function finds the position of [the smallest value in "maxExpArray" larger than or equal to "x"]

        - This function finds the highest position of [a value in "maxExpArray" larger than or equal to "x"]

    */

    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {

        uint8 lo = MIN_PRECISION;

        uint8 hi = MAX_PRECISION;



        while (lo + 1 < hi) {

            uint8 mid = (lo + hi) / 2;

            if (maxExpArray[mid] >= _x)

                lo = mid;

            else

                hi = mid;

        }



        if (maxExpArray[hi] >= _x)

            return hi;

        if (maxExpArray[lo] >= _x)

            return lo;



        require(false);

        return 0;

    }



    /**

        This function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.

        It approximates "e ^ x" via maclaurin summation: "(x^0)/0! + (x^1)/1! + ... + (x^n)/n!".

        It returns "e ^ (x / 2 ^ precision) * 2 ^ precision", that is, the result is upshifted for accuracy.

        The global "maxExpArray" maps each "precision" to "((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1".

        The maximum permitted value for "x" is therefore given by "maxExpArray[precision] >> (MAX_PRECISION - precision)".

    */

    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {

        uint256 xi = _x;

        uint256 res = 0;



        xi = (xi * _x) >> _precision; res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)

        xi = (xi * _x) >> _precision; res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)

        xi = (xi * _x) >> _precision; res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)

        xi = (xi * _x) >> _precision; res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)

        xi = (xi * _x) >> _precision; res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)

        xi = (xi * _x) >> _precision; res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)

        xi = (xi * _x) >> _precision; res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)

        xi = (xi * _x) >> _precision; res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)

        xi = (xi * _x) >> _precision; res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)

        xi = (xi * _x) >> _precision; res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)

        xi = (xi * _x) >> _precision; res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)

        xi = (xi * _x) >> _precision; res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)

        xi = (xi * _x) >> _precision; res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)

        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)

        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)

        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)

        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)

        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)

        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)

        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)

        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)

        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)



        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!

    }



    /**

        Return log(x / FIXED_1) * FIXED_1

        Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1

        Auto-generated via 'PrintFunctionOptimalLog.py'

        Detailed description:

        - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2

        - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent

        - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1

        - The natural logarithm of the input is calculated by summing up the intermediate results above

        - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)

    */

    function optimalLog(uint256 x) internal pure returns (uint256) {

        uint256 res = 0;



        uint256 y;

        uint256 z;

        uint256 w;



        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {res += 0x40000000000000000000000000000000; x = x * FIXED_1 / 0xd3094c70f034de4b96ff7d5b6f99fcd8;} // add 1 / 2^1

        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {res += 0x20000000000000000000000000000000; x = x * FIXED_1 / 0xa45af1e1f40c333b3de1db4dd55f29a7;} // add 1 / 2^2

        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {res += 0x10000000000000000000000000000000; x = x * FIXED_1 / 0x910b022db7ae67ce76b441c27035c6a1;} // add 1 / 2^3

        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {res += 0x08000000000000000000000000000000; x = x * FIXED_1 / 0x88415abbe9a76bead8d00cf112e4d4a8;} // add 1 / 2^4

        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {res += 0x04000000000000000000000000000000; x = x * FIXED_1 / 0x84102b00893f64c705e841d5d4064bd3;} // add 1 / 2^5

        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {res += 0x02000000000000000000000000000000; x = x * FIXED_1 / 0x8204055aaef1c8bd5c3259f4822735a2;} // add 1 / 2^6

        if (x >= 0x810100ab00222d861931c15e39b44e99) {res += 0x01000000000000000000000000000000; x = x * FIXED_1 / 0x810100ab00222d861931c15e39b44e99;} // add 1 / 2^7

        if (x >= 0x808040155aabbbe9451521693554f733) {res += 0x00800000000000000000000000000000; x = x * FIXED_1 / 0x808040155aabbbe9451521693554f733;} // add 1 / 2^8



        z = y = x - FIXED_1;

        w = y * y / FIXED_1;

        res += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02

        res += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04

        res += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06

        res += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08

        res += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10

        res += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12

        res += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14

        res += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16



        return res;

    }



    /**

        Return e ^ (x / FIXED_1) * FIXED_1

        Input range: 0 <= x <= OPT_EXP_MAX_VAL - 1

        Auto-generated via 'PrintFunctionOptimalExp.py'

        Detailed description:

        - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible

        - The exponentiation of each binary exponent is given (pre-calculated)

        - The exponentiation of r is calculated via Taylor series for e^x, where x = r

        - The exponentiation of the input is calculated by multiplying the intermediate results above

        - For example: e^5.021692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859

    */

    function optimalExp(uint256 x) internal pure returns (uint256) {

        uint256 res = 0;



        uint256 y;

        uint256 z;



        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)

        z = z * y / FIXED_1; res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)

        z = z * y / FIXED_1; res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)

        z = z * y / FIXED_1; res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)

        z = z * y / FIXED_1; res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)

        z = z * y / FIXED_1; res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)

        z = z * y / FIXED_1; res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)

        z = z * y / FIXED_1; res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)

        z = z * y / FIXED_1; res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)

        z = z * y / FIXED_1; res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)

        z = z * y / FIXED_1; res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)

        z = z * y / FIXED_1; res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)

        z = z * y / FIXED_1; res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)

        z = z * y / FIXED_1; res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)

        z = z * y / FIXED_1; res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)

        z = z * y / FIXED_1; res += z * 0x000000000001c638; // add y^16 * (20! / 16!)

        z = z * y / FIXED_1; res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)

        z = z * y / FIXED_1; res += z * 0x000000000000017c; // add y^18 * (20! / 18!)

        z = z * y / FIXED_1; res += z * 0x0000000000000014; // add y^19 * (20! / 19!)

        z = z * y / FIXED_1; res += z * 0x0000000000000001; // add y^20 * (20! / 20!)

        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!



        if ((x & 0x010000000000000000000000000000000) != 0) res = res * 0x1c3d6a24ed82218787d624d3e5eba95f9 / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)

        if ((x & 0x020000000000000000000000000000000) != 0) res = res * 0x18ebef9eac820ae8682b9793ac6d1e778 / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)

        if ((x & 0x040000000000000000000000000000000) != 0) res = res * 0x1368b2fc6f9609fe7aceb46aa619baed5 / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)

        if ((x & 0x080000000000000000000000000000000) != 0) res = res * 0x0bc5ab1b16779be3575bd8f0520a9f21e / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)

        if ((x & 0x100000000000000000000000000000000) != 0) res = res * 0x0454aaa8efe072e7f6ddbab84b40a55c5 / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)

        if ((x & 0x200000000000000000000000000000000) != 0) res = res * 0x00960aadc109e7a3bf4578099615711d7 / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)

        if ((x & 0x400000000000000000000000000000000) != 0) res = res * 0x0002bf84208204f5977f9a8cf01fdc307 / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)



        return res;

    }

}



// File: contracts/ClubTokenController.sol



pragma solidity ^0.4.18;



/**

* The ClubTokenController is a replaceable endpoint for minting and unminting ClubToken.sol

*/











contract ClubTokenController is BancorFormula, Admin, Ownable {

    event Buy(address buyer, uint256 tokens, uint256 value, uint256 poolBalance, uint256 tokenSupply);

    event Sell(address seller, uint256 tokens, uint256 value, uint256 poolBalance, uint256 tokenSupply);



    bool public paused;

    address public clubToken;

    address public simpleCloversMarket;

    address public curationMarket;

    address public support;



    /* uint256 public poolBalance; */

    uint256 public virtualSupply;

    uint256 public virtualBalance;

    uint32 public reserveRatio; // represented in ppm, 1-1000000



    constructor(address _clubToken) public {

        clubToken = _clubToken;

        paused = true;

    }



    function () public payable {

        buy(msg.sender);

    }



    modifier notPaused() {

        require(!paused || owner == msg.sender || admins[tx.origin], "Contract must not be paused");

        _;

    }



    function poolBalance() public constant returns(uint256) {

        return clubToken.balance;

    }



    /**

    * @dev gets the amount of tokens returned from spending Eth

    * @param buyValue The amount of Eth to be spent

    * @return A uint256 representing the amount of tokens gained in exchange for the Eth.

    */

    function getBuy(uint256 buyValue) public constant returns(uint256) {

        return calculatePurchaseReturn(

            safeAdd(ClubToken(clubToken).totalSupply(), virtualSupply),

            safeAdd(poolBalance(), virtualBalance),

            reserveRatio,

            buyValue);

    }





    /**

    * @dev gets the amount of Eth returned from selling tokens

    * @param sellAmount The amount of tokens to be sold

    * @return A uint256 representing the amount of Eth gained in exchange for the tokens.

    */



    function getSell(uint256 sellAmount) public constant returns(uint256) {

        return calculateSaleReturn(

            safeAdd(ClubToken(clubToken).totalSupply(), virtualSupply),

            safeAdd(poolBalance(), virtualBalance),

            reserveRatio,

            sellAmount);

    }



    function updatePaused(bool _paused) public onlyOwner {

        paused = _paused;

    }



    /**

    * @dev updates the Reserve Ratio variable

    * @param _reserveRatio The reserve ratio that determines the curve

    * @return A boolean representing whether or not the update was successful.

    */

    function updateReserveRatio(uint32 _reserveRatio) public onlyOwner returns(bool){

        reserveRatio = _reserveRatio;

        return true;

    }



    /**

    * @dev updates the Virtual Supply variable

    * @param _virtualSupply The virtual supply of tokens used for calculating buys and sells

    * @return A boolean representing whether or not the update was successful.

    */

    function updateVirtualSupply(uint256 _virtualSupply) public onlyOwner returns(bool){

        virtualSupply = _virtualSupply;

        return true;

    }



    /**

    * @dev updates the Virtual Balance variable

    * @param _virtualBalance The virtual balance of the contract used for calculating buys and sells

    * @return A boolean representing whether or not the update was successful.

    */

    function updateVirtualBalance(uint256 _virtualBalance) public onlyOwner returns(bool){

        virtualBalance = _virtualBalance;

        return true;

    }

    /**

    * @dev updates the poolBalance

    * @param _poolBalance The eth balance of ClubToken.sol

    * @return A boolean representing whether or not the update was successful.

    */

    /* function updatePoolBalance(uint256 _poolBalance) public onlyOwner returns(bool){

        poolBalance = _poolBalance;

        return true;

    } */



    /**

    * @dev updates the SimpleCloversMarket address

    * @param _simpleCloversMarket The address of the simpleCloversMarket

    * @return A boolean representing whether or not the update was successful.

    */

    function updateSimpleCloversMarket(address _simpleCloversMarket) public onlyOwner returns(bool){

        simpleCloversMarket = _simpleCloversMarket;

        return true;

    }



    /**

    * @dev updates the CurationMarket address

    * @param _curationMarket The address of the curationMarket

    * @return A boolean representing whether or not the update was successful.

    */

    function updateCurationMarket(address _curationMarket) public onlyOwner returns(bool){

        curationMarket = _curationMarket;

        return true;

    }



    /**

    * @dev updates the Support address

    * @param _support The address of the Support

    * @return A boolean representing whether or not the update was successful.

    */

    function updateSupport(address _support) public onlyOwner returns(bool){

        support = _support;

        return true;

    }



    /**

    * @dev donate Donate Eth to the poolBalance without increasing the totalSupply

    */

    function donate() public payable {

        require(msg.value > 0);

        /* poolBalance = safeAdd(poolBalance, msg.value); */

        clubToken.transfer(msg.value);

    }



    function burn(address from, uint256 amount) public {

        require(msg.sender == simpleCloversMarket);

        ClubToken(clubToken).burn(from, amount);

    }



    function transferFrom(address from, address to, uint256 amount) public {

        require(msg.sender == simpleCloversMarket || msg.sender == curationMarket || msg.sender == support);

        ClubToken(clubToken).transferFrom(from, to, amount);

    }



    /**

    * @dev buy Buy ClubTokens with Eth

    * @param buyer The address that should receive the new tokens

    */

    function buy(address buyer) public payable notPaused returns(bool) {

        require(msg.value > 0);

        uint256 tokens = getBuy(msg.value);

        require(tokens > 0);

        require(ClubToken(clubToken).mint(buyer, tokens));

        /* poolBalance = safeAdd(poolBalance, msg.value); */

        clubToken.transfer(msg.value);

        emit Buy(buyer, tokens, msg.value, poolBalance(), ClubToken(clubToken).totalSupply());

    }





    /**

    * @dev sell Sell ClubTokens for Eth

    * @param sellAmount The amount of tokens to sell

    */

    function sell(uint256 sellAmount) public notPaused returns(bool) {

        require(sellAmount > 0);

        require(ClubToken(clubToken).balanceOf(msg.sender) >= sellAmount);

        uint256 saleReturn = getSell(sellAmount);

        require(saleReturn > 0);

        require(saleReturn <= poolBalance());

        require(saleReturn <= clubToken.balance);

        ClubToken(clubToken).burn(msg.sender, sellAmount);

        /* poolBalance = safeSub(poolBalance, saleReturn); */

        ClubToken(clubToken).moveEth(msg.sender, saleReturn);

        emit Sell(msg.sender, sellAmount, saleReturn, poolBalance(), ClubToken(clubToken).totalSupply());

    }





 }



// File: zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol



pragma solidity ^0.4.24;









/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure.

 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */

library SafeERC20 {

  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {

    require(token.transfer(to, value));

  }



  function safeTransferFrom(

    ERC20 token,

    address from,

    address to,

    uint256 value

  )

    internal

  {

    require(token.transferFrom(from, to, value));

  }



  function safeApprove(ERC20 token, address spender, uint256 value) internal {

    require(token.approve(spender, value));

  }

}



// File: zeppelin-solidity/contracts/ownership/CanReclaimToken.sol



pragma solidity ^0.4.24;











/**

 * @title Contracts that should be able to recover tokens

 * @author SylTi

 * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.

 * This will prevent any accidental loss of tokens.

 */

contract CanReclaimToken is Ownable {

  using SafeERC20 for ERC20Basic;



  /**

   * @dev Reclaim all ERC20Basic compatible tokens

   * @param token ERC20Basic The address of the token contract

   */

  function reclaimToken(ERC20Basic token) external onlyOwner {

    uint256 balance = token.balanceOf(this);

    token.safeTransfer(owner, balance);

  }



}



// File: zeppelin-solidity/contracts/ownership/HasNoTokens.sol



pragma solidity ^0.4.24;







/**

 * @title Contracts that should not own Tokens

 * @author Remco Bloemen <[email protected]π.com>

 * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.

 * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the

 * owner to reclaim the tokens.

 */

contract HasNoTokens is CanReclaimToken {



 /**

  * @dev Reject all ERC223 compatible tokens

  * @param from_ address The address that is transferring the tokens

  * @param value_ uint256 the amount of the specified token

  * @param data_ Bytes The data passed from the caller.

  */

  function tokenFallback(address from_, uint256 value_, bytes data_) external {

    from_;

    value_;

    data_;

    revert();

  }



}



// File: zeppelin-solidity/contracts/ownership/HasNoEther.sol



pragma solidity ^0.4.24;







/**

 * @title Contracts that should not own Ether

 * @author Remco Bloemen <[email protected]π.com>

 * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up

 * in the contract, it will allow the owner to reclaim this ether.

 * @notice Ether can still be sent to this contract by:

 * calling functions labeled `payable`

 * `selfdestruct(contract_address)`

 * mining directly to the contract address

 */

contract HasNoEther is Ownable {



  /**

  * @dev Constructor that rejects incoming Ether

  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we

  * leave out payable, then Solidity will allow inheriting contracts to implement a payable

  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively

  * we could use assembly to access msg.value.

  */

  constructor() public payable {

    require(msg.value == 0);

  }



  /**

   * @dev Disallows direct send by settings a default function without the `payable` flag.

   */

  function() external {

  }



  /**

   * @dev Transfer all Ether held by the contract to the owner.

   */

  function reclaimEther() external onlyOwner {

    owner.transfer(address(this).balance);

  }

}



// File: contracts/CloversController.sol



pragma solidity ^0.4.18;



/**

 * The CloversController is a replaceable endpoint for minting and unminting Clovers.sol and ClubToken.sol

 */



















contract ISimpleCloversMarket {

    function sell(uint256 _tokenId, uint256 price) public;

} 



contract CloversController is HasNoEther, HasNoTokens {

    event cloverCommitted(bytes32 movesHash, address owner);

    event cloverClaimed(bytes28[2] moves, uint256 tokenId, address owner, uint stake, uint reward, uint256 symmetries, bool keep);

    event stakeRetrieved(uint256 tokenId, address owner, uint stake);

    event cloverChallenged(bytes28[2] moves, uint256 tokenId, address owner, address challenger, uint stake);



    using SafeMath for uint256;

    bool public paused;

    address public oracle;

    address public clovers;

    address public clubToken;

    address public clubTokenController;

    address public simpleCloversMarket;

    address public curationMarket;



    uint256 public gasLastUpdated_fastGasPrice_averageGasPrice_safeLowGasPrice;

    uint256 public gasBlockMargin = 240; // ~1 hour at 15 second blocks



    uint256 public basePrice;

    uint256 public priceMultiplier;

    uint256 public payMultiplier;

    uint256 public stakeAmount;

    uint256 public stakePeriod;

    uint256 public constant oneGwei = 1000000000;

    uint256 public marginOfError = 3;

    struct Commit {

        bool collected;

        uint256 stake;

        address committer;

    }



    mapping (bytes32 => Commit) public commits;



    modifier notPaused() {

        require(!paused, "Must not be paused");

        _;

    }



    modifier onlyOwnerOrOracle () {

        require(msg.sender == owner || msg.sender == oracle);

        _;

    }



    constructor(address _clovers, address _clubToken, address _clubTokenController) public {

        clovers = _clovers;

        clubToken = _clubToken;

        clubTokenController = _clubTokenController;

        paused = true;

    }

    /**

    * @dev Gets the current stake of a Clover based on the hash of the moves.

    * @param movesHash The hash of the moves that make up the clover.

    * @return A uint256 value of stake.

    */

    function getStake(bytes32 movesHash) public view returns (uint256) {

        return commits[movesHash].stake;

    }

    /**

    * @dev Gets the address of the committer of a Clover based on the hash of the moves.

    * @param movesHash The hash of the moves that make up the clover.

    * @return The address of the committer.

    */

    function getCommit(bytes32 movesHash) public view returns (address) {

        return commits[movesHash].committer;

    }

    /**

    * @dev Gets the current staking period needed to verify a Clover.

    * @param _tokenId The token Id of the clover.

    * @return A uint256 value of stake period in seconds.

    */

    function getMovesHash(uint _tokenId) public constant returns (bytes32) {

        return keccak256(Clovers(clovers).getCloverMoves(_tokenId));

    }

    /**

    * @dev Checks whether the game is valid.

    * @param moves The moves needed to play validate the game.

    * @return A boolean representing whether or not the game is valid.

    */

    function isValid(bytes28[2] moves) public constant returns (bool) {

        Reversi.Game memory game = Reversi.playGame(moves);

        return isValidGame(game.error, game.complete);

    }



    /**

    * @dev Checks whether the game is valid.

    * @param error The pre-played game error

    * @param complete The pre-played game complete boolean

    * @return A boolean representing whether or not the game is valid.

    */

    function isValidGame(bool error, bool complete) public pure returns (bool) {

        if (error) return false;

        if (!complete) return false;

        return true;

    }

    /**

    * @dev Checks whether the game has passed the verification period.

    * @param _tokenId The board being checked.

    * @return A boolean representing whether or not the game has been verified.

    */

    function isVerified(uint256 _tokenId) public constant returns (bool) {

        uint256 _blockMinted = Clovers(clovers).getBlockMinted(_tokenId);

        if(_blockMinted == 0) return false;

        return block.number.sub(_blockMinted) > stakePeriod;

    }

    /**

    * @dev Calculates the reward of the board.

    * @param _symmetries symmetries saved as a uint256 value like 00010101 where bits represent symmetry types.

    * @return A uint256 representing the reward that would be returned for claiming the board.

    */

    function calculateReward(uint256 _symmetries) public constant returns (uint256) {

        uint256 Symmetricals;

        uint256 RotSym;

        uint256 Y0Sym;

        uint256 X0Sym;

        uint256 XYSym;

        uint256 XnYSym;

        (Symmetricals,

        RotSym,

        Y0Sym,

        X0Sym,

        XYSym,

        XnYSym) = Clovers(clovers).getAllSymmetries();

        uint256 base = 0;

        if (_symmetries >> 4 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(RotSym + 1));

        if (_symmetries >> 3 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(Y0Sym + 1));

        if (_symmetries >> 2 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(X0Sym + 1));

        if (_symmetries >> 1 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(XYSym + 1));

        if (_symmetries & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(XnYSym + 1));

        return base;

    }



/*

    // NOTE: Disabled to reduce contract size

    function instantClaimClover(bytes28[2] moves, bool _keep) public payable returns (bool) {

        Reversi.Game memory game = Reversi.playGame(moves);

        require(isValidGame(game.error, game.complete));

        uint256 tokenId = uint256(game.board);

        require(Clovers(clovers).getBlockMinted(tokenId) == 0);

        require(!Clovers(clovers).exists(tokenId));

        Clovers(clovers).setBlockMinted(tokenId, block.number);

        Clovers(clovers).setCloverMoves(tokenId, moves);



        uint256 symmetries = Reversi.returnSymmetricals(game.RotSym, game.Y0Sym, game.X0Sym, game.XYSym, game.XnYSym);

        uint256 reward;



        if (uint256(symmetries) > 0) {

            Clovers(clovers).setSymmetries(tokenId, uint256(symmetries));

            reward = calculateReward(uint256(symmetries));

            Clovers(clovers).setReward(tokenId, reward);

        }

        if (_keep) {

            // If the user decides to keep the Clover, they must

            // pay for it in club tokens according to the reward price.

            if (ClubToken(clubToken).balanceOf(msg.sender) < reward) {

                ClubTokenController(clubTokenController).buy.value(msg.value)(msg.sender); // msg.value needs to be enough to buy "reward" amount of Club Token

            }

            if (reward > 0) {

                // ClubToken(clubToken).transferFrom(msg.sender, clubToken, reward); // if we'd rather keep the money

                ClubToken(clubToken).burn(msg.sender, reward);

            }

            Clovers(clovers).mint(msg.sender, tokenId);

        } else {

            // If the user decides not to keep the Clover, they will

            // receive the reward price in club tokens, and the clover will

            // go for sale at 10x the reward price.

            if (reward > 0) {

                require(ClubToken(clubToken).mint(msg.sender, reward));

            }

            Clovers(clovers).mint(clovers, tokenId);

        }



    } */



    function getPrice(uint256 _symmetries) public constant returns(uint256) {

        return basePrice.add(calculateReward(_symmetries));

    }



    function updateGasBlockMargin(uint256 _gasBlockMargin) public onlyOwnerOrOracle {

        gasBlockMargin = _gasBlockMargin;

    }



    function updateMarginOfError(uint256 _marginOfError) public onlyOwnerOrOracle {

        marginOfError = _marginOfError;

    }



    function updateGasPrices(uint256 _fastGasPrice, uint256 _averageGasPrice, uint256 _safeLowGasPrice) public onlyOwnerOrOracle {

        uint256 gasLastUpdated = block.number << 192;

        uint256 fastGasPrice = _fastGasPrice << 128;

        uint256 averageGasPrice = _averageGasPrice << 64;

        uint256 safeLowGasPrice = _safeLowGasPrice;

        gasLastUpdated_fastGasPrice_averageGasPrice_safeLowGasPrice = gasLastUpdated | fastGasPrice | averageGasPrice | safeLowGasPrice;

    }



    function gasLastUpdated() public view returns(uint256) {

        return uint256(uint64(gasLastUpdated_fastGasPrice_averageGasPrice_safeLowGasPrice >> 192));

    }

    function fastGasPrice() public view returns(uint256) {

        return uint256(uint64(gasLastUpdated_fastGasPrice_averageGasPrice_safeLowGasPrice >> 128));

    }

    function averageGasPrice() public view returns(uint256) {

        return uint256(uint64(gasLastUpdated_fastGasPrice_averageGasPrice_safeLowGasPrice >> 64));

    }

    function safeLowGasPrice() public view returns(uint256) {

        return uint256(uint64(gasLastUpdated_fastGasPrice_averageGasPrice_safeLowGasPrice));

    }

    function getGasPriceForApp() public view returns(uint256) {

        if (block.number.sub(gasLastUpdated()) > gasBlockMargin) {

            return oneGwei.mul(10);

        } else {

            return fastGasPrice();

        }

    }



    /**

    * @dev Claim the Clover without a commit or reveal. Payable so you can attach enough for the stake,

    * as well as enough to buy tokens if needed to keep the Clover.

    * @param moves The moves that make up the Clover reversi game.

    * @param _tokenId The board that results from the moves.

    * @param _symmetries symmetries saved as a uint256 value like 00010101 where bits represent symmetry

    * @param _keep symmetries saved as a uint256 value like 00010101 where bits represent symmetry

    * types.

    * @return A boolean representing whether or not the claim was successful.

    */

    function claimClover(bytes28[2] moves, uint256 _tokenId, uint256 _symmetries, bool _keep) public payable notPaused returns (bool) {

        emit cloverClaimed(moves, _tokenId, msg.sender, _tokenId, _tokenId, _symmetries, _keep);



        bytes32 movesHash = keccak256(moves);



        uint256 stakeWithGas = stakeAmount.mul(getGasPriceForApp());

        uint256 _marginOfError = stakeAmount.mul(oneGwei).mul(marginOfError);

        require(msg.value >= stakeWithGas.sub(_marginOfError));

        require(getCommit(movesHash) == 0);



        setCommit(movesHash, msg.sender);

        if (stakeWithGas > 0) {

            setStake(movesHash, stakeWithGas);

            clovers.transfer(stakeWithGas);

        }



        emit cloverCommitted(movesHash, msg.sender);



        require(!Clovers(clovers).exists(_tokenId));

        require(Clovers(clovers).getBlockMinted(_tokenId) == 0);



        Clovers(clovers).setBlockMinted(_tokenId, block.number);

        Clovers(clovers).setCloverMoves(_tokenId, moves);

        Clovers(clovers).setKeep(_tokenId, _keep);



        uint256 reward;

        if (_symmetries > 0) {

            Clovers(clovers).setSymmetries(_tokenId, _symmetries);

            reward = calculateReward(_symmetries);

            Clovers(clovers).setReward(_tokenId, reward);

        }

        uint256 price = basePrice.add(reward);

        if (_keep && price > 0) {

            // If the user decides to keep the Clover, they must

            // pay for it in club tokens according to the reward price.

            if (ClubToken(clubToken).balanceOf(msg.sender) < price) {

                ClubTokenController(clubTokenController).buy.value(msg.value.sub(stakeWithGas))(msg.sender);

            }

            // require(ClubToken(clubToken).transferFrom(msg.sender, clovers, price));

            ClubToken(clubToken).burn(msg.sender, price);

        }

        Clovers(clovers).mint(clovers, _tokenId);

        emit cloverClaimed(moves, _tokenId, msg.sender, stakeWithGas, reward, _symmetries, _keep);

        return true;

    }





    // This is better than current commit hash because the commiter's address is part of the move sequence

    // otherwise griefing could still take place....

    // function generateCommit(bytes28[2] moves) public view returns(bytes32 commitHash) {

    //     return sha256(moves, msg.sender);

    // }



    /**

    * @dev Commit the hash of the moves needed to claim the Clover. A stake should be

    * made for counterfactual verification.

    * @param movesHash The hash of the moves that makes up the Clover reversi

    * game.

    * @return A boolean representing whether or not the commit was successful.

    NOTE: Disabled for contract size, if front running becomes a problem it can be

    implemented with an upgrade

    */

    /* function claimCloverCommit(bytes32 movesHash) public payable returns (bool) {

        require(msg.value >= stakeAmount);

        require(getCommit(movesHash) == 0);



        setCommit(movesHash, msg.sender);

        setStake(movesHash, stakeAmount);



        clovers.transfer(stakeAmount);



        emit cloverCommitted(movesHash, msg.sender);

        return true;

    }

    /**

    * @dev Reveal the solution to the previous commit to claim the Clover.

    * @param moves The moves that make up the Clover reversi game.

    * @param _tokenId The board that results from the moves.

    * @param _symmetries symmetries saved as a uint256 value like 00010101 where bits represent symmetry types.

    * @return A boolean representing whether or not the reveal and claim was successful.

    NOTE: Disabled for contract size, if front running becomes a problem it can be implemented with an upgrade

    */

    /* function claimCloverReveal(bytes28[2] moves, uint256 _tokenId, uint256 _symmetries, bool _keep) public returns (bool) {

        bytes32 movesHash = keccak256(moves);

        address committer = getCommit(movesHash);



        require(Clovers(clovers).getBlockMinted(_tokenId) == 0);



        Clovers(clovers).setBlockMinted(_tokenId, block.number);

        Clovers(clovers).setCloverMoves(_tokenId, moves);

        Clovers(clovers).setKeep(_tokenId, _keep);

        uint256 reward;

        if (_symmetries > 0) {

            Clovers(clovers).setSymmetries(_tokenId, _symmetries);

            reward = calculateReward(_symmetries);

            Clovers(clovers).setReward(_tokenId, reward);

        }

        if (_keep) {

            ClubToken(clubToken).increaseApproval(address(this), basePrice.add(reward));

        }

        uint256 stake = getStake(movesHash);

        emit cloverClaimed(moves, _tokenId, committer, stake, reward, _symmetries, _keep);

        return true;

    } */





    /**

    * @dev Retrieve the stake from a Clover claim after the stake period has ended, or with the authority of the oracle.

    * @param _tokenId The board which holds the stake.

    * @param _fastGasPrice The current fast gas price.

    * @param _averageGasPrice The current average gas price.

    * @param _safeLowGasPrice The current slow safe gas price

    * @return A boolean representing whether or not the retrieval was successful.

    */

    function retrieveStakeWithGas(uint256 _tokenId, uint256 _fastGasPrice, uint256 _averageGasPrice, uint256 _safeLowGasPrice) public payable returns (bool) {

        require(retrieveStake(_tokenId));

        if (msg.sender == owner || msg.sender == oracle) {

            updateGasPrices(_fastGasPrice, _averageGasPrice, _safeLowGasPrice);

        }

    }



    /**

    * @dev Retrieve the stake from a Clover claim after the stake period has ended, or with the authority of the oracle.

    * @param _tokenId The board which holds the stake.

    * @return A boolean representing whether or not the retrieval was successful.

    */

    function retrieveStake(uint256 _tokenId) public payable returns (bool) {

        bytes28[2] memory moves = Clovers(clovers).getCloverMoves(_tokenId);

        bytes32 movesHash = keccak256(moves);





        require(!commits[movesHash].collected);

        commits[movesHash].collected = true;



        require(isVerified(_tokenId) || msg.sender == owner || msg.sender == oracle);



        uint256 stake = getStake(movesHash);

        addSymmetries(_tokenId);

        address committer = getCommit(movesHash);

        require(committer == msg.sender || msg.sender == owner || msg.sender == oracle);

        uint256 reward = Clovers(clovers).getReward(_tokenId);

        bool _keep = Clovers(clovers).getKeep(_tokenId);



        if (_keep) {

            // If the user decided to keep the Clover, they will

            // receive the clover now that it has been verified

            Clovers(clovers).transferFrom(clovers, committer, _tokenId);

        } else {

            // If the user decided not to keep the Clover, they will

            // receive the reward price in club tokens, and the clover will

            // go for sale by the contract.

            ISimpleCloversMarket(simpleCloversMarket).sell(_tokenId, basePrice.add(reward.mul(priceMultiplier)));

            if (reward > 0) {

                require(ClubToken(clubToken).mint(committer, reward));

            }

        }

        if (stake > 0) {

            Clovers(clovers).moveEth(msg.sender, stake);

        }

        emit stakeRetrieved(_tokenId, msg.sender, stake);



        return true;

    }





    /**

    * @dev Convert a bytes16 board into a uint256.

    * @param _board The board being converted.

    * @return number the uint256 being converted.

    */

    function convertBytes16ToUint(bytes16 _board) public view returns(uint256 number) {

        for(uint i=0;i<_board.length;i++){

            number = number + uint(_board[i])*(2**(8*(_board.length-(i+1))));

        }

    }





    /**

    * @dev Challenge a staked Clover for being invalid.

    * @param _tokenId The board being challenged.

    * @param _fastGasPrice The current fast gas price.

    * @param _averageGasPrice The current average gas price.

    * @param _safeLowGasPrice The current slow safe gas price

    * @return A boolean representing whether or not the challenge was successful.

    */

    function challengeCloverWithGas(uint256 _tokenId, uint256 _fastGasPrice, uint256 _averageGasPrice, uint256 _safeLowGasPrice) public returns (bool) {

        require(challengeClover(_tokenId));

        if (msg.sender == owner || msg.sender == oracle) {

            updateGasPrices(_fastGasPrice, _averageGasPrice, _safeLowGasPrice);

        }

        return true;

    }

    /**

    * @dev Challenge a staked Clover for being invalid.

    * @param _tokenId The board being challenged.

    * @return A boolean representing whether or not the challenge was successful.

    */

    function challengeClover(uint256 _tokenId) public returns (bool) {

        bool valid = true;

        bytes28[2] memory moves = Clovers(clovers).getCloverMoves(_tokenId);



        if (msg.sender != owner && msg.sender != oracle) {

            Reversi.Game memory game = Reversi.playGame(moves);

            if(convertBytes16ToUint(game.board) != _tokenId) {

                valid = false;

            }

            if(valid && isValidGame(game.error, game.complete)) {

                uint256 _symmetries = Clovers(clovers).getSymmetries(_tokenId);

                valid = (_symmetries >> 4 & 1) > 0 == game.RotSym ? valid : false;

                valid = (_symmetries >> 3 & 1) > 0 == game.Y0Sym ? valid : false;

                valid = (_symmetries >> 2 & 1) > 0 == game.X0Sym ? valid : false;

                valid = (_symmetries >> 1 & 1) > 0 == game.XYSym ? valid : false;

                valid = (_symmetries & 1) > 0 == game.XnYSym ? valid : false;

            } else {

                valid = false;

            }

            require(!valid);

        }

        bytes32 movesHash = keccak256(moves);

        uint256 stake = getStake(movesHash);

        if (!isVerified(_tokenId) && stake > 0) {

            Clovers(clovers).moveEth(msg.sender, stake);

        }

        if (commits[movesHash].collected) {

            removeSymmetries(_tokenId);

        }



        address committer = getCommit(movesHash);

        emit cloverChallenged(moves, _tokenId, committer, msg.sender, stake);



        Clovers(clovers).deleteClover(_tokenId);

        deleteCommit(movesHash);

        return true;

    }



    function fixSalePrice(uint256 _tokenId, uint256 _price) public onlyOwnerOrOracle {

        ISimpleCloversMarket(simpleCloversMarket).sell(_tokenId, _price);

    }



    /**

    * @dev Moves clovers without explicit allow permission for use by simpleCloversMarket

    * in order to avoid double transaction (allow, transferFrom)

    * @param _from The current owner of the Clover

    * @param _to The future owner of the Clover

    * @param _tokenId The Clover

    */

    function transferFrom(address _from, address _to, uint256 _tokenId) public {

        require(msg.sender == simpleCloversMarket || msg.sender == curationMarket);

        Clovers(clovers).transferFrom(_from, _to, _tokenId);

    }



    /**

    * @dev Updates pause boolean.

    * @param _paused The new puased boolean.

    */

    function updatePaused(bool _paused) public onlyOwner {

        paused = _paused;

    }



    /**

    * @dev Updates curationMarket Address.

    * @param _curationMarket The new curationMarket Address.

    */

    function updateCurationMarket(address _curationMarket) public onlyOwner {

        curationMarket = _curationMarket;

    }

    /**

    * @dev Updates oracle Address.

    * @param _oracle The new oracle Address.

    */

    function updateOracle(address _oracle) public onlyOwner {

        oracle = _oracle;

    }



    /**

    * @dev Updates simpleCloversMarket Address.

    * @param _simpleCloversMarket The new simpleCloversMarket address.

    */

    function updateSimpleCloversMarket(address _simpleCloversMarket) public onlyOwner {

        simpleCloversMarket = _simpleCloversMarket;

    }



    /**

    * @dev Updates clubTokenController Address.

    * @param _clubTokenController The new clubTokenController address.

    */

    function updateClubTokenController(address _clubTokenController) public onlyOwner {

        clubTokenController = _clubTokenController;

    }

    /**

    * @dev Updates the stake amount.

    * @param _stakeAmount The new amount needed to stake.

    */

    function updateStakeAmount(uint256 _stakeAmount) public onlyOwner {

        stakeAmount = _stakeAmount;

    }

    /**

    * @dev Updates the stake period.

    * @param _stakePeriod The uint256 value of time needed to stake before being verified.

    */

    function updateStakePeriod(uint256 _stakePeriod) public onlyOwner {

        stakePeriod = _stakePeriod;

    }

    /**

    * @dev Updates the pay multiplier, used to calculate token reward.

    * @param _payMultiplier The uint256 value of pay multiplier.

    */

    function updatePayMultipier(uint256 _payMultiplier) public onlyOwner {

        payMultiplier = _payMultiplier;

    }

    /**

    * @dev Updates the price multiplier, used to calculate the clover price (multiplied by the original reward).

    * @param _priceMultiplier The uint256 value of the price multiplier.

    */

    function updatePriceMultipier(uint256 _priceMultiplier) public onlyOwner {

        priceMultiplier = _priceMultiplier;

    }

    /**

    * @dev Updates the base price, used to calculate the clover cost.

    * @param _basePrice The uint256 value of the base price.

    */

    function updateBasePrice(uint256 _basePrice) public onlyOwner {

        basePrice = _basePrice;

    }



    /**

    * @dev Sets the stake of a Clover based on the hash of the moves.

    * @param movesHash The hash of the moves that make up the clover.

    * @param stake A uint256 value of stake.

    */

    function setStake(bytes32 movesHash, uint256 stake) private {

        commits[movesHash].stake = stake;

    }



    /**

    * @dev Sets the address of the committer of a Clover based on the hash of the moves.

    * @param movesHash The hash of the moves that make up the clover.

    * @param committer The address of the committer.

    */

    function setCommit(bytes32 movesHash, address committer) private {

        commits[movesHash].committer = committer;

    }



    function _setCommit(bytes32 movesHash, address committer) public onlyOwner {

        setCommit(movesHash, committer);

    }

    function deleteCommit(bytes32 movesHash) private {

        delete(commits[movesHash]);

    }



    /**

    * @dev Adds new tallys of the totals numbers of clover symmetries.

    * @param _tokenId The token which needs to be examined.

    */

    function addSymmetries(uint256 _tokenId) private {

        uint256 Symmetricals;

        uint256 RotSym;

        uint256 Y0Sym;

        uint256 X0Sym;

        uint256 XYSym;

        uint256 XnYSym;

        (Symmetricals,

        RotSym,

        Y0Sym,

        X0Sym,

        XYSym,

        XnYSym) = Clovers(clovers).getAllSymmetries();

        uint256 _symmetries = Clovers(clovers).getSymmetries(_tokenId);

        Symmetricals = Symmetricals.add(_symmetries > 0 ? 1 : 0);

        RotSym = RotSym.add(uint256(_symmetries >> 4 & 1));

        Y0Sym = Y0Sym.add(uint256(_symmetries >> 3 & 1));

        X0Sym = X0Sym.add(uint256(_symmetries >> 2 & 1));

        XYSym = XYSym.add(uint256(_symmetries >> 1 & 1));

        XnYSym = XnYSym.add(uint256(_symmetries & 1));

        Clovers(clovers).setAllSymmetries(Symmetricals, RotSym, Y0Sym, X0Sym, XYSym, XnYSym);

    }

    /**

    * @dev Remove false tallys of the totals numbers of clover symmetries.

    * @param _tokenId The token which needs to be examined.

    */

    function removeSymmetries(uint256 _tokenId) private {

        uint256 Symmetricals;

        uint256 RotSym;

        uint256 Y0Sym;

        uint256 X0Sym;

        uint256 XYSym;

        uint256 XnYSym;

        (Symmetricals,

        RotSym,

        Y0Sym,

        X0Sym,

        XYSym,

        XnYSym) = Clovers(clovers).getAllSymmetries();

        uint256 _symmetries = Clovers(clovers).getSymmetries(_tokenId);

        Symmetricals = Symmetricals.sub(_symmetries > 0 ? 1 : 0);

        RotSym = RotSym.sub(uint256(_symmetries >> 4 & 1));

        Y0Sym = Y0Sym.sub(uint256(_symmetries >> 3 & 1));

        X0Sym = X0Sym.sub(uint256(_symmetries >> 2 & 1));

        XYSym = XYSym.sub(uint256(_symmetries >> 1 & 1));

        XnYSym = XnYSym.sub(uint256(_symmetries & 1));

        Clovers(clovers).setAllSymmetries(Symmetricals, RotSym, Y0Sym, X0Sym, XYSym, XnYSym);

    }



}