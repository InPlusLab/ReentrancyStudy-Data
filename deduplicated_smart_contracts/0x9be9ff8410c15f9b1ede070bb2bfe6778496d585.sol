/**

 *Submitted for verification at Etherscan.io on 2018-09-06

*/



pragma solidity ^0.4.24;



// File: zos-lib/contracts/migrations/Migratable.sol



/**

 * @title Migratable

 * Helper contract to support intialization and migration schemes between

 * different implementations of a contract in the context of upgradeability.

 * To use it, replace the constructor with a function that has the

 * `isInitializer` modifier starting with `"0"` as `migrationId`.

 * When you want to apply some migration code during an upgrade, increase

 * the `migrationId`. Or, if the migration code must be applied only after

 * another migration has been already applied, use the `isMigration` modifier.

 * This helper supports multiple inheritance.

 * WARNING: It is the developer's responsibility to ensure that migrations are

 * applied in a correct order, or that they are run at all.

 * See `Initializable` for a simpler version.

 */

contract Migratable {

  /**

   * @dev Emitted when the contract applies a migration.

   * @param contractName Name of the Contract.

   * @param migrationId Identifier of the migration applied.

   */

  event Migrated(string contractName, string migrationId);



  /**

   * @dev Mapping of the already applied migrations.

   * (contractName => (migrationId => bool))

   */

  mapping (string => mapping (string => bool)) internal migrated;



  /**

   * @dev Internal migration id used to specify that a contract has already been initialized.

   */

  string constant private INITIALIZED_ID = "initialized";





  /**

   * @dev Modifier to use in the initialization function of a contract.

   * @param contractName Name of the contract.

   * @param migrationId Identifier of the migration.

   */

  modifier isInitializer(string contractName, string migrationId) {

    validateMigrationIsPending(contractName, INITIALIZED_ID);

    validateMigrationIsPending(contractName, migrationId);

    _;

    emit Migrated(contractName, migrationId);

    migrated[contractName][migrationId] = true;

    migrated[contractName][INITIALIZED_ID] = true;

  }



  /**

   * @dev Modifier to use in the migration of a contract.

   * @param contractName Name of the contract.

   * @param requiredMigrationId Identifier of the previous migration, required

   * to apply new one.

   * @param newMigrationId Identifier of the new migration to be applied.

   */

  modifier isMigration(string contractName, string requiredMigrationId, string newMigrationId) {

    require(isMigrated(contractName, requiredMigrationId), "Prerequisite migration ID has not been run yet");

    validateMigrationIsPending(contractName, newMigrationId);

    _;

    emit Migrated(contractName, newMigrationId);

    migrated[contractName][newMigrationId] = true;

  }



  /**

   * @dev Returns true if the contract migration was applied.

   * @param contractName Name of the contract.

   * @param migrationId Identifier of the migration.

   * @return true if the contract migration was applied, false otherwise.

   */

  function isMigrated(string contractName, string migrationId) public view returns(bool) {

    return migrated[contractName][migrationId];

  }



  /**

   * @dev Initializer that marks the contract as initialized.



   * For more information see https://github.com/zeppelinos/zos-lib/issues/158.

   */

  function initialize() isInitializer("Migratable", "1.2.1") public {

  }



  /**

   * @dev Reverts if the requested migration was already executed.

   * @param contractName Name of the contract.

   * @param migrationId Identifier of the migration.

   */

  function validateMigrationIsPending(string contractName, string migrationId) private view {

    require(!isMigrated(contractName, migrationId), "Requested target migration ID has already been run");

  }

}



// File: openzeppelin-zos/contracts/ownership/Ownable.sol



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable is Migratable {

  address public owner;





  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  function initialize(address _sender) public isInitializer("Ownable", "1.9.0") {

    owner = _sender;

  }



  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param newOwner The address to transfer ownership to.

   */

  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



}



// File: openzeppelin-zos/contracts/token/ERC20/ERC20Basic.sol



/**

 * @title ERC20Basic

 * @dev Simpler version of ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/179

 */

contract ERC20Basic {

  function totalSupply() public view returns (uint256);

  function balanceOf(address who) public view returns (uint256);

  function transfer(address to, uint256 value) public returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

}



// File: contracts/NaviTokenBurner.sol



/**

 * @title NaviTokenBurner contract

 */

contract NaviTokenBurner is Ownable {



  event TokensBurned (uint256 amount);



  ERC20Basic public token;



  constructor(ERC20Basic _token) public {

    token = _token;

  }



  function tokenDestroy() public onlyOwner{

    require(token.balanceOf(this) > 0);

    selfdestruct(owner);



    emit TokensBurned(token.balanceOf(this));

  }



  function () public payable {

    revert();

  }



}