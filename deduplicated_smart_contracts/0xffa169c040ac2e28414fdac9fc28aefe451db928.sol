/**

 *Submitted for verification at Etherscan.io on 2018-12-03

*/



pragma solidity 0.4.25;



/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

contract ERC20 {

  function totalSupply() public view returns (uint256);



  function balanceOf(address _who) public view returns (uint256);



  function allowance(address _owner, address _spender)

    public view returns (uint256);



  function transfer(address _to, uint256 _value) public returns (bool);



  function approve(address _spender, uint256 _value)

    public returns (bool);



  function transferFrom(address _from, address _to, uint256 _value)

    public returns (bool);



  function decimals() public view returns (uint256);



  event Transfer(

    address indexed from,

    address indexed to,

    uint256 value

  );



  event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

  );

}



library ERC20SafeTransfer {

    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {



        require(_tokenAddress.call(bytes4(keccak256("transfer(address,uint256)")), _to, _value));



        return fetchReturnData();

    }



    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {



        require(_tokenAddress.call(bytes4(keccak256("transferFrom(address,address,uint256)")), _from, _to, _value));



        return fetchReturnData();

    }



    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {



        require(_tokenAddress.call(bytes4(keccak256("approve(address,uint256)")), _spender, _value));



        return fetchReturnData();

    }



    function fetchReturnData() internal returns (bool success){

        assembly {

            switch returndatasize()

            case 0 {

                success := 1

            }

            case 32 {

                returndatacopy(0, 0, 32)

                success := mload(0)

            }

            default {

                revert(0, 0)

            }

        }

    }



}



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

  address public owner;



  event OwnershipRenounced(address indexed previousOwner);

  event OwnershipTransferred(

    address indexed previousOwner,

    address indexed newOwner

  );



  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  constructor() public {

    owner = msg.sender;

  }



  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  /**

   * @dev Allows the current owner to relinquish control of the contract.

   * @notice Renouncing to ownership will leave the contract without an owner.

   * It will not be possible to call the functions with the `onlyOwner`

   * modifier anymore.

   */

  function renounceOwnership() public onlyOwner {

    emit OwnershipRenounced(owner);

    owner = address(0);

  }



  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function transferOwnership(address _newOwner) public onlyOwner {

    _transferOwnership(_newOwner);

  }



  /**

   * @dev Transfers control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function _transferOwnership(address _newOwner) internal {

    require(_newOwner != address(0));

    emit OwnershipTransferred(owner, _newOwner);

    owner = _newOwner;

  }

}



/*



  Copyright 2018 ZeroEx Intl.



  Licensed under the Apache License, Version 2.0 (the "License");

  you may not use this file except in compliance with the License.

  You may obtain a copy of the License at



    http://www.apache.org/licenses/LICENSE-2.0



  Unless required by applicable law or agreed to in writing, software

  distributed under the License is distributed on an "AS IS" BASIS,

  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

  See the License for the specific language governing permissions and

  limitations under the License.



*/



pragma solidity 0.4.25;



/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.

/// @author Amir Bandeali - <[email protected]>, Will Warren - <[email protected]>

contract TokenTransferProxy is Ownable {



    /// @dev Only authorized addresses can invoke functions with this modifier.

    modifier onlyAuthorized {

        require(authorized[msg.sender]);

        _;

    }



    modifier targetAuthorized(address target) {

        require(authorized[target]);

        _;

    }



    modifier targetNotAuthorized(address target) {

        require(!authorized[target]);

        _;

    }



    mapping (address => bool) public authorized;

    address[] public authorities;



    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);

    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);



    /*

     * Public functions

     */



    /// @dev Authorizes an address.

    /// @param target Address to authorize.

    function addAuthorizedAddress(address target)

        public

        onlyOwner

        targetNotAuthorized(target)

    {

        authorized[target] = true;

        authorities.push(target);

        emit LogAuthorizedAddressAdded(target, msg.sender);

    }



    /// @dev Removes authorizion of an address.

    /// @param target Address to remove authorization from.

    function removeAuthorizedAddress(address target)

        public

        onlyOwner

        targetAuthorized(target)

    {

        delete authorized[target];

        for (uint i = 0; i < authorities.length; i++) {

            if (authorities[i] == target) {

                authorities[i] = authorities[authorities.length - 1];

                authorities.length -= 1;

                break;

            }

        }

        emit LogAuthorizedAddressRemoved(target, msg.sender);

    }



    /// @dev Calls into ERC20 Token contract, invoking transferFrom.

    /// @param token Address of token to transfer.

    /// @param from Address to transfer token from.

    /// @param to Address to transfer token to.

    /// @param value Amount of token to transfer.

    /// @return Success of transfer.

    function transferFrom(

        address token,

        address from,

        address to,

        uint value)

        public

        onlyAuthorized

        returns (bool)

    {

        require(ERC20SafeTransfer.safeTransferFrom(token, from, to, value));

    }



    /*

     * Public constant functions

     */



    /// @dev Gets all authorized addresses.

    /// @return Array of authorized addresses.

    function getAuthorizedAddresses()

        public

        view

        returns (address[])

    {

        return authorities;

    }

}