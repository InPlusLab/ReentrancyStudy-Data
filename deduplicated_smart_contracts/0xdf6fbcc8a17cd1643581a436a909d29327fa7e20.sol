/**

 *Submitted for verification at Etherscan.io on 2018-08-24

*/



pragma solidity ^0.4.24;



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (a == 0) {

      return 0;

    }



    c = a * b;

    assert(c / a == b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    // assert(b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return a / b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {

    c = a + b;

    assert(c >= a);

    return c;

  }

}



// File: contracts/Distribute.sol



contract Distribute {



    using SafeMath for SafeMath;



    address public netAddress = 0x88888888c84198BCc5CEb4160d13726F22c151Ab;



    address public otherAddress = 0x8e83D33aB48b110B7C3DF8C6F5D02191aF9b80FD;



    uint proportionA = 94;

    uint proportionB = 6;

    uint base = 100;



    constructor() public {



    }



    function() payable public {

        require(msg.value > 0);



        netAddress.transfer(SafeMath.div(SafeMath.mul(msg.value, proportionA), base));

        otherAddress.transfer(SafeMath.div(SafeMath.mul(msg.value, proportionB), base));



    }





}