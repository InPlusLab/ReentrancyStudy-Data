/**

 *Submitted for verification at Etherscan.io on 2018-12-30

*/



pragma solidity >=0.4.22 <0.6.0;



library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }



  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a / b;

    return c;

  }



  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function add(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a + b;

    assert(c >= a);

    return c;

  }

}



contract ForeignToken {

    function balanceOf(address _owner) public returns (uint256);

    function transfer(address _to, uint256 _value) public returns (bool);

}



contract ERC20Basic {

    uint256 public totalSupply;

    function balanceOf(address who) public returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

}



contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender) public returns (uint256);

    function transferFrom(address from, address to, uint256 value) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



interface Token { 

    function distr(address _to, uint256 _value) external returns (bool);

    function totalSupply() external returns (uint256 supply);

    function balanceOf(address _owner) external returns (uint256 balance);

}



interface token {

    function transfer(address receiver, uint amount) external;

}



contract Crowdsale {

    address public beneficiary;

    uint public fundingGoal = 10 ether;

    uint public amountRaised = 2000 ether;

    uint public deadline = now ;

    uint public price = 250 ether;

    token public tokenReward;

    mapping(address => uint256) public balanceOf;

    bool fundingGoalReached = false;

    bool crowdsaleClosed = false;



    event GoalReached(address recipient, uint totalAmountRaised);

    event FundTransfer(address backer, uint amount, bool isContribution);



    /**

     * Constructor

     *

     * Setup the owner

     */

    constructor(

        address ifSuccessfulSendTo,

        uint fundingGoalInEthers,

        uint durationInMinutes,

        uint etherCostOfEachToken,

        address addressOfTokenUsedAsReward

    ) public {

        beneficiary = ifSuccessfulSendTo= 0x11C848b7Ee546313505a15f286E858d653C4a8Ca;

        fundingGoal = fundingGoalInEthers * 10 ether;

        deadline = now + durationInMinutes * 43200 minutes;

        price = etherCostOfEachToken * 0.00009 ether;

        tokenReward = token(addressOfTokenUsedAsReward);

    }



    /**

     * Fallback function

     *

     * The function without name is the default function that is called whenever anyone sends funds to a contract

     */

    function () payable external {

        require(!crowdsaleClosed);

        uint amount = msg.value;

        balanceOf[msg.sender] += amount;

        amountRaised += amount;

        tokenReward.transfer(msg.sender, amount / price);

       emit FundTransfer(msg.sender, amount, true);

    }



    modifier afterDeadline() { if (now >= deadline) _; }



    /**

     * Check if goal was reached

     *

     * Checks if the goal or time limit has been reached and ends the campaign

     */

    function checkGoalReached() public afterDeadline {

        if (amountRaised >= fundingGoal){

            fundingGoalReached = true;

            emit GoalReached(beneficiary, amountRaised);

        }

        crowdsaleClosed = true;

   

 }





    /**

     * Withdraw the funds

     *

     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,

     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw

     * the amount they contributed.

     */

    function safeWithdrawal() public afterDeadline {

        if (!fundingGoalReached) {

            uint amount = balanceOf[msg.sender];

            balanceOf[msg.sender] = 0;

            if (amount > 0) {

                if (msg.sender.send(amount)) {

                   emit FundTransfer(msg.sender, amount, false);

                } else {

                    balanceOf[msg.sender] = amount;

                }

            }

        }



        if (fundingGoalReached && beneficiary == msg.sender) {

            if (msg.sender.send(amountRaised)) {

               emit FundTransfer(beneficiary, amountRaised, false);

            } else {

                //If we fail to send the funds to beneficiary, unlock funders balance

                fundingGoalReached = false;

            }

        }

    }

}