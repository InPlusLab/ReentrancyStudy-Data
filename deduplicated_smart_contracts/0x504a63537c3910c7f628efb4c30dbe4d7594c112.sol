// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

/*
.___..             ..__ .      .     
  |  |_ ._. _  _. _|[ __|  .._ |_  __
  |  [ )[  (/,(_](_][_./|\_|[_)[ )_) 
ThreadGlyphs             ._||        
Collect customizable line art NFTs, all completely decentralized and generated by the Ethereum blockchain.

Website: https://threadglyphs.com/
Created by sol_dev

*/

import "./PerlinNoise.sol";

interface Receiver {
	function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

contract Metadata {
	string public name = "ThreadGlyphs";
	string public symbol = unicode"â©¬";
	function contractURI() external pure returns (string memory) {
		return "https://api.threadglyphs.com/metadata";
	}
	function baseTokenURI() public pure returns (string memory) {
		return "https://api.threadglyphs.com/glyph/metadata/";
	}
	function tokenURI(uint256 _tokenId) external pure returns (string memory) {
		bytes memory _base = bytes(baseTokenURI());
		uint256 _digits = 1;
		uint256 _n = _tokenId;
		while (_n > 9) {
			_n /= 10;
			_digits++;
		}
		bytes memory _uri = new bytes(_base.length + _digits);
		for (uint256 i = 0; i < _uri.length; i++) {
			if (i < _base.length) {
				_uri[i] = _base[i];
			} else {
				uint256 _dec = (_tokenId / (10**(_uri.length - i - 1))) % 10;
				_uri[i] = bytes1(uint8(_dec) + 48);
			}
		}
		return string(_uri);
	}
}


contract ThreadGlyphs {

	uint256 constant public MAX_SUPPLY = 512;
	uint256 constant public MINT_COST = 0.25 ether;
	uint256 constant private SIZE = 10000;
	uint256 constant private STEP = 80;
	uint256 constant private STROKE = 32;
	uint256 constant private X_PADDING = 1000;
	uint256 constant private Y_PADDING = 1600;
	int256 constant private SCALAR = 2**16;

	struct User {
		uint256 balance;
		mapping(uint256 => uint256) list;
		mapping(address => bool) approved;
		mapping(uint256 => uint256) indexOf;
	}

	struct Token {
		address owner;
		address approved;
		bytes32 seed;
		bytes3 color1;
		bytes3 color2;
	}

	struct Info {
		uint256 totalSupply;
		mapping(uint256 => Token) list;
		mapping(address => User) users;
		Metadata metadata;
		address owner;
	}
	Info private info;

	mapping(bytes4 => bool) public supportsInterface;

	event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
	event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
	event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

	event Mint(address indexed owner, uint256 indexed tokenId, bytes32 seed);
	event Recolor(address indexed owner, uint256 indexed tokenId, bytes3 color, bool isColor1);


	modifier _onlyOwner() {
		require(msg.sender == owner());
		_;
	}


	constructor() {
		info.metadata = new Metadata();
		info.owner = msg.sender;
		supportsInterface[0x01ffc9a7] = true; // ERC-165
		supportsInterface[0x80ac58cd] = true; // ERC-721
		supportsInterface[0x5b5e139f] = true; // Metadata
		supportsInterface[0x780e9d63] = true; // Enumerable

		for (uint256 i = 0; i < 10; i++) {
			_mint();
		}
	}

	function setOwner(address _owner) external _onlyOwner {
		info.owner = _owner;
	}

	function setMetadata(Metadata _metadata) external _onlyOwner {
		info.metadata = _metadata;
	}

	function ownerWithdraw() external _onlyOwner {
		uint256 _balance = address(this).balance;
		require(_balance > 0);
		payable(msg.sender).transfer(_balance);
	}

	
	receive() external payable {
		mintMany(msg.value / MINT_COST);
	}
	
	function mint() external payable {
		mintMany(1);
	}

	function mintMany(uint256 _tokens) public payable {
		require(_tokens > 0);
		uint256 _cost = _tokens * MINT_COST;
		require(msg.value >= _cost);
		for (uint256 i = 0; i < _tokens; i++) {
			_mint();
		}
		if (msg.value > _cost) {
			payable(msg.sender).transfer(msg.value - _cost);
		}
	}
	
	function setColor1(uint256 _tokenId, bytes3 _color) external {
		require(msg.sender == ownerOf(_tokenId));
		info.list[_tokenId].color1 = _color;
		emit Recolor(msg.sender, _tokenId, _color, true);
	}
	
	function setColor2(uint256 _tokenId, bytes3 _color) external {
		require(msg.sender == ownerOf(_tokenId));
		info.list[_tokenId].color2 = _color;
		emit Recolor(msg.sender, _tokenId, _color, false);
	}
	
	function approve(address _approved, uint256 _tokenId) external {
		require(msg.sender == ownerOf(_tokenId));
		info.list[_tokenId].approved = _approved;
		emit Approval(msg.sender, _approved, _tokenId);
	}

	function setApprovalForAll(address _operator, bool _approved) external {
		info.users[msg.sender].approved[_operator] = _approved;
		emit ApprovalForAll(msg.sender, _operator, _approved);
	}

	function transferFrom(address _from, address _to, uint256 _tokenId) external {
		_transfer(_from, _to, _tokenId);
	}

	function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {
		safeTransferFrom(_from, _to, _tokenId, "");
	}

	function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public {
		_transfer(_from, _to, _tokenId);
		uint32 _size;
		assembly {
			_size := extcodesize(_to)
		}
		if (_size > 0) {
			require(Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) == 0x150b7a02);
		}
	}


	function name() external view returns (string memory) {
		return info.metadata.name();
	}

	function symbol() external view returns (string memory) {
		return info.metadata.symbol();
	}

	function contractURI() external view returns (string memory) {
		return info.metadata.contractURI();
	}

	function baseTokenURI() external view returns (string memory) {
		return info.metadata.baseTokenURI();
	}

	function tokenURI(uint256 _tokenId) external view returns (string memory) {
		return info.metadata.tokenURI(_tokenId);
	}

	function owner() public view returns (address) {
		return info.owner;
	}

	function totalSupply() public view returns (uint256) {
		return info.totalSupply;
	}

	function balanceOf(address _owner) public view returns (uint256) {
		return info.users[_owner].balance;
	}

	function ownerOf(uint256 _tokenId) public view returns (address) {
		require(_tokenId < totalSupply());
		return info.list[_tokenId].owner;
	}

	function getApproved(uint256 _tokenId) public view returns (address) {
		require(_tokenId < totalSupply());
		return info.list[_tokenId].approved;
	}

	function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
		return info.users[_owner].approved[_operator];
	}

	function getSeed(uint256 _tokenId) public view returns (bytes32) {
		require(_tokenId < totalSupply());
		return info.list[_tokenId].seed;
	}

	function getColor1(uint256 _tokenId) public view returns (bytes3) {
		require(_tokenId < totalSupply());
		return info.list[_tokenId].color1;
	}

	function getColor2(uint256 _tokenId) public view returns (bytes3) {
		require(_tokenId < totalSupply());
		return info.list[_tokenId].color2;
	}

	function tokenByIndex(uint256 _index) public view returns (uint256) {
		require(_index < totalSupply());
		return _index;
	}

	function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {
		require(_index < balanceOf(_owner));
		return info.users[_owner].list[_index];
	}

	function getSVG(uint256 _tokenId) external view returns (string memory svg) {
		string memory _size = _uint2str(SIZE);
		svg = string(abi.encodePacked("<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='", _size, "' height='", _size, "' viewBox='0 0 ", _size, " ", _size, "'>"));
		(bool[2] memory _bools, uint256[6] memory _ints) = getSettingsCompressed(getSeed(_tokenId));
		svg = string(abi.encodePacked(svg, "<rect width='100%' height='100%' fill='", _bools[0] ? "#040404" : "#fbfbfb", "' /><g fill='none' stroke-width='", _uint2str(STROKE), "' stroke-linecap='round'>"));
		for (uint256 i = 0; i < _ints[4]; i++) {
			string memory _path = "<path d='";
			for (uint256 j = 0; j <= (SIZE - 2 * X_PADDING) / STEP; j++) {
				uint256 x = X_PADDING + j * STEP;
				uint256 y = Y_PADDING + (SIZE - 2 * Y_PADDING) * i / (_ints[4] - 1);
				y = uint256(int256(y) + PerlinNoise.noise2d(int256(_ints[0] + x * uint256(SCALAR) / _ints[2]), int256(_ints[1] + y * uint256(SCALAR) / _ints[3])) * int256(Y_PADDING) / SCALAR);
				_path = string(abi.encodePacked(_path, j == 0 ? "M" : "L", _uint2str(_bools[1] ? y : x), " ", _uint2str(_bools[1] ? x : y)));
			}
			bytes3 _col = getColor1(_tokenId);
			if ((_ints[5] == 1 && i % 2 == 1) || (_ints[5] == 2 && i >= _ints[4] / 2)) {
				_col = getColor2(_tokenId);
			} else if (_ints[5] == 3) {
				_col = _collerp(_col, getColor2(_tokenId), i, _ints[4] - 1);
			}
			_path = string(abi.encodePacked(_path, "' stroke='", _col2str(_col), "'></path>"));
			svg = string(abi.encodePacked(svg, _path));
		}
		svg = string(abi.encodePacked(svg, "</g></svg>"));
	}

	function getTokenSettings(uint256 _tokenId) external view returns (bool inverted, bool vertical, uint256 xPos, uint256 yPos, uint256 xZoom, uint256 yZoom, uint256 lines, uint256 mode) {
		(inverted, vertical, xPos, yPos, xZoom, yZoom, lines, mode) = getSettings(getSeed(_tokenId));
	}

	function getSettings(bytes32 _seed) public pure returns (bool inverted, bool vertical, uint256 xPos, uint256 yPos, uint256 xZoom, uint256 yZoom, uint256 lines, uint256 mode) {
		bytes32 _rand = keccak256(abi.encodePacked("ThreadGlyph:", _seed));
		inverted = uint256(_rand) % 5 == 0;
		_rand = keccak256(abi.encodePacked(_rand));
		vertical = uint256(_rand) % 25 == 0;
		_rand = keccak256(abi.encodePacked(_rand));
		xPos = uint256(_rand) % 2**16;
		_rand = keccak256(abi.encodePacked(_rand));
		yPos = uint256(_rand) % 2**16;
		_rand = keccak256(abi.encodePacked(_rand));
		xZoom = 3200 + uint256(_rand) % 1800;
		_rand = keccak256(abi.encodePacked(_rand));
		yZoom = xZoom - 500 + uint256(_rand) % 500;
		_rand = keccak256(abi.encodePacked(_rand));
		lines = 12 + 2 * (10 - _sqrt(uint256(_rand) % 101));
		_rand = keccak256(abi.encodePacked(_rand));
		if (uint256(_rand) % 8 == 0) {
			_rand = keccak256(abi.encodePacked(_rand));
			if (uint256(_rand) % 4 == 0) {
				_rand = keccak256(abi.encodePacked(_rand));
				if (uint256(_rand) % 4 == 0) {
					mode = 3;
				} else {
					mode = 2;
				}
			} else {
				mode = 1;
			}
		} else {
			mode = 0;
		}
	}

	function getSettingsCompressed(bytes32 _seed) public pure returns (bool[2] memory bools, uint256[6] memory ints) {
		(bools[0], bools[1], ints[0], ints[1], ints[2], ints[3], ints[4], ints[5]) = getSettings(_seed);
	}

	function getGlyph(uint256 _tokenId) public view returns (address tokenOwner, address approved, bytes32 seed, bytes3 color1, bytes3 color2) {
		return (ownerOf(_tokenId), getApproved(_tokenId), getSeed(_tokenId), getColor1(_tokenId), getColor2(_tokenId));
	}

	function getGlyphs(uint256[] memory _tokenIds) public view returns (address[] memory owners, address[] memory approveds, bytes32[] memory seeds, bytes3[] memory color1s, bytes3[] memory color2s) {
		uint256 _length = _tokenIds.length;
		owners = new address[](_length);
		approveds = new address[](_length);
		seeds = new bytes32[](_length);
		color1s = new bytes3[](_length);
		color2s = new bytes3[](_length);
		for (uint256 i = 0; i < _length; i++) {
			(owners[i], approveds[i], seeds[i], color1s[i], color2s[i]) = getGlyph(_tokenIds[i]);
		}
	}

	function getGlyphsTable(uint256 _limit, uint256 _page, bool _isAsc) public view returns (uint256[] memory tokenIds, address[] memory owners, address[] memory approveds, bytes32[] memory seeds, bytes3[] memory color1s, bytes3[] memory color2s, uint256 totalGlyphs, uint256 totalPages) {
		require(_limit > 0);
		totalGlyphs = totalSupply();

		if (totalGlyphs > 0) {
			totalPages = (totalGlyphs / _limit) + (totalGlyphs % _limit == 0 ? 0 : 1);
			require(_page < totalPages);

			uint256 _offset = _limit * _page;
			if (_page == totalPages - 1 && totalGlyphs % _limit != 0) {
				_limit = totalGlyphs % _limit;
			}

			tokenIds = new uint256[](_limit);
			for (uint256 i = 0; i < _limit; i++) {
				tokenIds[i] = tokenByIndex(_isAsc ? _offset + i : totalGlyphs - _offset - i - 1);
			}
		} else {
			totalPages = 0;
			tokenIds = new uint256[](0);
		}
		(owners, approveds, seeds, color1s, color2s) = getGlyphs(tokenIds);
	}

	function getOwnerGlyphsTable(address _owner, uint256 _limit, uint256 _page, bool _isAsc) public view returns (uint256[] memory tokenIds, address[] memory approveds, bytes32[] memory seeds, bytes3[] memory color1s, bytes3[] memory color2s, uint256 totalGlyphs, uint256 totalPages) {
		require(_limit > 0);
		totalGlyphs = balanceOf(_owner);

		if (totalGlyphs > 0) {
			totalPages = (totalGlyphs / _limit) + (totalGlyphs % _limit == 0 ? 0 : 1);
			require(_page < totalPages);

			uint256 _offset = _limit * _page;
			if (_page == totalPages - 1 && totalGlyphs % _limit != 0) {
				_limit = totalGlyphs % _limit;
			}

			tokenIds = new uint256[](_limit);
			for (uint256 i = 0; i < _limit; i++) {
				tokenIds[i] = tokenOfOwnerByIndex(_owner, _isAsc ? _offset + i : totalGlyphs - _offset - i - 1);
			}
		} else {
			totalPages = 0;
			tokenIds = new uint256[](0);
		}
		( , approveds, seeds, color1s, color2s) = getGlyphs(tokenIds);
	}

	function allInfoFor(address _owner) external view returns (uint256 supply, uint256 ownerBalance) {
		return (totalSupply(), balanceOf(_owner));
	}


	function _mint() internal {
		require(msg.sender == tx.origin);
		require(totalSupply() < MAX_SUPPLY);
		uint256 _tokenId = info.totalSupply++;
		Token storage _newToken = info.list[_tokenId];
		_newToken.owner = msg.sender;
		bytes32 _seed = keccak256(abi.encodePacked(_tokenId, msg.sender, blockhash(block.number - 1), gasleft()));
		_newToken.seed = _seed;
		(bool _inverted, , , , , , , ) = getSettings(_seed);
		_newToken.color1 = _inverted ? bytes3(0xffffff) : bytes3(0x000000);
		_newToken.color2 = _inverted ? bytes3(0x66dd66) : bytes3(0xdd4444);
		uint256 _index = info.users[msg.sender].balance++;
		info.users[msg.sender].indexOf[_tokenId] = _index + 1;
		info.users[msg.sender].list[_index] = _tokenId;
		emit Transfer(address(0x0), msg.sender, _tokenId);
		emit Mint(msg.sender, _tokenId, _seed);
	}
	
	function _transfer(address _from, address _to, uint256 _tokenId) internal {
		address _owner = ownerOf(_tokenId);
		address _approved = getApproved(_tokenId);
		require(_from == _owner);
		require(msg.sender == _owner || msg.sender == _approved || isApprovedForAll(_owner, msg.sender));

		info.list[_tokenId].owner = _to;
		if (_approved != address(0x0)) {
			info.list[_tokenId].approved = address(0x0);
			emit Approval(address(0x0), address(0x0), _tokenId);
		}

		uint256 _index = info.users[_from].indexOf[_tokenId] - 1;
		uint256 _moved = info.users[_from].list[info.users[_from].balance - 1];
		info.users[_from].list[_index] = _moved;
		info.users[_from].indexOf[_moved] = _index + 1;
		info.users[_from].balance--;
		delete info.users[_from].indexOf[_tokenId];
		uint256 _newIndex = info.users[_to].balance++;
		info.users[_to].indexOf[_tokenId] = _newIndex + 1;
		info.users[_to].list[_newIndex] = _tokenId;
		emit Transfer(_from, _to, _tokenId);
	}


	function _uint2str(uint256 _value) internal pure returns (string memory) {
		uint256 _digits = 1;
		uint256 _n = _value;
		while (_n > 9) {
			_n /= 10;
			_digits++;
		}
		bytes memory _out = new bytes(_digits);
		for (uint256 i = 0; i < _out.length; i++) {
			uint256 _dec = (_value / (10**(_out.length - i - 1))) % 10;
			_out[i] = bytes1(uint8(_dec) + 48);
		}
		return string(_out);
	}

	function _col2str(bytes3 _color) internal pure returns (string memory) {
		bytes memory _out = new bytes(7);
		for (uint256 i = 0; i < _out.length; i++) {
			if (i == 0) {
				_out[i] = bytes1(uint8(35));
			} else {
				uint8 _hex = uint8(uint24(_color >> (4 * (_out.length - i - 1))) & 15);
				_out[i] = bytes1(_hex + (_hex > 9 ? 87 : 48));
			}
		}
		return string(_out);
	}

	function _collerp(bytes3 _color1, bytes3 _color2, uint256 _current, uint256 _limit) public pure returns (bytes3 col) {
		require(_current <= _limit);
		for (uint256 i = 0; i < 3; i++) {
			uint8 _c1 = uint8(uint24(_color1) >> (8 * i));
			uint8 _c2 = uint8(uint24(_color2) >> (8 * i));
			uint8 _diff;
			uint8 _new;
			if (_c2 == _c1) {
				_new = _c1;
			} else if (_c2 > _c1) {
				_diff = _c2 - _c1;
				_new = uint8(_c1 + _diff * _current / _limit);
			} else {
				_diff = _c1 - _c2;
				_new = uint8(_c2 + _diff * (_limit - _current) / _limit);
			}
			col |= bytes3(uint24(_new) << uint24(8 * i));
		}
	}

	function _sqrt(uint256 _n) internal pure returns (uint256 result) {
		uint256 _tmp = (_n + 1) / 2;
		result = _n;
		while (_tmp < result) {
			result = _tmp;
			_tmp = (_n / _tmp + _tmp) / 2;
		}
	}
}