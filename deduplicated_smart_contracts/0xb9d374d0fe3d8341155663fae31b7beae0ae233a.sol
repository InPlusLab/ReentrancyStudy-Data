/**

 *Submitted for verification at Etherscan.io on 2019-04-30

*/



// File: contracts/PriceOracle.sol



pragma solidity >=0.4.24;



interface PriceOracle {

    /**

     * @dev Returns the price to register or renew a name.

     * @param name The name being registered or renewed.

     * @param expires When the name presently expires (0 if this is a new registration).

     * @param duration How long the name is being registered or extended for, in seconds.

     * @return The price of this renewal or registration, in wei.

     */

    function price(string calldata name, uint expires, uint duration) external view returns(uint);

}



// File: contracts/SafeMath.sol



pragma solidity >=0.4.24;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

    * @dev Multiplies two unsigned integers, reverts on overflow.

    */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

    */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

    */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

    * @dev Adds two unsigned integers, reverts on overflow.

    */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

    * reverts when dividing by zero.

    */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: contracts/StringUtils.sol



pragma solidity >=0.4.24;



library StringUtils {

    /**

     * @dev Returns the length of a given string

     *

     * @param s The string to measure the length of

     * @return The length of the input string

     */

    function strlen(string memory s) internal pure returns (uint) {

        uint len;

        uint i = 0;

        uint bytelength = bytes(s).length;

        for(len = 0; i < bytelength; len++) {

            byte b = bytes(s)[i];

            if(b < 0x80) {

                i += 1;

            } else if (b < 0xE0) {

                i += 2;

            } else if (b < 0xF0) {

                i += 3;

            } else if (b < 0xF8) {

                i += 4;

            } else if (b < 0xFC) {

                i += 5;

            } else {

                i += 6;

            }

        }

        return len;

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.0;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * @notice Renouncing to ownership will leave the contract without an owner.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/StablePriceOracle.sol



pragma solidity ^0.5.0;











interface DSValue {

    function read() external view returns (bytes32);

}



// StablePriceOracle sets a price in USD, based on an oracle.

contract StablePriceOracle is Ownable, PriceOracle {

    using SafeMath for *;

    using StringUtils for *;



    // Oracle address

    DSValue usdOracle;



    // Rent in attodollars (1e-18) per second

    uint[] public rentPrices;



    event OracleChanged(address oracle);

    event RentPriceChanged(uint[] prices);



    constructor(DSValue _usdOracle, uint[] memory _rentPrices) public {

        setOracle(_usdOracle);

        setPrices(_rentPrices);

    }



    /**

     * @dev Sets the price oracle address

     * @param _usdOracle The address of the price oracle to use.

     */

    function setOracle(DSValue _usdOracle) public onlyOwner {

        usdOracle = _usdOracle;

        emit OracleChanged(address(_usdOracle));

    }



    /**

     * @dev Sets rent prices.

     * @param _rentPrices The price array. Each element corresponds to a specific

     *                    name length; names longer than the length of the array

     *                    default to the price of the last element.

     */

    function setPrices(uint[] memory _rentPrices) public onlyOwner {

        rentPrices = _rentPrices;

        emit RentPriceChanged(_rentPrices);

    }



    /**

     * @dev Returns the price to register or renew a name.

     * @param name The name being registered or renewed.

     * @param duration How long the name is being registered or extended for, in seconds.

     * @return The price of this renewal or registration, in wei.

     */

    function price(string calldata name, uint /*expires*/, uint duration) view external returns(uint) {

        uint len = name.strlen();

        if(len > rentPrices.length) {

            len = rentPrices.length;

        }

        require(len > 0);

        uint priceUSD = rentPrices[len - 1].mul(duration);



        // Price of one ether in attodollars

        uint ethPrice = uint(usdOracle.read());



        // priceUSD and ethPrice are both fixed-point values with 18dp, so we

        // multiply the numerator by 1e18 before dividing.

        return priceUSD.mul(1e18).div(ethPrice);

    }

}