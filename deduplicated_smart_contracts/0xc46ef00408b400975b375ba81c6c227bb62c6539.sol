/**
 *Submitted for verification at Etherscan.io on 2019-07-04
*/

pragma solidity ^0.5.0;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @return the address of the owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    /**
     * @return true if `msg.sender` is the owner of the contract.
     */
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Allows the current owner to relinquish control of the contract.
     * @notice Renouncing to ownership will leave the contract without an owner.
     * It will not be possible to call the functions with the `onlyOwner`
     * modifier anymore.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

pragma solidity ^0.5.0;

/**
 * @title Roles
 * @dev Library for managing addresses assigned to a Role.
 */
library Roles {
    struct Role {
        mapping (address => bool) bearer;
    }

    /**
     * @dev give an account access to this role
     */
    function add(Role storage role, address account) internal {
        require(account != address(0));
        require(!has(role, account));

        role.bearer[account] = true;
    }

    /**
     * @dev remove an account's access to this role
     */
    function remove(Role storage role, address account) internal {
        require(account != address(0));
        require(has(role, account));

        role.bearer[account] = false;
    }

    /**
     * @dev check if an account has this role
     * @return bool
     */
    function has(Role storage role, address account) internal view returns (bool) {
        require(account != address(0));
        return role.bearer[account];
    }
}

pragma solidity ^0.5.0;


contract PauserRole {
    using Roles for Roles.Role;

    event PauserAdded(address indexed account);
    event PauserRemoved(address indexed account);

    Roles.Role private _pausers;

    constructor () internal {
        _addPauser(msg.sender);
    }

    modifier onlyPauser() {
        require(isPauser(msg.sender));
        _;
    }

    function isPauser(address account) public view returns (bool) {
        return _pausers.has(account);
    }

    function addPauser(address account) public onlyPauser {
        _addPauser(account);
    }

    function renouncePauser() public {
        _removePauser(msg.sender);
    }

    function _addPauser(address account) internal {
        _pausers.add(account);
        emit PauserAdded(account);
    }

    function _removePauser(address account) internal {
        _pausers.remove(account);
        emit PauserRemoved(account);
    }
}

pragma solidity ^0.5.0;


/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is PauserRole {
    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    constructor () internal {
        _paused = false;
    }

    /**
     * @return true if the contract is paused, false otherwise.
     */
    function paused() public view returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
        require(!_paused);
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     */
    modifier whenPaused() {
        require(_paused);
        _;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() public onlyPauser whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() public onlyPauser whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }
}

pragma solidity ^0.5.0;

/**
 * @title Elliptic curve signature operations
 * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
 * TODO Remove this library once solidity supports passing a signature to ecrecover.
 * See https://github.com/ethereum/solidity/issues/864
 */

library ECDSA {
    /**
     * @dev Recover signer address from a message by using their signature
     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
     * @param signature bytes signature, the signature is generated using web3.eth.sign()
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        // Check the signature length
        if (signature.length != 65) {
            return (address(0));
        }

        // Divide the signature in r, s and v variables
        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
        if (v < 27) {
            v += 27;
        }

        // If the version is correct return the signer address
        if (v != 27 && v != 28) {
            return (address(0));
        } else {
            return ecrecover(hash, v, r, s);
        }
    }

    /**
     * toEthSignedMessageHash
     * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"
     * and hash the result
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}

pragma solidity ^0.5.0;

/**
 * §£§Ñ§Ý§Ú§Õ§Ñ§ä§à§â§í
 */

contract ValidationUtil {
    function requireNotEmptyAddress(address value) internal view{
        require(isAddressNotEmpty(value));
    }

    function isAddressNotEmpty(address value) internal view returns (bool result){
        return value != address(0x0);
    }
}

pragma solidity ^0.5.0;

/**
 * §¬§à§ß§ä§â§Ñ§Ü§ä §ê§Ñ§ç§ä
 */

contract ImpMine is Ownable, Pausable, ValidationUtil {
    using ECDSA for bytes32;

    /* §¡§Ü§Ü, §Ü§å§Õ§Ñ §á§Ö§â§Ö§Ó§à§Õ§ñ§ä§ã§ñ §ã§â§Ö§Õ§ã§ä§Ó§Ñ */
    address payable private _destinationWallet;

    /* §®§Ñ§á§Ñ §å§Ø§Ö §ã§à§Ó§Ö§â§ê§Ö§ß§ß§í§ç §Ñ§á§Ô§â§Ö§Û§Õ§à§Ó, §ç§ï§ê: §Ñ§Ü§Ü §á§à§Ý§î§Ù§à§Ó§Ñ§ä§Ö§Ý§ñ + id §ê§Ñ§ç§ä§í + level */
    mapping (bytes32 => bool) private _userUpgrades;

    /* §®§Ñ§á§Ñ §ã§ä§à§Ú§Þ§à§ã§ä§Ö§Û §Ñ§Ô§â§Ö§Û§Õ§Ñ: level => wei */
    mapping (uint => uint) private _upgradePrices;

    /* §³§à§Ò§í§ä§Ú§Ö §Ñ§á§Ô§â§Ö§Û§Õ§Ñ §ê§Ñ§ç§ä§í */
    event MineUpgraded(address receiver, uint mineId, uint level, uint buyPrice);

    function upgrade(uint mineId, uint level, bytes calldata signature) external payable validDestinationWallet whenNotPaused {
        // 0 §ã§å§Þ§Þ§í - §ß§Ö §á§â§Ú§ß§Ú§Þ§Ñ§Ö§Þ
        require(msg.value != 0);

        // §¡§Ü§Ü §á§à§Ý§î§Ù§à§Ó§Ñ§ä§Ö§Ý§ñ, id §ê§Ñ§ç§ä§í, §å§â§à§Ó§Ö§ß§î §Ñ§á§Ô§â§Ö§Û§Õ§Ñ
        bytes32 validatingHash = keccak256(abi.encodePacked(msg.sender, mineId, level));

        // §±§à§Õ§á§Ú§ã§í§Ó§Ñ§ä§î §Ó§ã§Ö §ä§â§Ñ§ß§Ù§Ñ§Ü§è§Ú§Ú §Õ§à§Ý§Ø§Ö§ß owner
        address addressRecovered = validatingHash.toEthSignedMessageHash().recover(signature);
        require(addressRecovered == owner());

        // §±§â§à§Ó§Ö§â§ñ§Þ, §Ò§í§Ý §Ý§Ú §å§Ø§Ö §Ñ§á§Ô§â§Ö§Û§Õ?
        require(!_userUpgrades[validatingHash]);

        //§±§â§à§Ó§Ö§â§ñ§Ö§Þ §å§ã§ä§Ñ§ß§à§Ó§Ý§Ö§ß§ß§å§ð §ã§å§Þ§Þ§å §Ó §Ñ§á§Ô§â§Ö§Û§Õ§Ö
        require(_upgradePrices[level] == msg.value);

        // §¥§Ö§Ý§Ñ§Ö§Þ §á§Ö§â§Ö§Ó§à§Õ §á§à§Ý§å§é§Ñ§ä§Ö§Ý§ð, §Ó §ã§Ý§å§é§Ñ§Ö §ß§Ö§å§Õ§Ñ§é§Ú §Ò§å§Õ§Ö§ä throws
        _destinationWallet.transfer(msg.value);

        _userUpgrades[validatingHash] = true;

        emit MineUpgraded(msg.sender, mineId, level, msg.value);
    }

    function isUserUpgraded(address userAddress, uint mineId, uint level) public view returns (bool) {
        return _userUpgrades[keccak256(abi.encodePacked(userAddress, mineId, level))];
    }

    function setUpgradePrice(uint level, uint price) external onlyOwner {
        // 0 §ã§å§Þ§Þ§í - §ß§Ö §á§â§Ú§ß§Ú§Þ§Ñ§Ö§Þ
        require(price != 0);

        _upgradePrices[level] = price;
    }

    function getUpgradePrice(uint level) public view returns (uint) {
        return _upgradePrices[level];
    }

    function setDestinationWallet(address payable walletAddress) external onlyOwner {
        requireNotEmptyAddress(walletAddress);

        _destinationWallet = walletAddress;
    }

    function getDestinationWallet() public view returns (address) {
        return _destinationWallet;
    }

    modifier validDestinationWallet() {
        requireNotEmptyAddress(_destinationWallet);
        _;
    }
}