/**

 *Submitted for verification at Etherscan.io on 2019-06-12

*/



pragma solidity ^0.5.0;



pragma solidity ^0.5.0;



/// @title ERC-721 Non-Fungible Token Standard

/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md

///  Note: the ERC-165 identifier for this interface is 0x6466353c

interface ERC721Proxy /*is ERC165*/ {



    /// @notice Query if a contract implements an interface

    /// @param interfaceID The interface identifier, as specified in ERC-165

    /// @dev Interface identification is specified in ERC-165. This function

    ///  uses less than 30,000 gas.

    /// @return `true` if the contract implements `interfaceID` and

    ///  `interfaceID` is not 0xffffffff, `false` otherwise

    function supportsInterface(bytes4 interfaceID) external view returns (bool);



    /// @dev This emits when ownership of any NFT changes by any mechanism.

    ///  This event emits when NFTs are created (`from` == 0) and destroyed

    ///  (`to` == 0). Exception: during contract creation, any number of NFTs

    ///  may be created and assigned without emitting Transfer. At the time of

    ///  any transfer, the approved address for that NFT (if any) is reset to none.

    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);



    /// @dev This emits when the approved address for an NFT is changed or

    ///  reaffirmed. The zero address indicates there is no approved address.

    ///  When a Transfer event emits, this also indicates that the approved

    ///  address for that NFT (if any) is reset to none.

    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);



    /// @dev This emits when an operator is enabled or disabled for an owner.

    ///  The operator can manage all NFTs of the owner.

    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);



    /// @notice Count all NFTs assigned to an owner

    /// @dev NFTs assigned to the zero address are considered invalid, and this

    ///  function throws for queries about the zero address.

    /// @param _owner An address for whom to query the balance

    /// @return The number of NFTs owned by `_owner`, possibly zero

    function balanceOf(address _owner) external view returns (uint256);



    /// @notice Find the owner of an NFT

    /// @param _tokenId The identifier for an NFT

    /// @dev NFTs assigned to zero address are considered invalid, and queries

    ///  about them do throw.

    /// @return The address of the owner of the NFT

    function ownerOf(uint256 _tokenId) external view returns (address);



    /// @notice Transfers the ownership of an NFT from one address to another address

    /// @dev Throws unless `msg.sender` is the current owner, an authorized

    ///  operator, or the approved address for this NFT. Throws if `_from` is

    ///  not the current owner. Throws if `_to` is the zero address. Throws if

    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function

    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls

    ///  `onERC721Received` on `_to` and throws if the return value is not

    ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.

    /// @param _from The current owner of the NFT

    /// @param _to The new owner

    /// @param _tokenId The NFT to transfer

    /// @param data Additional data with no specified format, sent in call to `_to`

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;



    /// @notice Transfers the ownership of an NFT from one address to another address

    /// @dev This works identically to the other function with an extra data parameter,

    ///  except this function just sets data to ""

    /// @param _from The current owner of the NFT

    /// @param _to The new owner

    /// @param _tokenId The NFT to transfer

    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;



    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE

    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE

    ///  THEY MAY BE PERMANENTLY LOST

    /// @dev Throws unless `msg.sender` is the current owner, an authorized

    ///  operator, or the approved address for this NFT. Throws if `_from` is

    ///  not the current owner. Throws if `_to` is the zero address. Throws if

    ///  `_tokenId` is not a valid NFT.

    /// @param _from The current owner of the NFT

    /// @param _to The new owner

    /// @param _tokenId The NFT to transfer

    function transferFrom(address _from, address _to, uint256 _tokenId) external;



    /// @notice Set or reaffirm the approved address for an NFT

    /// @dev The zero address indicates there is no approved address.

    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized

    ///  operator of the current owner.

    /// @param _approved The new approved NFT controller

    /// @param _tokenId The NFT to approve

    function approve(address _approved, uint256 _tokenId) external;



    /// @notice Enable or disable approval for a third party ("operator") to manage

    ///  all your asset.

    /// @dev Emits the ApprovalForAll event

    /// @param _operator Address to add to the set of authorized operators.

    /// @param _approved True if the operators is approved, false to revoke approval

    function setApprovalForAll(address _operator, bool _approved) external;



    /// @notice Get the approved address for a single NFT

    /// @dev Throws if `_tokenId` is not a valid NFT

    /// @param _tokenId The NFT to find the approved address for

    /// @return The approved address for this NFT, or the zero address if there is none

    function getApproved(uint256 _tokenId) external view returns (address);



    /// @notice Query if an address is an authorized operator for another address

    /// @param _owner The address that owns the NFTs

    /// @param _operator The address that acts on behalf of the owner

    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise

    function isApprovedForAll(address _owner, address _operator) external view returns (bool);





    /// @notice A descriptive name for a collection of NFTs in this contract

    function name() external view returns (string memory _name);



    /// @notice An abbreviated name for NFTs in this contract

    function symbol() external view returns (string memory _symbol);





    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.

    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC

    ///  3986. The URI may point to a JSON file that conforms to the "ERC721

    ///  Metadata JSON Schema".

    function tokenURI(uint256 _tokenId) external view returns (string memory);



    /// @notice Count NFTs tracked by this contract

    /// @return A count of valid NFTs tracked by this contract, where each one of

    ///  them has an assigned and queryable owner not equal to the zero address

    function totalSupply() external view returns (uint256);



    /// @notice Enumerate valid NFTs

    /// @dev Throws if `_index` >= `totalSupply()`.

    /// @param _index A counter less than `totalSupply()`

    /// @return The token identifier for the `_index`th NFT,

    ///  (sort order not specified)

    function tokenByIndex(uint256 _index) external view returns (uint256);



    /// @notice Enumerate NFTs assigned to an owner

    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if

    ///  `_owner` is the zero address, representing invalid NFTs.

    /// @param _owner An address where we are interested in NFTs owned by them

    /// @param _index A counter less than `balanceOf(_owner)`

    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,

    ///   (sort order not specified)

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);



    /// @notice Transfers a Token to another address. When transferring to a smart

    ///  contract, ensure that it is aware of ERC-721, otherwise the Token may be lost forever.

    /// @param _to The address of the recipient, can be a user or contract.

    /// @param _tokenId The ID of the Token to transfer.

    function transfer(address _to, uint256 _tokenId) external;



    function onTransfer(address _from, address _to, uint256 _nftIndex) external;

}



pragma solidity ^0.5.0;



/// @title BlockchainCuties: Collectible and breedable cuties on the Ethereum blockchain.

/// @author https://BlockChainArchitect.io

interface UriProviderInterface

{

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.

    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC

    ///  3986. The URI may point to a JSON file that conforms to the "ERC721

    ///  Metadata JSON Schema".

    function tokenURI(uint256 _tokenId) external view returns (string memory infoUrl);

}



pragma solidity ^0.5.0;



interface BlockchainCutiesERC1155Interface

{

    function mintNonFungibleSingleShort(uint128 _type, address _to) external;

    function mintNonFungibleSingle(uint256 _type, address _to) external;

    function mintNonFungibleShort(uint128 _type, address[] calldata _to) external;

    function mintNonFungible(uint256 _type, address[] calldata _to) external;

    function mintFungibleSingle(uint256 _id, address _to, uint256 _quantity) external;

    function mintFungible(uint256 _id, address[] calldata _to, uint256[] calldata _quantities) external;

    function isNonFungible(uint256 _id) external pure returns(bool);

    function ownerOf(uint256 _id) external view returns (address);

    function totalSupplyNonFungible(uint256 _type) view external returns (uint256);

    function totalSupplyNonFungibleShort(uint128 _type) view external returns (uint256);



    /**

        @notice A distinct Uniform Resource Identifier (URI) for a given token.

        @dev URIs are defined in RFC 3986.

        The URI may point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".

        @return URI string

    */

    function uri(uint256 _id) external view returns (string memory);

    function proxyTransfer721(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

    function proxyTransfer20(address _from, address _to, uint256 _tokenId, uint256 _value) external;

    /**

        @notice Get the balance of an account's Tokens.

        @param _owner  The address of the token holder

        @param _id     ID of the Token

        @return        The _owner's balance of the Token type requested

     */

    function balanceOf(address _owner, uint256 _id) external view returns (uint256);

    /**

        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).

        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard).

        MUST revert if `_to` is the zero address.

        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.

        MUST revert on any other error.

        MUST emit the `TransferSingle` event to reflect the balance change (see "Safe Transfer Rules" section of the standard).

        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).

        @param _from    Source address

        @param _to      Target address

        @param _id      ID of the token type

        @param _value   Transfer amount

        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`

    */

    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;

}



pragma solidity ^0.5.0;



contract Operators

{

    mapping (address=>bool) ownerAddress;

    mapping (address=>bool) operatorAddress;



    constructor() public

    {

        ownerAddress[msg.sender] = true;

    }



    modifier onlyOwner()

    {

        require(ownerAddress[msg.sender]);

        _;

    }



    function isOwner(address _addr) public view returns (bool) {

        return ownerAddress[_addr];

    }



    function addOwner(address _newOwner) external onlyOwner {

        require(_newOwner != address(0));



        ownerAddress[_newOwner] = true;

    }



    function removeOwner(address _oldOwner) external onlyOwner {

        delete(ownerAddress[_oldOwner]);

    }



    modifier onlyOperator() {

        require(isOperator(msg.sender));

        _;

    }



    function isOperator(address _addr) public view returns (bool) {

        return operatorAddress[_addr] || ownerAddress[_addr];

    }



    function addOperator(address _newOperator) external onlyOwner {

        require(_newOperator != address(0));



        operatorAddress[_newOperator] = true;

    }



    function removeOperator(address _oldOperator) external onlyOwner {

        delete(operatorAddress[_oldOperator]);

    }

}





contract Proxy721_1155 is ERC721Proxy, Operators {



    BlockchainCutiesERC1155Interface public erc1155;

    UriProviderInterface public uriProvider;

    uint256 public nftType;

    string public nftName;

    string public nftSymbol;

    bool public canSetup = true;



    // The top bit is a flag to tell if this is a NFI.

    uint256 constant public TYPE_NF_BIT = 1 << 255;



    modifier canBeStoredIn128Bits(uint256 _value)

    {

        require(_value <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);

        _;

    }



    function setup(

        BlockchainCutiesERC1155Interface _erc1155,

        UriProviderInterface _uriProvider,

        uint256 _nftType,

        string calldata _nftSymbol,

        string calldata _nftName) external onlyOwner canBeStoredIn128Bits(_nftType)

    {

        require(canSetup);

        erc1155 = _erc1155;

        uriProvider = _uriProvider;

        nftType = (_nftType << 128) | TYPE_NF_BIT;

        nftSymbol = _nftSymbol;

        nftName = _nftName;

    }



    function disableSetup() external onlyOwner

    {

        canSetup = false;

    }



    /// @notice A descriptive name for a collection of NFTs in this contract

    function name() external view returns (string memory)

    {

        return nftName;

    }



    /// @notice An abbreviated name for NFTs in this contract

    function symbol() external view returns (string memory)

    {

        return nftSymbol;

    }



    /// @notice Count all NFTs assigned to an owner

    /// @dev NFTs assigned to the zero address are considered invalid, and this

    ///  function throws for queries about the zero address.

    /// @param _owner An address for whom to query the balance

    /// @return The number of NFTs owned by `_owner`, possibly zero

    function balanceOf(address _owner) external view returns (uint256 balance)

    {

        require(_owner != address(0x0));

        balance = 0;

        uint total = erc1155.totalSupplyNonFungible(nftType);

        for (uint index = 1; index <= total; index++)

        {

            if (_ownerOf(index) == _owner)

            {

                balance++;

            }

        }

    }



    /// @notice Find the owner of an NFT

    /// @param _tokenIndex The index for an NFT with type nftType

    /// @dev NFTs assigned to zero address are considered invalid, and queries

    ///  about them do throw.

    /// @return The address of the owner of the NFT

    function ownerOf(uint256 _tokenIndex) external view returns (address)

    {

        return _ownerOf(_tokenIndex);

    }



    function _ownerOf(uint256 _tokenIndex) internal view returns (address)

    {

        return erc1155.ownerOf(_indexToId(_tokenIndex));

    }



    function _indexToId(uint256 _tokenIndex) internal view canBeStoredIn128Bits(_tokenIndex) returns (uint256)

    {

        return nftType | _tokenIndex;

    }



    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.

    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC

    ///  3986. The URI may point to a JSON file that conforms to the "ERC721

    ///  Metadata JSON Schema".

    function tokenURI(uint256 _tokenIndex) external view canBeStoredIn128Bits(_tokenIndex) returns (string memory)

    {

        return uriProvider.tokenURI(_tokenIndex);

    }



    /// @notice Count NFTs tracked by this contract

    /// @return A count of valid NFTs tracked by this contract, where each one of

    ///  them has an assigned and queryable owner not equal to the zero address

    function totalSupply() external view returns (uint256)

    {

        return _totalSupply();

    }



    function _totalSupply() internal view returns (uint256)

    {

        return erc1155.totalSupplyNonFungible(nftType);

    }



    /// @notice Enumerate valid NFTs

    /// @dev Throws if `_index` >= `totalSupply()`.

    /// @param _index A counter less than `totalSupply()`

    /// @return The token identifier for the `_index`th NFT,

    ///  (sort order not specified)

    function tokenByIndex(uint256 _index) external view returns (uint256)

    {

        require(_index < _totalSupply());

        return _index - 1;

    }



    /// @notice Enumerate NFTs assigned to an owner

    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if

    ///  `_owner` is the zero address, representing invalid NFTs.

    /// @param _owner An address where we are interested in NFTs owned by them

    /// @param _index A counter less than `balanceOf(_owner)`

    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,

    ///   (sort order not specified)

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenIndex)

    {

        require(_owner != address(0x0));

        uint40 count = 0;

        for (uint40 i = 1; i <= _totalSupply(); ++i) {

            if (_ownerOf(i) == _owner) {

                if (count == _index) {

                    return i;

                } else {

                    count++;

                }

            }

        }

        revert();

    }



    /// @notice Transfers a Token to another address. When transferring to a smart

    ///  contract, ensure that it is aware of ERC-721,

    /// otherwise the Token may be lost forever.

    /// @param _to The address of the recipient, can be a user or contract.

    /// @param _tokenIndex The ID of the Token to transfer.

    function transfer(address _to, uint256 _tokenIndex) external

    {

        _transfer(msg.sender, _to, _tokenIndex, "");

    }



    function _transfer(address _from, address _to, uint256 _tokenIndex, bytes memory data) internal

    {

        erc1155.proxyTransfer721(_from, _to, _indexToId(_tokenIndex), data);

    }



    function onTransfer(address _from, address _to, uint256 _nftIndex) external {

        require(msg.sender == address(erc1155));

        emit Transfer(_from, _to, _nftIndex);

    }



    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Metadata =

        bytes4(keccak256('name()')) ^

        bytes4(keccak256('symbol()')) ^

        bytes4(keccak256('tokenURI(uint256)'));



    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Enumerable =

        bytes4(keccak256('totalSupply()')) ^

        bytes4(keccak256('tokenByIndex(uint256)')) ^

        bytes4(keccak256('tokenOfOwnerByIndex(address, uint256)'));



    function supportsInterface(bytes4 interfaceID) external view returns (bool) {

        return

        interfaceID == 0x6466353c ||

        interfaceID == 0x80ac58cd || // ERC721

        interfaceID == INTERFACE_SIGNATURE_ERC721Metadata ||

        interfaceID == INTERFACE_SIGNATURE_ERC721Enumerable ||

        interfaceID == bytes4(keccak256('supportsInterface(bytes4)'));

    }



    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external {

        _transfer(_from, _to, _tokenId, data);

    }



    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {

        _transfer(_from, _to, _tokenId, "");

    }



    function transferFrom(address _from, address _to, uint256 _tokenId) external {

        _transfer(_from, _to, _tokenId, "");

    }



    function approve(address, uint256) external {

        revert();

    }



    function setApprovalForAll(address, bool) external {

        revert();

    }



    function getApproved(uint256) external view returns (address) {

        return address(0x0);

    }



    function isApprovedForAll(address, address) external view returns (bool) {

        return false;

    }

}