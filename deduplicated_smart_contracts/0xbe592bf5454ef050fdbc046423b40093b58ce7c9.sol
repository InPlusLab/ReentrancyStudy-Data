/**

 *Submitted for verification at Etherscan.io on 2019-05-15

*/



pragma solidity ^0.5.2;



/**

 * @title ERC20 interface

 * @dev see https://eips.ethereum.org/EIPS/eip-20

 */

interface IERC20 {

    function transfer(address to, uint256 value) external returns (bool);



    function approve(address spender, uint256 value) external returns (bool);



    function transferFrom(address from, address to, uint256 value) external returns (bool);



    function totalSupply() external view returns (uint256);



    function balanceOf(address who) external view returns (uint256);



    function allowance(address owner, address spender) external view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);

}



/**

 * @title ERC20Detailed token

 * @dev The decimals are only for visualization purposes.

 * All the operations are done using the smallest and indivisible token unit,

 * just as on Ethereum all the operations are done in wei.

 */

contract ERC20Detailed is IERC20 {

    string private _name;

    string private _symbol;

    uint8 private _decimals;



    constructor (string memory name, string memory symbol, uint8 decimals) public {

        _name = name;

        _symbol = symbol;

        _decimals = decimals;

    }



    /**

     * @return the name of the token.

     */

    function name() public view returns (string memory) {

        return _name;

    }



    /**

     * @return the symbol of the token.

     */

    function symbol() public view returns (string memory) {

        return _symbol;

    }



    /**

     * @return the number of decimals of the token.

     */

    function decimals() public view returns (uint8) {

        return _decimals;

    }

}



/**

 * Utility library of inline functions on addresses

 */

library Address {

    /**

     * Returns whether the target address is a contract

     * @dev This function will return false if invoked during the constructor of a contract,

     * as the code is not actually created until after the constructor finishes.

     * @param account address of the account to check

     * @return whether the target address is a contract

     */

    function isContract(address account) internal view returns (bool) {

        uint256 size;

        // XXX Currently there is no better way to check if there is a contract in an address

        // than to check the size of the code at that address.

        // See https://ethereum.stackexchange.com/a/14016/36603

        // for more details about how this works.

        // TODO Check this again before the Serenity release, because all addresses will be

        // contracts then.

        // solhint-disable-next-line no-inline-assembly

        assembly { size := extcodesize(account) }

        return size > 0;

    }

}



/**

 * @title ERC165Checker

 * @dev Use `using ERC165Checker for address`; to include this library

 * https://eips.ethereum.org/EIPS/eip-165

 */

library ERC165Checker {

    // As per the EIP-165 spec, no interface should ever match 0xffffffff

    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;



    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /*

     * 0x01ffc9a7 ===

     *     bytes4(keccak256('supportsInterface(bytes4)'))

     */



    /**

     * @notice Query if a contract supports ERC165

     * @param account The address of the contract to query for support of ERC165

     * @return true if the contract at account implements ERC165

     */

    function _supportsERC165(address account) internal view returns (bool) {

        // Any contract that implements ERC165 must explicitly indicate support of

        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid

        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&

            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);

    }



    /**

     * @notice Query if a contract implements an interface, also checks support of ERC165

     * @param account The address of the contract to query for support of an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @return true if the contract at account indicates support of the interface with

     * identifier interfaceId, false otherwise

     * @dev Interface identification is specified in ERC-165.

     */

    function _supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {

        // query support of both ERC165 as per the spec and support of _interfaceId

        return _supportsERC165(account) &&

            _supportsERC165Interface(account, interfaceId);

    }



    /**

     * @notice Query if a contract implements interfaces, also checks support of ERC165

     * @param account The address of the contract to query for support of an interface

     * @param interfaceIds A list of interface identifiers, as specified in ERC-165

     * @return true if the contract at account indicates support all interfaces in the

     * interfaceIds list, false otherwise

     * @dev Interface identification is specified in ERC-165.

     */

    function _supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {

        // query support of ERC165 itself

        if (!_supportsERC165(account)) {

            return false;

        }



        // query support of each interface in _interfaceIds

        for (uint256 i = 0; i < interfaceIds.length; i++) {

            if (!_supportsERC165Interface(account, interfaceIds[i])) {

                return false;

            }

        }



        // all interfaces supported

        return true;

    }



    /**

     * @notice Query if a contract implements an interface, does not check ERC165 support

     * @param account The address of the contract to query for support of an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @return true if the contract at account indicates support of the interface with

     * identifier interfaceId, false otherwise

     * @dev Assumes that account contains a contract that supports ERC165, otherwise

     * the behavior of this method is undefined. This precondition can be checked

     * with the `supportsERC165` method in this library.

     * Interface identification is specified in ERC-165.

     */

    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {

        // success determines whether the staticcall succeeded and result determines

        // whether the contract at account indicates support of _interfaceId

        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);



        return (success && result);

    }



    /**

     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw

     * @param account The address of the contract to query for support of an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @return success true if the STATICCALL succeeded, false otherwise

     * @return result true if the STATICCALL succeeded and the contract at account

     * indicates support of the interface with identifier interfaceId, false otherwise

     */

    function _callERC165SupportsInterface(address account, bytes4 interfaceId)

        private

        view

        returns (bool success, bool result)

    {

        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);



        // solhint-disable-next-line no-inline-assembly

        assembly {

            let encodedParams_data := add(0x20, encodedParams)

            let encodedParams_size := mload(encodedParams)



            let output := mload(0x40)    // Find empty storage location using "free memory pointer"

            mstore(output, 0x0)



            success := staticcall(

                30000,                   // 30k gas

                account,                 // To addr

                encodedParams_data,

                encodedParams_size,

                output,

                0x20                     // Outputs are 32 bytes long

            )



            result := mload(output)      // Load the result

        }

    }

}



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * https://eips.ethereum.org/EIPS/eip-20

 * Originally based on code by FirstBlood:

 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 *

 * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for

 * all accounts just by listening to said events. Note that this isn't required by the specification, and other

 * compliant implementations may not do it.

 */

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowed;



    uint256 private _totalSupply;



    /**

     * @dev Total number of tokens in existence

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev Gets the balance of the specified address.

     * @param owner The address to query the balance of.

     * @return A uint256 representing the amount owned by the passed address.

     */

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    /**

     * @dev Function to check the amount of tokens that an owner allowed to a spender.

     * @param owner address The address which owns the funds.

     * @param spender address The address which will spend the funds.

     * @return A uint256 specifying the amount of tokens still available for the spender.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    /**

     * @dev Transfer token to a specified address

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    /**

     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param spender The address which will spend the funds.

     * @param value The amount of tokens to be spent.

     */

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    /**

     * @dev Transfer tokens from one address to another.

     * Note that while this function emits an Approval event, this is not required as per the specification,

     * and other compliant implementations may not emit the event.

     * @param from address The address which you want to send tokens from

     * @param to address The address which you want to transfer to

     * @param value uint256 the amount of tokens to be transferred

     */

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _transfer(from, to, value);

        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));

        return true;

    }



    /**

     * @dev Increase the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To increment

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param addedValue The amount of tokens to increase the allowance by.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Decrease the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param subtractedValue The amount of tokens to decrease the allowance by.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    /**

     * @dev Transfer token for a specified addresses

     * @param from The address to transfer from.

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    /**

     * @dev Internal function that mints an amount of the token and assigns it to

     * an account. This encapsulates the modification of balances such that the

     * proper events are emitted.

     * @param account The account that will receive the created tokens.

     * @param value The amount that will be created.

     */

    function _mint(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account.

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burn(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    /**

     * @dev Approve an address to spend another addresses' tokens.

     * @param owner The address that owns the tokens.

     * @param spender The address that will spend the tokens.

     * @param value The number of tokens that can be spent.

     */

    function _approve(address owner, address spender, uint256 value) internal {

        require(spender != address(0));

        require(owner != address(0));



        _allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account, deducting from the sender's allowance for said account. Uses the

     * internal burn function.

     * Emits an Approval event (reflecting the reduced allowance).

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burnFrom(address account, uint256 value) internal {

        _burn(account, value);

        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));

    }

}



/**

 * @title IERC165

 * @dev https://eips.ethereum.org/EIPS/eip-165

 */

interface IERC165 {

    /**

     * @notice Query if a contract implements an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @dev Interface identification is specified in ERC-165. This function

     * uses less than 30,000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



/**

 * @title ERC165

 * @author Matt Condon (@shrugs)

 * @dev Implements ERC165 using a lookup table.

 */

contract ERC165 is IERC165 {

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    /*

     * 0x01ffc9a7 ===

     *     bytes4(keccak256('supportsInterface(bytes4)'))

     */



    /**

     * @dev a mapping of interface id to whether or not it's supported

     */

    mapping(bytes4 => bool) private _supportedInterfaces;



    /**

     * @dev A contract implementing SupportsInterfaceWithLookup

     * implement ERC165 itself

     */

    constructor () internal {

        _registerInterface(_INTERFACE_ID_ERC165);

    }



    /**

     * @dev implement supportsInterface(bytes4) using a lookup table

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool) {

        return _supportedInterfaces[interfaceId];

    }



    /**

     * @dev internal method for registering an interface

     */

    function _registerInterface(bytes4 interfaceId) internal {

        require(interfaceId != 0xffffffff);

        _supportedInterfaces[interfaceId] = true;

    }

}



/**

 * @title IERC1363 Interface

 * @author Vittorio Minacori (https://github.com/vittominacori)

 * @dev Interface for a Payable Token contract as defined in

 *  https://github.com/ethereum/EIPs/issues/1363

 */

contract IERC1363 is IERC20, ERC165 {

    /*

     * Note: the ERC-165 identifier for this interface is 0x4bbee2df.

     * 0x4bbee2df ===

     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^

     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^

     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^

     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)'))

     */



    /*

     * Note: the ERC-165 identifier for this interface is 0xfb9ec8ce.

     * 0xfb9ec8ce ===

     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^

     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))

     */



    /**

     * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver

     * @param to address The address which you want to transfer to

     * @param value uint256 The amount of tokens to be transferred

     * @return true unless throwing

     */

    function transferAndCall(address to, uint256 value) public returns (bool);



    /**

     * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver

     * @param to address The address which you want to transfer to

     * @param value uint256 The amount of tokens to be transferred

     * @param data bytes Additional data with no specified format, sent in call to `to`

     * @return true unless throwing

     */

    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool);



    /**

     * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver

     * @param from address The address which you want to send tokens from

     * @param to address The address which you want to transfer to

     * @param value uint256 The amount of tokens to be transferred

     * @return true unless throwing

     */

    function transferFromAndCall(address from, address to, uint256 value) public returns (bool);





    /**

     * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver

     * @param from address The address which you want to send tokens from

     * @param to address The address which you want to transfer to

     * @param value uint256 The amount of tokens to be transferred

     * @param data bytes Additional data with no specified format, sent in call to `to`

     * @return true unless throwing

     */

    function transferFromAndCall(address from, address to, uint256 value, bytes memory data) public returns (bool);



    /**

     * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender

     * and then call `onApprovalReceived` on spender.

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param spender address The address which will spend the funds

     * @param value uint256 The amount of tokens to be spent

     */

    function approveAndCall(address spender, uint256 value) public returns (bool);



    /**

     * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender

     * and then call `onApprovalReceived` on spender.

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param spender address The address which will spend the funds

     * @param value uint256 The amount of tokens to be spent

     * @param data bytes Additional data with no specified format, sent in call to `spender`

     */

    function approveAndCall(address spender, uint256 value, bytes memory data) public returns (bool);

}



/**

 * @title IERC1363Receiver Interface

 * @author Vittorio Minacori (https://github.com/vittominacori)

 * @dev Interface for any contract that wants to support transferAndCall or transferFromAndCall

 *  from ERC1363 token contracts as defined in

 *  https://github.com/ethereum/EIPs/issues/1363

 */

contract IERC1363Receiver {

    /*

     * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.

     * 0x88a7ca5c === bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))

     */



    /**

     * @notice Handle the receipt of ERC1363 tokens

     * @dev Any ERC1363 smart contract calls this function on the recipient

     * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the

     * transfer. Return of other than the magic value MUST result in the

     * transaction being reverted.

     * Note: the token contract address is always the message sender.

     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function

     * @param from address The address which are token transferred from

     * @param value uint256 The amount of tokens transferred

     * @param data bytes Additional data with no specified format

     * @return `bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))`

     *  unless throwing

     */

    function onTransferReceived(address operator, address from, uint256 value, bytes memory data) public returns (bytes4); // solhint-disable-line  max-line-length

}



/**

 * @title IERC1363Spender Interface

 * @author Vittorio Minacori (https://github.com/vittominacori)

 * @dev Interface for any contract that wants to support approveAndCall

 *  from ERC1363 token contracts as defined in

 *  https://github.com/ethereum/EIPs/issues/1363

 */

contract IERC1363Spender {

    /*

     * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.

     * 0x7b04a2d0 === bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))

     */



    /**

     * @notice Handle the approval of ERC1363 tokens

     * @dev Any ERC1363 smart contract calls this function on the recipient

     * after an `approve`. This function MAY throw to revert and reject the

     * approval. Return of other than the magic value MUST result in the

     * transaction being reverted.

     * Note: the token contract address is always the message sender.

     * @param owner address The address which called `approveAndCall` function

     * @param value uint256 The amount of tokens to be spent

     * @param data bytes Additional data with no specified format

     * @return `bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))`

     *  unless throwing

     */

    function onApprovalReceived(address owner, uint256 value, bytes memory data) public returns (bytes4);

}



/**

 * @title ERC1363

 * @author Vittorio Minacori (https://github.com/vittominacori)

 * @dev Implementation of an ERC1363 interface

 */

contract ERC1363 is ERC20, IERC1363 {

    using Address for address;



    /*

     * Note: the ERC-165 identifier for this interface is 0x4bbee2df.

     * 0x4bbee2df ===

     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^

     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^

     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^

     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)'))

     */

    bytes4 internal constant _INTERFACE_ID_ERC1363_TRANSFER = 0x4bbee2df;



    /*

     * Note: the ERC-165 identifier for this interface is 0xfb9ec8ce.

     * 0xfb9ec8ce ===

     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^

     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))

     */

    bytes4 internal constant _INTERFACE_ID_ERC1363_APPROVE = 0xfb9ec8ce;



    // Equals to `bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))`

    // which can be also obtained as `IERC1363Receiver(0).onTransferReceived.selector`

    bytes4 private constant _ERC1363_RECEIVED = 0x88a7ca5c;



    // Equals to `bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))`

    // which can be also obtained as `IERC1363Spender(0).onApprovalReceived.selector`

    bytes4 private constant _ERC1363_APPROVED = 0x7b04a2d0;



    constructor() public {

        // register the supported interfaces to conform to ERC1363 via ERC165

        _registerInterface(_INTERFACE_ID_ERC1363_TRANSFER);

        _registerInterface(_INTERFACE_ID_ERC1363_APPROVE);

    }



    function transferAndCall(address to, uint256 value) public returns (bool) {

        return transferAndCall(to, value, "");

    }



    function transferAndCall(address to, uint256 value, bytes memory data) public returns (bool) {

        require(transfer(to, value));

        require(_checkAndCallTransfer(msg.sender, to, value, data));

        return true;

    }



    function transferFromAndCall(address from, address to, uint256 value) public returns (bool) {

        return transferFromAndCall(from, to, value, "");

    }



    function transferFromAndCall(address from, address to, uint256 value, bytes memory data) public returns (bool) {

        require(transferFrom(from, to, value));

        require(_checkAndCallTransfer(from, to, value, data));

        return true;

    }



    function approveAndCall(address spender, uint256 value) public returns (bool) {

        return approveAndCall(spender, value, "");

    }



    function approveAndCall(address spender, uint256 value, bytes memory data) public returns (bool) {

        approve(spender, value);

        require(_checkAndCallApprove(spender, value, data));

        return true;

    }



    /**

     * @dev Internal function to invoke `onTransferReceived` on a target address

     *  The call is not executed if the target address is not a contract

     * @param from address Representing the previous owner of the given token value

     * @param to address Target address that will receive the tokens

     * @param value uint256 The amount mount of tokens to be transferred

     * @param data bytes Optional data to send along with the call

     * @return whether the call correctly returned the expected magic value

     */

    function _checkAndCallTransfer(address from, address to, uint256 value, bytes memory data) internal returns (bool) {

        if (!to.isContract()) {

            return false;

        }

        bytes4 retval = IERC1363Receiver(to).onTransferReceived(

            msg.sender, from, value, data

        );

        return (retval == _ERC1363_RECEIVED);

    }



    /**

     * @dev Internal function to invoke `onApprovalReceived` on a target address

     *  The call is not executed if the target address is not a contract

     * @param spender address The address which will spend the funds

     * @param value uint256 The amount of tokens to be spent

     * @param data bytes Optional data to send along with the call

     * @return whether the call correctly returned the expected magic value

     */

    function _checkAndCallApprove(address spender, uint256 value, bytes memory data) internal returns (bool) {

        if (!spender.isContract()) {

            return false;

        }

        bytes4 retval = IERC1363Spender(spender).onApprovalReceived(

            msg.sender, value, data

        );

        return (retval == _ERC1363_APPROVED);

    }

}



contract YVRToken is ERC20Detailed, ERC1363 {

  uint256 private INITIAL_SUPPLY = uint256(uint256(300000000) * uint256(1000000000000000000));



  constructor(string memory name,  string memory symbol,  uint8 decimals)

    ERC20Detailed(name, symbol, decimals)

    ERC1363()

  public

  {

    _mint(msg.sender, INITIAL_SUPPLY);

  }

}