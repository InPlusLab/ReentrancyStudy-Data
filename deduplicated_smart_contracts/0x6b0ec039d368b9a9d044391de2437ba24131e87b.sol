/**

 *Submitted for verification at Etherscan.io on 2019-07-10

*/



/*

 * Crypto stamp colors storage

 * Store colors for connected physical assets

 *

 * Developed by capacity.at

 * for post.at

 */



// File: openzeppelin-solidity/contracts/introspection/IERC165.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC165 standard, as defined in the

 * [EIP](https://eips.ethereum.org/EIPS/eip-165).

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others (`ERC165Checker`).

 *

 * For an implementation, see `ERC165`.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol



pragma solidity ^0.5.0;





/**

 * @dev Required interface of an ERC721 compliant contract.

 */

contract IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of NFTs in `owner`'s account.

     */

    function balanceOf(address owner) public view returns (uint256 balance);



    /**

     * @dev Returns the owner of the NFT specified by `tokenId`.

     */

    function ownerOf(uint256 tokenId) public view returns (address owner);



    /**

     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to

     * another (`to`).

     *

     * 

     *

     * Requirements:

     * - `from`, `to` cannot be zero.

     * - `tokenId` must be owned by `from`.

     * - If the caller is not `from`, it must be have been allowed to move this

     * NFT by either `approve` or `setApproveForAll`.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) public;

    /**

     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to

     * another (`to`).

     *

     * Requirements:

     * - If the caller is not `from`, it must be approved to move this NFT by

     * either `approve` or `setApproveForAll`.

     */

    function transferFrom(address from, address to, uint256 tokenId) public;

    function approve(address to, uint256 tokenId) public;

    function getApproved(uint256 tokenId) public view returns (address operator);



    function setApprovalForAll(address operator, bool _approved) public;

    function isApprovedForAll(address owner, address operator) public view returns (bool);





    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol



pragma solidity ^0.5.0;





/**

 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721Enumerable is IERC721 {

    function totalSupply() public view returns (uint256);

    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);



    function tokenByIndex(uint256 index) public view returns (uint256);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol



pragma solidity ^0.5.0;





/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721Metadata is IERC721 {

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function tokenURI(uint256 tokenId) external view returns (string memory);

}



// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Full.sol



pragma solidity ^0.5.0;









/**

 * @title ERC-721 Non-Fungible Token Standard, full implementation interface

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

contract IERC721Full is IERC721, IERC721Enumerable, IERC721Metadata {

    // solhint-disable-previous-line no-empty-blocks

}



// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.0;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see `ERC20Detailed`.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a `Transfer` event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through `transferFrom`. This is

     * zero by default.

     *

     * This value changes when `approve` or `transferFrom` are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * > Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an `Approval` event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a `Transfer` event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to `approve`. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.0;



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 */

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");



        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");



        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers. Reverts on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0, "SafeMath: division by zero");

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * Reverts when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0, "SafeMath: modulo by zero");

        return a % b;

    }

}



// File: contracts/CryptostampColors.sol



/*

Implements a color store for crypto stamp

*/

pragma solidity ^0.5.0;









contract CryptostampColors {

    using SafeMath for uint256;



    IERC721Full internal cryptostamp;



    address public createControl;



    address public tokenAssignmentControl;



    enum Colors {

        Black,

        Green,

        Blue,

        Yellow,

        Red

    }



    uint256 public constant packFactor = 85;

    uint256 public constant packBits = 3;

    uint256[] public packedColors;



    event SavedColors(uint256 firstId, uint256 lastId);



    constructor(address _createControl, address _tokenAssignmentControl)

    public

    {

        createControl = _createControl;

        tokenAssignmentControl = _tokenAssignmentControl;

    }



    modifier onlyCreateControl()

    {

        require(msg.sender == createControl, "createControl key required for this function.");

        _;

    }



    modifier onlyTokenAssignmentControl() {

        require(msg.sender == tokenAssignmentControl, "tokenAssignmentControl key required for this function.");

        _;

    }



    modifier requireCryptostamp() {

        require(address(cryptostamp) != address(0x0), "You need to provide an actual Cryptostamp contract.");

        _;

    }



    /*** Enable adjusting variables after deployment ***/



    function setCryptostamp(IERC721Full _newCryptostamp)

    public

    onlyCreateControl

    {

        require(address(_newCryptostamp) != address(0x0), "You need to provide an actual Cryptostamp contract.");

        cryptostamp = _newCryptostamp;

    }



    /*** Actual color storage ***/



    function calcPackedColors(Colors[] memory _values)

    public pure

    returns (uint256)

    {

        uint256 valcount = _values.length;

        require(valcount <= packFactor, "Can only pack values up to a maximum of the packFactor.");

        uint256 packedVal = 0;

        for (uint256 i = 0; i < valcount; i++) {

            packedVal += uint256(_values[i]) * (2 ** (i * packBits));

        }

        return packedVal;

    }



    function setColorsPacked(uint256 _tokenIdStart, uint256[] memory _packedValues)

    public

    onlyCreateControl

    requireCryptostamp

    {

        require(_tokenIdStart == packedColors.length * packFactor, "Values can can only be appended at the end.");

        require(_tokenIdStart % packFactor == 0, "The starting token ID needs to be aligned with the packing factor.");

        uint256 valcount = _packedValues.length;

        for (uint256 i = 0; i < valcount; i++) {

            packedColors.push(_packedValues[i]);

        }

        emit SavedColors(_tokenIdStart, totalSupply() - 1);

    }



    // Returns the color of a given token ID

    function getColor(uint256 tokenId)

    public view

    requireCryptostamp

    returns (Colors)

    {

        require(tokenId < totalSupply(), "The token ID has no color stored.");

        require(tokenId < cryptostamp.totalSupply(), "The token ID is not valid.");

        uint256 packElement = tokenId / packFactor;

        uint256 packItem = tokenId % packFactor;

        uint256 packValue = (packedColors[packElement] >> (packBits * packItem)) % (2 ** packBits);

        require(packValue < 5, "Error in packed Value.");

        return Colors(packValue);

    }



    // Returns the amount of colors saved.

    function totalSupply()

    public view

    requireCryptostamp

    returns (uint256)

    {

        uint256 maxSupply = packedColors.length * packFactor;

        uint256 csSupply = cryptostamp.totalSupply();

        if (csSupply < maxSupply) {

            return csSupply;

        }

        return maxSupply;

    }



    /*** Make sure currency or NFT doesn't get stranded in this contract ***/



    // If this contract gets a balance in some ERC20 contract after it's finished, then we can rescue it.

    function rescueToken(IERC20 _foreignToken, address _to)

    external

    onlyTokenAssignmentControl

    {

        _foreignToken.transfer(_to, _foreignToken.balanceOf(address(this)));

    }



    // If this contract gets a balance in some ERC721 contract after it's finished, then we can rescue it.

    function approveNFTrescue(IERC721 _foreignNFT, address _to)

    external

    onlyTokenAssignmentControl

    {

        _foreignNFT.setApprovalForAll(_to, true);

    }

 

    // Make sure this contract cannot receive ETH.

    function()

    external payable

    {

        revert("The contract cannot receive ETH payments.");

    }

}