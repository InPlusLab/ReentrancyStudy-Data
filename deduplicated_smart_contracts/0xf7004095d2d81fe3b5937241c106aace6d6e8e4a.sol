/**

 *Submitted for verification at Etherscan.io on 2018-08-29

*/



pragma solidity ^0.4.23;



// File: @ensdomains/dnssec-oracle/contracts/BytesUtils.sol



library BytesUtils {

    /*

    * @dev Returns the keccak-256 hash of a byte range.

    * @param self The byte string to hash.

    * @param offset The position to start hashing at.

    * @param len The number of bytes to hash.

    * @return The hash of the byte range.

    */

    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {

        require(offset + len <= self.length);

        assembly {

            ret := sha3(add(add(self, 32), offset), len)

        }

    }





    /*

    * @dev Returns a positive number if `other` comes lexicographically after

    *      `self`, a negative number if it comes before, or zero if the

    *      contents of the two bytes are equal.

    * @param self The first bytes to compare.

    * @param other The second bytes to compare.

    * @return The result of the comparison.

    */

    function compare(bytes memory self, bytes memory other) internal pure returns (int) {

        return compare(self, 0, self.length, other, 0, other.length);

    }



    /*

    * @dev Returns a positive number if `other` comes lexicographically after

    *      `self`, a negative number if it comes before, or zero if the

    *      contents of the two bytes are equal. Comparison is done per-rune,

    *      on unicode codepoints.

    * @param self The first bytes to compare.

    * @param offset The offset of self.

    * @param len    The length of self.

    * @param other The second bytes to compare.

    * @param otheroffset The offset of the other string.

    * @param otherlen    The length of the other string.

    * @return The result of the comparison.

    */

    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {

        uint shortest = len;

        if (otherlen < len)

        shortest = otherlen;



        uint selfptr;

        uint otherptr;



        assembly {

            selfptr := add(self, add(offset, 32))

            otherptr := add(other, add(otheroffset, 32))

        }

        for (uint idx = 0; idx < shortest; idx += 32) {

            uint a;

            uint b;

            assembly {

                a := mload(selfptr)

                b := mload(otherptr)

            }

            if (a != b) {

                // Mask out irrelevant bytes and check again

                uint mask;

                if (shortest > 32) {

                    mask = uint256(- 1); // aka 0xffffff....

                } else {

                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);

                }

                uint diff = (a & mask) - (b & mask);

                if (diff != 0)

                return int(diff);

            }

            selfptr += 32;

            otherptr += 32;

        }



        return int(len) - int(otherlen);

    }



    /*

    * @dev Returns true if the two byte ranges are equal.

    * @param self The first byte range to compare.

    * @param offset The offset into the first byte range.

    * @param other The second byte range to compare.

    * @param otherOffset The offset into the second byte range.

    * @param len The number of bytes to compare

    * @return True if the byte ranges are equal, false otherwise.

    */

    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {

        return keccak(self, offset, len) == keccak(other, otherOffset, len);

    }



    /*

    * @dev Returns true if the two byte ranges are equal with offsets.

    * @param self The first byte range to compare.

    * @param offset The offset into the first byte range.

    * @param other The second byte range to compare.

    * @param otherOffset The offset into the second byte range.

    * @return True if the byte ranges are equal, false otherwise.

    */

    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {

        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);

    }



    /*

    * @dev Compares a range of 'self' to all of 'other' and returns True iff

    *      they are equal.

    * @param self The first byte range to compare.

    * @param offset The offset into the first byte range.

    * @param other The second byte range to compare.

    * @return True if the byte ranges are equal, false otherwise.

    */

    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {

        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);

    }



    /*

    * @dev Returns true if the two byte ranges are equal.

    * @param self The first byte range to compare.

    * @param other The second byte range to compare.

    * @return True if the byte ranges are equal, false otherwise.

    */

    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {

        return self.length == other.length && equals(self, 0, other, 0, self.length);

    }



    /*

    * @dev Returns the 8-bit number at the specified index of self.

    * @param self The byte string.

    * @param idx The index into the bytes

    * @return The specified 8 bits of the string, interpreted as an integer.

    */

    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {

        require(idx + 1 <= self.length);

        assembly {

            ret := and(mload(add(add(self, 1), idx)), 0xFF)

        }

    }



    /*

    * @dev Returns the 16-bit number at the specified index of self.

    * @param self The byte string.

    * @param idx The index into the bytes

    * @return The specified 16 bits of the string, interpreted as an integer.

    */

    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {

        require(idx + 2 <= self.length);

        assembly {

            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)

        }

    }



    /*

    * @dev Returns the 32-bit number at the specified index of self.

    * @param self The byte string.

    * @param idx The index into the bytes

    * @return The specified 32 bits of the string, interpreted as an integer.

    */

    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {

        require(idx + 4 <= self.length);

        assembly {

            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)

        }

    }



    /*

    * @dev Returns the 32 byte value at the specified index of self.

    * @param self The byte string.

    * @param idx The index into the bytes

    * @return The specified 32 bytes of the string.

    */

    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {

        require(idx + 32 <= self.length);

        assembly {

            ret := mload(add(add(self, 32), idx))

        }

    }



    /*

    * @dev Returns the 32 byte value at the specified index of self.

    * @param self The byte string.

    * @param idx The index into the bytes

    * @return The specified 32 bytes of the string.

    */

    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {

        require(idx + 20 <= self.length);

        assembly {

            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)

        }

    }



    /*

    * @dev Returns the n byte value at the specified index of self.

    * @param self The byte string.

    * @param idx The index into the bytes.

    * @param len The number of bytes.

    * @return The specified 32 bytes of the string.

    */

    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes20 ret) {

        require(idx + len <= self.length);

        assembly {

            let mask := not(sub(exp(256, sub(32, len)), 1))

            ret := and(mload(add(add(self, 32), idx)),  mask)

        }

    }



    function memcpy(uint dest, uint src, uint len) private pure {

        // Copy word-length chunks while possible

        for (; len >= 32; len -= 32) {

            assembly {

                mstore(dest, mload(src))

            }

            dest += 32;

            src += 32;

        }



        // Copy remaining bytes

        uint mask = 256 ** (32 - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }

    }



    /*

    * @dev Copies a substring into a new byte string.

    * @param self The byte string to copy from.

    * @param offset The offset to start copying at.

    * @param len The number of bytes to copy.

    */

    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes) {

        require(offset + len <= self.length);



        bytes memory ret = new bytes(len);

        uint dest;

        uint src;



        assembly {

            dest := add(ret, 32)

            src := add(add(self, 32), offset)

        }

        memcpy(dest, src, len);



        return ret;

    }



    // Maps characters from 0x30 to 0x7A to their base32 values.

    // 0xFF represents invalid characters in that range.

    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';



    /**

     * @dev Decodes unpadded base32 data of up to one word in length.

     * @param self The data to decode.

     * @param off Offset into the string to start at.

     * @param len Number of characters to decode.

     * @return The decoded data, left aligned.

     */

    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {

        require(len <= 52);



        uint ret = 0;

        for(uint i = 0; i < len; i++) {

            byte char = self[off + i];

            require(char >= 0x30 && char <= 0x7A);

            uint8 decoded = uint8(base32HexTable[uint(char) - 0x30]);

            require(decoded <= 0x20);

            if(i == len - 1) {

                break;

            }

            ret = (ret << 5) | decoded;

        }



        uint bitlen = len * 5;

        if(len % 8 == 0) {

            // Multiple of 8 characters, no padding

            ret = (ret << 5) | decoded;

        } else if(len % 8 == 2) {

            // Two extra characters - 1 byte

            ret = (ret << 3) | (decoded >> 2);

            bitlen -= 2;

        } else if(len % 8 == 4) {

            // Four extra characters - 2 bytes

            ret = (ret << 1) | (decoded >> 4);

            bitlen -= 4;

        } else if(len % 8 == 5) {

            // Five extra characters - 3 bytes

            ret = (ret << 4) | (decoded >> 1);

            bitlen -= 1;

        } else if(len % 8 == 7) {

            // Seven extra characters - 4 bytes

            ret = (ret << 2) | (decoded >> 3);

            bitlen -= 3;

        } else {

            revert();

        }



        return bytes32(ret << (256 - bitlen));

    }

}



// File: @ensdomains/dnssec-oracle/contracts/DNSSEC.sol



interface DNSSEC {



    event AlgorithmUpdated(uint8 id, address addr);

    event DigestUpdated(uint8 id, address addr);

    event NSEC3DigestUpdated(uint8 id, address addr);

    event RRSetUpdated(bytes name, bytes rrset);



    function submitRRSets(bytes memory data, bytes memory proof) public returns (bytes);

    function submitRRSet(bytes memory input, bytes memory sig, bytes memory proof) public returns(bytes memory rrs);

    function deleteRRSet(uint16 deleteType, bytes deleteName, bytes memory nsec, bytes memory sig, bytes memory proof) public;

    function rrdata(uint16 dnstype, bytes memory name) public view returns (uint32, uint64, bytes20);



}



// File: @ensdomains/buffer/contracts/Buffer.sol



/**

* @dev A library for working with mutable byte buffers in Solidity.

*

* Byte buffers are mutable and expandable, and provide a variety of primitives

* for writing to them. At any time you can fetch a bytes object containing the

* current contents of the buffer. The bytes object should not be stored between

* operations, as it may change due to resizing of the buffer.

*/

library Buffer {

    /**

    * @dev Represents a mutable buffer. Buffers have a current value (buf) and

    *      a capacity. The capacity may be longer than the current value, in

    *      which case it can be extended without the need to allocate more memory.

    */

    struct buffer {

        bytes buf;

        uint capacity;

    }



    /**

    * @dev Initializes a buffer with an initial capacity.

    * @param buf The buffer to initialize.

    * @param capacity The number of bytes of space to allocate the buffer.

    * @return The buffer, for chaining.

    */

    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {

        if (capacity % 32 != 0) {

            capacity += 32 - (capacity % 32);

        }

        // Allocate space for the buffer data

        buf.capacity = capacity;

        assembly {

            let ptr := mload(0x40)

            mstore(buf, ptr)

            mstore(ptr, 0)

            mstore(0x40, add(ptr, capacity))

        }

        return buf;

    }



    /**

    * @dev Initializes a new buffer from an existing bytes object.

    *      Changes to the buffer may mutate the original value.

    * @param b The bytes object to initialize the buffer with.

    * @return A new buffer.

    */

    function fromBytes(bytes b) internal pure returns(buffer memory) {

        buffer memory buf;

        buf.buf = b;

        buf.capacity = b.length;

        return buf;

    }



    function resize(buffer memory buf, uint capacity) private pure {

        bytes memory oldbuf = buf.buf;

        init(buf, capacity);

        append(buf, oldbuf);

    }



    function max(uint a, uint b) private pure returns(uint) {

        if (a > b) {

            return a;

        }

        return b;

    }



    /**

    * @dev Sets buffer length to 0.

    * @param buf The buffer to truncate.

    * @return The original buffer, for chaining..

    */

    function truncate(buffer memory buf) internal pure returns (buffer memory) {

        assembly {

            let bufptr := mload(buf)

            mstore(bufptr, 0)

        }

        return buf;

    }



    /**

    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed

    *      the capacity of the buffer.

    * @param buf The buffer to append to.

    * @param off The start offset to write to.

    * @param data The data to append.

    * @param len The number of bytes to copy.

    * @return The original buffer, for chaining.

    */

    function write(buffer memory buf, uint off, bytes data, uint len) internal pure returns(buffer memory) {

        require(len <= data.length);



        if (off + len + buf.buf.length > buf.capacity) {

            resize(buf, max(buf.capacity, len + off) * 2);

        }



        uint dest;

        uint src;

        assembly {

            // Memory address of the buffer data

            let bufptr := mload(buf)

            // Length of existing buffer data

            let buflen := mload(bufptr)

            // Start address = buffer address + offset + sizeof(buffer length)

            dest := add(add(bufptr, 32), off)

            // Update buffer length if we're extending it

            if gt(add(len, off), buflen) {

                mstore(bufptr, add(len, off))

            }

            src := add(data, 32)

        }



        // Copy word-length chunks while possible

        for (; len >= 32; len -= 32) {

            assembly {

                mstore(dest, mload(src))

            }

            dest += 32;

            src += 32;

        }



        // Copy remaining bytes

        uint mask = 256 ** (32 - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }



        return buf;

    }



    /**

    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed

    *      the capacity of the buffer.

    * @param buf The buffer to append to.

    * @param data The data to append.

    * @param len The number of bytes to copy.

    * @return The original buffer, for chaining.

    */

    function append(buffer memory buf, bytes data, uint len) internal pure returns (buffer memory) {

        return write(buf, buf.buf.length, data, len);

    }



    /**

    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed

    *      the capacity of the buffer.

    * @param buf The buffer to append to.

    * @param data The data to append.

    * @return The original buffer, for chaining.

    */

    function append(buffer memory buf, bytes data) internal pure returns (buffer memory) {

        return write(buf, buf.buf.length, data, data.length);

    }



    /**

    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the

    *      capacity of the buffer.

    * @param buf The buffer to append to.

    * @param off The offset to write the byte at.

    * @param data The data to append.

    * @return The original buffer, for chaining.

    */

    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {

        if (off > buf.capacity) {

            resize(buf, buf.capacity * 2);

        }



        assembly {

            // Memory address of the buffer data

            let bufptr := mload(buf)

            // Length of existing buffer data

            let buflen := mload(bufptr)

            // Address = buffer address + sizeof(buffer length) + off

            let dest := add(add(bufptr, off), 32)

            mstore8(dest, data)

            // Update buffer length if we extended it

            if eq(off, buflen) {

                mstore(bufptr, add(buflen, 1))

            }

        }

        return buf;

    }



    /**

    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the

    *      capacity of the buffer.

    * @param buf The buffer to append to.

    * @param data The data to append.

    * @return The original buffer, for chaining.

    */

    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {

        return writeUint8(buf, buf.buf.length, data);

    }



    /**

    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would

    *      exceed the capacity of the buffer.

    * @param buf The buffer to append to.

    * @param off The offset to write at.

    * @param data The data to append.

    * @param len The number of bytes to write (left-aligned).

    * @return The original buffer, for chaining.

    */

    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {

        if (len + off > buf.capacity) {

            resize(buf, max(buf.capacity, len) * 2);

        }



        uint mask = 256 ** len - 1;

        // Right-align data

        data = data >> (8 * (32 - len));

        assembly {

            // Memory address of the buffer data

            let bufptr := mload(buf)

            // Address = buffer address + sizeof(buffer length) + off + len

            let dest := add(add(bufptr, off), len)

            mstore(dest, or(and(mload(dest), not(mask)), data))

            // Update buffer length if we extended it

            if gt(add(off, len), mload(bufptr)) {

                mstore(bufptr, add(off, len))

            }

        }

        return buf;

    }



    /**

    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the

    *      capacity of the buffer.

    * @param buf The buffer to append to.

    * @param off The offset to write at.

    * @param data The data to append.

    * @return The original buffer, for chaining.

    */

    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {

        return write(buf, off, bytes32(data), 20);

    }



    /**

    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed

    *      the capacity of the buffer.

    * @param buf The buffer to append to.

    * @param data The data to append.

    * @return The original buffer, for chhaining.

    */

    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {

        return write(buf, buf.buf.length, bytes32(data), 20);

    }



    /**

    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed

    *      the capacity of the buffer.

    * @param buf The buffer to append to.

    * @param data The data to append.

    * @return The original buffer, for chaining.

    */

    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {

        return write(buf, buf.buf.length, data, 32);

    }



    /**

    * @dev Writes an integer to the buffer. Resizes if doing so would exceed

    *      the capacity of the buffer.

    * @param buf The buffer to append to.

    * @param off The offset to write at.

    * @param data The data to append.

    * @param len The number of bytes to write (right-aligned).

    * @return The original buffer, for chaining.

    */

    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {

        if (len + off > buf.capacity) {

            resize(buf, max(buf.capacity, len + off) * 2);

        }



        uint mask = 256 ** len - 1;

        assembly {

            // Memory address of the buffer data

            let bufptr := mload(buf)

            // Address = buffer address + off + sizeof(buffer length) + len

            let dest := add(add(bufptr, off), len)

            mstore(dest, or(and(mload(dest), not(mask)), data))

            // Update buffer length if we extended it

            if gt(add(off, len), mload(bufptr)) {

                mstore(bufptr, add(off, len))

            }

        }

        return buf;

    }

}



// File: @ensdomains/dnssec-oracle/contracts/RRUtils.sol



/**

* @dev RRUtils is a library that provides utilities for parsing DNS resource records.

*/

library RRUtils {

    using BytesUtils for *;

    using Buffer for *;



    /**

    * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.

    * @param self The byte array to read a name from.

    * @param offset The offset to start reading at.

    * @return The length of the DNS name at 'offset', in bytes.

    */

    function nameLength(bytes memory self, uint offset) internal pure returns(uint) {

        uint idx = offset;

        while (true) {

            assert(idx < self.length);

            uint labelLen = self.readUint8(idx);

            idx += labelLen + 1;

            if (labelLen == 0) {

                break;

            }

        }

        return idx - offset;

    }



    /**

    * @dev Returns a DNS format name at the specified offset of self.

    * @param self The byte array to read a name from.

    * @param offset The offset to start reading at.

    * @return The name.

    */

    function readName(bytes memory self, uint offset) internal pure returns(bytes memory ret) {

        uint len = nameLength(self, offset);

        return self.substring(offset, len);

    }



    /**

    * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.

    * @param self The byte array to read a name from.

    * @param offset The offset to start reading at.

    * @return The number of labels in the DNS name at 'offset', in bytes.

    */

    function labelCount(bytes memory self, uint offset) internal pure returns(uint) {

        uint count = 0;

        while (true) {

            assert(offset < self.length);

            uint labelLen = self.readUint8(offset);

            offset += labelLen + 1;

            if (labelLen == 0) {

                break;

            }

            count += 1;

        }

        return count;

    }



    /**

    * @dev An iterator over resource records.

    */

    struct RRIterator {

        bytes data;

        uint offset;

        uint16 dnstype;

        uint16 class;

        uint32 ttl;

        uint rdataOffset;

        uint nextOffset;

    }



    /**

    * @dev Begins iterating over resource records.

    * @param self The byte string to read from.

    * @param offset The offset to start reading at.

    * @return An iterator object.

    */

    function iterateRRs(bytes memory self, uint offset) internal pure returns (RRIterator memory ret) {

        ret.data = self;

        ret.nextOffset = offset;

        next(ret);

    }



    /**

    * @dev Returns true iff there are more RRs to iterate.

    * @param iter The iterator to check.

    * @return True iff the iterator has finished.

    */

    function done(RRIterator memory iter) internal pure returns(bool) {

        return iter.offset >= iter.data.length;

    }



    /**

    * @dev Moves the iterator to the next resource record.

    * @param iter The iterator to advance.

    */

    function next(RRIterator memory iter) internal pure {

        iter.offset = iter.nextOffset;

        if (iter.offset >= iter.data.length) {

            return;

        }



        // Skip the name

        uint off = iter.offset + nameLength(iter.data, iter.offset);



        // Read type, class, and ttl

        iter.dnstype = iter.data.readUint16(off);

        off += 2;

        iter.class = iter.data.readUint16(off);

        off += 2;

        iter.ttl = iter.data.readUint32(off);

        off += 4;



        // Read the rdata

        uint rdataLength = iter.data.readUint16(off);

        off += 2;

        iter.rdataOffset = off;

        iter.nextOffset = off + rdataLength;

    }



    /**

    * @dev Returns the name of the current record.

    * @param iter The iterator.

    * @return A new bytes object containing the owner name from the RR.

    */

    function name(RRIterator memory iter) internal pure returns(bytes memory) {

        return iter.data.substring(iter.offset, nameLength(iter.data, iter.offset));

    }



    /**

    * @dev Returns the rdata portion of the current record.

    * @param iter The iterator.

    * @return A new bytes object containing the RR's RDATA.

    */

    function rdata(RRIterator memory iter) internal pure returns(bytes memory) {

        return iter.data.substring(iter.rdataOffset, iter.nextOffset - iter.rdataOffset);

    }



    /**

    * @dev Checks if a given RR type exists in a type bitmap.

    * @param self The byte string to read the type bitmap from.

    * @param offset The offset to start reading at.

    * @param rrtype The RR type to check for.

    * @return True if the type is found in the bitmap, false otherwise.

    */

    function checkTypeBitmap(bytes memory self, uint offset, uint16 rrtype) internal pure returns (bool) {

        uint8 typeWindow = uint8(rrtype >> 8);

        uint8 windowByte = uint8((rrtype & 0xff) / 8);

        uint8 windowBitmask = uint8(uint8(1) << (uint8(7) - uint8(rrtype & 0x7)));

        for (uint off = offset; off < self.length;) {

            uint8 window = self.readUint8(off);

            uint8 len = self.readUint8(off + 1);

            if (typeWindow < window) {

                // We've gone past our window; it's not here.

                return false;

            } else if (typeWindow == window) {

                // Check this type bitmap

                if (len * 8 <= windowByte) {

                    // Our type is past the end of the bitmap

                    return false;

                }

                return (self.readUint8(off + windowByte + 2) & windowBitmask) != 0;

            } else {

                // Skip this type bitmap

                off += len + 2;

            }

        }



        return false;

    }



    function compareNames(bytes memory self, bytes memory other) internal pure returns (int) {

        if (self.equals(other)) {

            return 0;

        }



        uint off;

        uint otheroff;

        uint prevoff;

        uint otherprevoff;

        uint counts = labelCount(self, 0);

        uint othercounts = labelCount(other, 0);



        // Keep removing labels from the front of the name until both names are equal length

        while (counts > othercounts) {

            prevoff = off;

            off = progress(self, off);

            counts--;

        }



        while (othercounts > counts) {

            otherprevoff = otheroff;

            otheroff = progress(other, otheroff);

            othercounts--;

        }



        // Compare the last nonequal labels to each other

        while (counts > 0 && !self.equals(off, other, otheroff)) {

            prevoff = off;

            off = progress(self, off);

            otherprevoff = otheroff;

            otheroff = progress(other, otheroff);

            counts -= 1;

        }



        if (off == 0) {

            return -1;

        }

        if(otheroff == 0) {

            return 1;

        }



        return self.compare(prevoff + 1, self.readUint8(prevoff), other, otherprevoff + 1, other.readUint8(otherprevoff));

    }



    function progress(bytes memory body, uint off) internal pure returns(uint) {

        return off + 1 + body.readUint8(off);

    }

}



// File: @ensdomains/ens/contracts/ENS.sol



interface ENS {



    // Logged when the owner of a node assigns a new owner to a subnode.

    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);



    // Logged when the owner of a node transfers ownership to a new account.

    event Transfer(bytes32 indexed node, address owner);



    // Logged when the resolver for a node changes.

    event NewResolver(bytes32 indexed node, address resolver);



    // Logged when the TTL of a node changes

    event NewTTL(bytes32 indexed node, uint64 ttl);





    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;

    function setResolver(bytes32 node, address resolver) public;

    function setOwner(bytes32 node, address owner) public;

    function setTTL(bytes32 node, uint64 ttl) public;

    function owner(bytes32 node) public view returns (address);

    function resolver(bytes32 node) public view returns (address);

    function ttl(bytes32 node) public view returns (uint64);



}



// File: @ensdomains/ens/contracts/ENSRegistry.sol



/**

 * The ENS registry contract.

 */

contract ENSRegistry is ENS {

    struct Record {

        address owner;

        address resolver;

        uint64 ttl;

    }



    mapping (bytes32 => Record) records;



    // Permits modifications only by the owner of the specified node.

    modifier only_owner(bytes32 node) {

        require(records[node].owner == msg.sender);

        _;

    }



    /**

     * @dev Constructs a new ENS registrar.

     */

    function ENSRegistry() public {

        records[0x0].owner = msg.sender;

    }



    /**

     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.

     * @param node The node to transfer ownership of.

     * @param owner The address of the new owner.

     */

    function setOwner(bytes32 node, address owner) public only_owner(node) {

        Transfer(node, owner);

        records[node].owner = owner;

    }



    /**

     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.

     * @param node The parent node.

     * @param label The hash of the label specifying the subnode.

     * @param owner The address of the new owner.

     */

    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {

        var subnode = keccak256(node, label);

        NewOwner(node, label, owner);

        records[subnode].owner = owner;

    }



    /**

     * @dev Sets the resolver address for the specified node.

     * @param node The node to update.

     * @param resolver The address of the resolver.

     */

    function setResolver(bytes32 node, address resolver) public only_owner(node) {

        NewResolver(node, resolver);

        records[node].resolver = resolver;

    }



    /**

     * @dev Sets the TTL for the specified node.

     * @param node The node to update.

     * @param ttl The TTL in seconds.

     */

    function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {

        NewTTL(node, ttl);

        records[node].ttl = ttl;

    }



    /**

     * @dev Returns the address that owns the specified node.

     * @param node The specified node.

     * @return address of the owner.

     */

    function owner(bytes32 node) public view returns (address) {

        return records[node].owner;

    }



    /**

     * @dev Returns the address of the resolver for the specified node.

     * @param node The specified node.

     * @return address of the resolver.

     */

    function resolver(bytes32 node) public view returns (address) {

        return records[node].resolver;

    }



    /**

     * @dev Returns the TTL of a node, and any records associated with it.

     * @param node The specified node.

     * @return ttl of the node.

     */

    function ttl(bytes32 node) public view returns (uint64) {

        return records[node].ttl;

    }



}



// File: contracts/DNSRegistrar.sol



/**

 * @dev An ENS registrar that allows the owner of a DNS name to claim the

 *      corresponding name in ENS.

 */

contract DNSRegistrar {

    using BytesUtils for bytes;

    using RRUtils for *;

    using Buffer for Buffer.buffer;



    uint16 constant CLASS_INET = 1;

    uint16 constant TYPE_TXT = 16;



    DNSSEC public oracle;

    ENS public ens;

    bytes public rootDomain;

    bytes32 public rootNode;



    event Claim(bytes32 indexed node, address indexed owner, bytes dnsname);



    constructor(DNSSEC _dnssec, ENS _ens, bytes _rootDomain, bytes32 _rootNode) public {

        oracle = _dnssec;

        ens = _ens;

        rootDomain = _rootDomain;

        rootNode = _rootNode;

    }



    /**

     * @dev Claims a name by proving ownership of its DNS equivalent.

     * @param name The name to claim, in DNS wire format.

     * @param proof A DNS RRSet proving ownership of the name. Must be verified

     *        in the DNSSEC oracle before calling. This RRSET must contain a TXT

     *        record for '_ens.' + name, with the value 'a=0x...'. Ownership of

     *        the name will be transferred to the address specified in the TXT

     *        record.

     */

    function claim(bytes name, bytes proof) public {

        bytes32 labelHash = getLabelHash(name);



        address addr = getOwnerAddress(name, proof);



        ens.setSubnodeOwner(rootNode, labelHash, addr);

        emit Claim(keccak256(rootNode, labelHash), addr, name);

    }



    /**

     * @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.

     * @param name The name to claim, in DNS wire format.

     * @param input The data to be passed to the Oracle's `submitProofs` function. The last

     *        proof must be the TXT record required by the registrar.

     * @param proof The proof record for the first element in input.

     */

    function proveAndClaim(bytes name, bytes input, bytes proof) public {

        proof = oracle.submitRRSets(input, proof);

        claim(name, proof);

    }



    function getLabelHash(bytes memory name) internal view returns(bytes32) {

        uint len = name.readUint8(0);

        // Check this name is a direct subdomain of the one we're responsible for

        require(name.equals(len + 1, rootDomain));

        return name.keccak(1, len);

    }



    function getOwnerAddress(bytes memory name, bytes memory proof) internal view returns(address) {

        // Add "_ens." to the front of the name.

        Buffer.buffer memory buf;

        buf.init(name.length + 5);

        buf.append("\x04_ens");

        buf.append(name);

        bytes20 hash;

        uint64 inserted;

        // Check the provided TXT record has been validated by the oracle

        (, inserted, hash) = oracle.rrdata(TYPE_TXT, buf.buf);

        if(hash == bytes20(0) && proof.length == 0) return 0;



        require(hash == bytes20(keccak256(proof)));



        for(RRUtils.RRIterator memory iter = proof.iterateRRs(0); !iter.done(); iter.next()) {

            require(inserted + iter.ttl >= now, "DNS record is stale; refresh or delete it before proceeding.");



            address addr = parseRR(proof, iter.rdataOffset);

            if(addr != 0) {

                return addr;

            }

        }



        return 0;

    }



    function parseRR(bytes memory rdata, uint idx) internal pure returns(address) {

        while(idx < rdata.length) {

            uint len = rdata.readUint8(idx); idx += 1;

            address addr = parseString(rdata, idx, len);

            if(addr != 0) return addr;

            idx += len;

        }



        return 0;

    }



    function parseString(bytes memory str, uint idx, uint len) internal pure returns(address) {

        // TODO: More robust parsing that handles whitespace and multiple key/value pairs

        if(str.readUint32(idx) != 0x613d3078) return 0; // 0x613d3078 == 'a=0x'

        if(len < 44) return 0;

        return hexToAddress(str, idx + 4);

    }



    function hexToAddress(bytes memory str, uint idx) internal pure returns(address) {

        if(str.length - idx < 40) return 0;

        uint ret = 0;

        for(uint i = idx; i < idx + 40; i++) {

            ret <<= 4;

            uint x = str.readUint8(i);

            if(x >= 48 && x < 58) {

                ret |= x - 48;

            } else if(x >= 65 && x < 71) {

                ret |= x - 55;

            } else if(x >= 97 && x < 103) {

                ret |= x - 87;

            } else {

                return 0;

            }

        }

        return address(ret);

    }

}