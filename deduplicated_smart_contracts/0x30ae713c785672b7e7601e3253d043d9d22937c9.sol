/**

 *Submitted for verification at Etherscan.io on 2019-05-29

*/



// File: openzeppelin-solidity/contracts/math/SafeMath.sol



pragma solidity ^0.5.2;



/**

 * @title SafeMath

 * @dev Unsigned math operations with safety checks that revert on error

 */

library SafeMath {

    /**

     * @dev Multiplies two unsigned integers, reverts on overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

     * @dev Adds two unsigned integers, reverts on overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }



    /**

     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

     * reverts when dividing by zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b != 0);

        return a % b;

    }

}



// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol



pragma solidity ^0.5.2;



/**

 * @title ERC20 interface

 * @dev see https://eips.ethereum.org/EIPS/eip-20

 */

interface IERC20 {

    function transfer(address to, uint256 value) external returns (bool);



    function approve(address spender, uint256 value) external returns (bool);



    function transferFrom(address from, address to, uint256 value) external returns (bool);



    function totalSupply() external view returns (uint256);



    function balanceOf(address who) external view returns (uint256);



    function allowance(address owner, address spender) external view returns (uint256);



    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);

}



// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol



pragma solidity ^0.5.2;







/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * https://eips.ethereum.org/EIPS/eip-20

 * Originally based on code by FirstBlood:

 * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 *

 * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for

 * all accounts just by listening to said events. Note that this isn't required by the specification, and other

 * compliant implementations may not do it.

 */

contract ERC20 is IERC20 {

    using SafeMath for uint256;



    mapping (address => uint256) private _balances;



    mapping (address => mapping (address => uint256)) private _allowed;



    uint256 private _totalSupply;



    /**

     * @dev Total number of tokens in existence

     */

    function totalSupply() public view returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev Gets the balance of the specified address.

     * @param owner The address to query the balance of.

     * @return A uint256 representing the amount owned by the passed address.

     */

    function balanceOf(address owner) public view returns (uint256) {

        return _balances[owner];

    }



    /**

     * @dev Function to check the amount of tokens that an owner allowed to a spender.

     * @param owner address The address which owns the funds.

     * @param spender address The address which will spend the funds.

     * @return A uint256 specifying the amount of tokens still available for the spender.

     */

    function allowance(address owner, address spender) public view returns (uint256) {

        return _allowed[owner][spender];

    }



    /**

     * @dev Transfer token to a specified address

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function transfer(address to, uint256 value) public returns (bool) {

        _transfer(msg.sender, to, value);

        return true;

    }



    /**

     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param spender The address which will spend the funds.

     * @param value The amount of tokens to be spent.

     */

    function approve(address spender, uint256 value) public returns (bool) {

        _approve(msg.sender, spender, value);

        return true;

    }



    /**

     * @dev Transfer tokens from one address to another.

     * Note that while this function emits an Approval event, this is not required as per the specification,

     * and other compliant implementations may not emit the event.

     * @param from address The address which you want to send tokens from

     * @param to address The address which you want to transfer to

     * @param value uint256 the amount of tokens to be transferred

     */

    function transferFrom(address from, address to, uint256 value) public returns (bool) {

        _transfer(from, to, value);

        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));

        return true;

    }



    /**

     * @dev Increase the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To increment

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param addedValue The amount of tokens to increase the allowance by.

     */

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));

        return true;

    }



    /**

     * @dev Decrease the amount of tokens that an owner allowed to a spender.

     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * Emits an Approval event.

     * @param spender The address which will spend the funds.

     * @param subtractedValue The amount of tokens to decrease the allowance by.

     */

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {

        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));

        return true;

    }



    /**

     * @dev Transfer token for a specified addresses

     * @param from The address to transfer from.

     * @param to The address to transfer to.

     * @param value The amount to be transferred.

     */

    function _transfer(address from, address to, uint256 value) internal {

        require(to != address(0));



        _balances[from] = _balances[from].sub(value);

        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);

    }



    /**

     * @dev Internal function that mints an amount of the token and assigns it to

     * an account. This encapsulates the modification of balances such that the

     * proper events are emitted.

     * @param account The account that will receive the created tokens.

     * @param value The amount that will be created.

     */

    function _mint(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.add(value);

        _balances[account] = _balances[account].add(value);

        emit Transfer(address(0), account, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account.

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burn(address account, uint256 value) internal {

        require(account != address(0));



        _totalSupply = _totalSupply.sub(value);

        _balances[account] = _balances[account].sub(value);

        emit Transfer(account, address(0), value);

    }



    /**

     * @dev Approve an address to spend another addresses' tokens.

     * @param owner The address that owns the tokens.

     * @param spender The address that will spend the tokens.

     * @param value The number of tokens that can be spent.

     */

    function _approve(address owner, address spender, uint256 value) internal {

        require(spender != address(0));

        require(owner != address(0));



        _allowed[owner][spender] = value;

        emit Approval(owner, spender, value);

    }



    /**

     * @dev Internal function that burns an amount of the token of a given

     * account, deducting from the sender's allowance for said account. Uses the

     * internal burn function.

     * Emits an Approval event (reflecting the reduced allowance).

     * @param account The account whose tokens will be burnt.

     * @param value The amount that will be burnt.

     */

    function _burnFrom(address account, uint256 value) internal {

        _burn(account, value);

        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));

    }

}



// File: registry/contracts/Registry.sol



pragma solidity >=0.4.25 <0.6.0;





interface RegistryClone {

    function syncAttributeValue(address _who, bytes32 _attribute, uint256 _value) external;

}



contract Registry {

    struct AttributeData {

        uint256 value;

        bytes32 notes;

        address adminAddr;

        uint256 timestamp;

    }

    

    // never remove any storage variables

    address public owner;

    address public pendingOwner;

    bool initialized;



    // Stores arbitrary attributes for users. An example use case is an ERC20

    // token that requires its users to go through a KYC/AML check - in this case

    // a validator can set an account's "hasPassedKYC/AML" attribute to 1 to indicate

    // that account can use the token. This mapping stores that value (1, in the

    // example) as well as which validator last set the value and at what time,

    // so that e.g. the check can be renewed at appropriate intervals.

    mapping(address => mapping(bytes32 => AttributeData)) attributes;

    // The logic governing who is allowed to set what attributes is abstracted as

    // this accessManager, so that it may be replaced by the owner as needed

    bytes32 constant WRITE_PERMISSION = keccak256("canWriteTo-");

    mapping(bytes32 => RegistryClone[]) subscribers;



    event OwnershipTransferred(

        address indexed previousOwner,

        address indexed newOwner

    );

    event SetAttribute(address indexed who, bytes32 attribute, uint256 value, bytes32 notes, address indexed adminAddr);

    event SetManager(address indexed oldManager, address indexed newManager);

    event StartSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);

    event StopSubscription(bytes32 indexed attribute, RegistryClone indexed subscriber);



    // Allows a write if either a) the writer is that Registry's owner, or

    // b) the writer is writing to attribute foo and that writer already has

    // the canWriteTo-foo attribute set (in that same Registry)

    function confirmWrite(bytes32 _attribute, address _admin) internal view returns (bool) {

        bytes32 attr =  WRITE_PERMISSION ^ _attribute;

        bytes32 kesres = bytes32(keccak256(abi.encodePacked(attr)));

        return (_admin == owner || hasAttribute(_admin, kesres));

    }



    // Writes are allowed only if the accessManager approves

    function setAttribute(address _who, bytes32 _attribute, uint256 _value, bytes32 _notes) public {

        require(confirmWrite(_attribute, msg.sender));

        attributes[_who][_attribute] = AttributeData(_value, _notes, msg.sender, block.timestamp);

        emit SetAttribute(_who, _attribute, _value, _notes, msg.sender);



        RegistryClone[] storage targets = subscribers[_attribute];

        uint256 index = targets.length;

        while (index --> 0) {

            targets[index].syncAttributeValue(_who, _attribute, _value);

        }

    }



    function subscribe(bytes32 _attribute, RegistryClone _syncer) external onlyOwner {

        subscribers[_attribute].push(_syncer);

        emit StartSubscription(_attribute, _syncer);

    }



    function unsubscribe(bytes32 _attribute, uint256 _index) external onlyOwner {

        uint256 length = subscribers[_attribute].length;

        require(_index < length);

        emit StopSubscription(_attribute, subscribers[_attribute][_index]);

        subscribers[_attribute][_index] = subscribers[_attribute][length - 1];

        subscribers[_attribute].length = length - 1;

    }



    function subscriberCount(bytes32 _attribute) public view returns (uint256) {

        return subscribers[_attribute].length;

    }



    function setAttributeValue(address _who, bytes32 _attribute, uint256 _value) public {

        require(confirmWrite(_attribute, msg.sender));

        attributes[_who][_attribute] = AttributeData(_value, "", msg.sender, block.timestamp);

        emit SetAttribute(_who, _attribute, _value, "", msg.sender);

        RegistryClone[] storage targets = subscribers[_attribute];

        uint256 index = targets.length;

        while (index --> 0) {

            targets[index].syncAttributeValue(_who, _attribute, _value);

        }

    }



    // Returns true if the uint256 value stored for this attribute is non-zero

    function hasAttribute(address _who, bytes32 _attribute) public view returns (bool) {

        return attributes[_who][_attribute].value != 0;

    }





    // Returns the exact value of the attribute, as well as its metadata

    function getAttribute(address _who, bytes32 _attribute) public view returns (uint256, bytes32, address, uint256) {

        AttributeData memory data = attributes[_who][_attribute];

        return (data.value, data.notes, data.adminAddr, data.timestamp);

    }



    function getAttributeValue(address _who, bytes32 _attribute) public view returns (uint256) {

        return attributes[_who][_attribute].value;

    }



    function getAttributeAdminAddr(address _who, bytes32 _attribute) public view returns (address) {

        return attributes[_who][_attribute].adminAddr;

    }



    function getAttributeTimestamp(address _who, bytes32 _attribute) public view returns (uint256) {

        return attributes[_who][_attribute].timestamp;

    }



    function syncAttribute(bytes32 _attribute, uint256 _startIndex, address[] calldata _addresses) external {

        RegistryClone[] storage targets = subscribers[_attribute];

        uint256 index = targets.length;

        while (index --> _startIndex) {

            RegistryClone target = targets[index];

            for (uint256 i = _addresses.length; i --> 0; ) {

                address who = _addresses[i];

                target.syncAttributeValue(who, _attribute, attributes[who][_attribute].value);

            }

        }

    }



    function reclaimEther(address payable _to) external onlyOwner {

        _to.transfer(address(this).balance);

    }



    function reclaimToken(ERC20 token, address _to) external onlyOwner {

        uint256 balance = token.balanceOf(address(this));

        token.transfer(_to, balance);

    }



   /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner, "only Owner");

        _;

    }



    /**

    * @dev Modifier throws if called by any account other than the pendingOwner.

    */

    modifier onlyPendingOwner() {

        require(msg.sender == pendingOwner);

        _;

    }



    /**

    * @dev Allows the current owner to set the pendingOwner address.

    * @param newOwner The address to transfer ownership to.

    */

    function transferOwnership(address newOwner) public onlyOwner {

        pendingOwner = newOwner;

    }



    /**

    * @dev Allows the pendingOwner address to finalize the transfer.

    */

    function claimOwnership() public onlyPendingOwner {

        emit OwnershipTransferred(owner, pendingOwner);

        owner = pendingOwner;

        pendingOwner = address(0);

    }

}



// File: openzeppelin-solidity/contracts/ownership/Ownable.sol



pragma solidity ^0.5.2;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev The Ownable constructor sets the original `owner` of the contract to the sender

     * account.

     */

    constructor () internal {

        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);

    }



    /**

     * @return the address of the owner.

     */

    function owner() public view returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(isOwner());

        _;

    }



    /**

     * @return true if `msg.sender` is the owner of the contract.

     */

    function isOwner() public view returns (bool) {

        return msg.sender == _owner;

    }



    /**

     * @dev Allows the current owner to relinquish control of the contract.

     * It will not be possible to call the functions with the `onlyOwner`

     * modifier anymore.

     * @notice Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public onlyOwner {

        emit OwnershipTransferred(_owner, address(0));

        _owner = address(0);

    }



    /**

     * @dev Allows the current owner to transfer control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function transferOwnership(address newOwner) public onlyOwner {

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers control of the contract to a newOwner.

     * @param newOwner The address to transfer ownership to.

     */

    function _transferOwnership(address newOwner) internal {

        require(newOwner != address(0));

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }

}



// File: contracts/Claimable.sol



pragma solidity >=0.4.25 <0.6.0;





contract Claimable is Ownable {

  address public pendingOwner;



  modifier onlyPendingOwner() {

    if (msg.sender == pendingOwner)

      _;

  }



  function transferOwnership(address newOwner) public onlyOwner {

    pendingOwner = newOwner;

  }



  function claimOwnership() onlyPendingOwner public {

    _transferOwnership(pendingOwner);

    pendingOwner = address(0x0);

  }



}



// File: contracts/modularERC20/BalanceSheet.sol



pragma solidity >=0.4.25 <0.6.0;







// A wrapper around the balanceOf mapping.

contract BalanceSheet is Claimable {

    using SafeMath for uint256;



    mapping (address => uint256) public balanceOf;



    function addBalance(address _addr, uint256 _value) public onlyOwner {

        balanceOf[_addr] = balanceOf[_addr].add(_value);

    }



    function subBalance(address _addr, uint256 _value) public onlyOwner {

        balanceOf[_addr] = balanceOf[_addr].sub(_value);

    }



    function setBalance(address _addr, uint256 _value) public onlyOwner {

        balanceOf[_addr] = _value;

    }

}



// File: contracts/modularERC20/AllowanceSheet.sol



pragma solidity >=0.4.25 <0.6.0;







// A wrapper around the allowanceOf mapping.

contract AllowanceSheet is Claimable {

    using SafeMath for uint256;



    mapping (address => mapping (address => uint256)) public allowanceOf;



    function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {

        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].add(_value);

    }



    function subAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {

        allowanceOf[_tokenHolder][_spender] = allowanceOf[_tokenHolder][_spender].sub(_value);

    }



    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {

        allowanceOf[_tokenHolder][_spender] = _value;

    }

}



// File: contracts/ProxyStorage.sol



pragma solidity >=0.4.25 <0.6.0;









/*

Defines the storage layout of the token implementaiton contract. Any newly declared

state variables in future upgrades should be appened to the bottom. Never remove state variables

from this list

 */

contract ProxyStorage {

    address public owner;

    address public pendingOwner;



    bool initialized;

    

    BalanceSheet balances_Deprecated;

    AllowanceSheet allowances_Deprecated;



    uint256 totalSupply_;

    

    bool private paused_Deprecated = false;

    address private globalPause_Deprecated;



    uint256 public burnMin = 0;

    uint256 public burnMax = 0;



    Registry public registry;



    string name_Deprecated;

    string symbol_Deprecated;



    uint[] gasRefundPool_Deprecated;

    uint256 private redemptionAddressCount_Deprecated;

    uint256 public minimumGasPriceForFutureRefunds;



    mapping (address => uint256) _balanceOf;

    mapping (address => mapping (address => uint256)) _allowance;

    mapping (bytes32 => mapping (address => uint256)) attributes;





    /* Additionally, we have several keccak-based storage locations.

     * If you add more keccak-based storage mappings, such as mappings, you must document them here.

     * If the length of the keccak input is the same as an existing mapping, it is possible there could be a preimage collision.

     * A preimage collision can be used to attack the contract by treating one storage location as another,

     * which would always be a critical issue.

     * Carefully examine future keccak-based storage to ensure there can be no preimage collisions.

     *******************************************************************************************************

     ** length     input                                                         usage

     *******************************************************************************************************

     ** 19         "trueXXX.proxy.owner"                                         Proxy Owner

     ** 27         "trueXXX.pending.proxy.owner"                                 Pending Proxy Owner

     ** 28         "trueXXX.proxy.implementation"                                Proxy Implementation

     ** 32         uint256(11)                                                   gasRefundPool_Deprecated

     ** 64         uint256(address),uint256(14)                                  balanceOf

     ** 64         uint256(address),keccak256(uint256(address),uint256(15))      allowance

     ** 64         uint256(address),keccak256(bytes32,uint256(16))               attributes

    **/

}



// File: contracts/HasOwner.sol



pragma solidity >=0.4.25 <0.6.0;





/**

 * @title HasOwner

 * @dev The HasOwner contract is a copy of Claimable Contract by Zeppelin. 

 and provides basic authorization control functions. Inherits storage layout of 

 ProxyStorage.

 */

contract HasOwner is ProxyStorage {



    event OwnershipTransferred(

        address indexed previousOwner,

        address indexed newOwner

    );



    /**

    * @dev sets the original `owner` of the contract to the sender

    * at construction. Must then be reinitialized 

    */

    constructor() public {

        owner = msg.sender;

        emit OwnershipTransferred(address(0), owner);

    }



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner, "only Owner");

        _;

    }



    /**

    * @dev Modifier throws if called by any account other than the pendingOwner.

    */

    modifier onlyPendingOwner() {

        require(msg.sender == pendingOwner);

        _;

    }



    /**

    * @dev Allows the current owner to set the pendingOwner address.

    * @param newOwner The address to transfer ownership to.

    */

    function transferOwnership(address newOwner) public onlyOwner {

        pendingOwner = newOwner;

    }



    /**

    * @dev Allows the pendingOwner address to finalize the transfer.

    */

    function claimOwnership() public onlyPendingOwner {

        emit OwnershipTransferred(owner, pendingOwner);

        owner = pendingOwner;

        pendingOwner = address(0);

    }

}



// File: contracts/TrueCoinReceiver.sol



pragma solidity >=0.4.25 <0.6.0;



contract TrueCoinReceiver {

    function tokenFallback( address from, uint256 value ) external;

}



// File: contracts/ReclaimerToken.sol



pragma solidity >=0.4.25 <0.6.0;





contract ReclaimerToken is HasOwner {

    /**  

    *@dev send all eth balance in the contract to another address

    */

    function reclaimEther(address payable _to) external onlyOwner {

        _to.transfer(address(this).balance);

    }



    /**  

    *@dev send all token balance of an arbitary erc20 token

    in the contract to another address

    */

    function reclaimToken(ERC20 token, address _to) external onlyOwner {

        uint256 balance = token.balanceOf(address(this));

        token.transfer(_to, balance);

    }



    /**  

    *@dev allows owner of the contract to gain ownership of any contract that the contract currently owns

    */

    function reclaimContract(Ownable _ownable) external onlyOwner {

        _ownable.transferOwnership(owner);

    }



}



// File: contracts/modularERC20/ModularBasicToken.sol



pragma solidity >=0.4.25 <0.6.0;







// Fork of OpenZeppelin's BasicToken

/**

 * @title Basic token

 * @dev Basic version of StandardToken, with no allowances.

 */

contract ModularBasicToken is HasOwner {

    using SafeMath for uint256;



    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

    * @dev total number of tokens in existence

    */

    function totalSupply() public view returns (uint256) {

        return totalSupply_;

    }



    function balanceOf(address _who) public view returns (uint256) {

        return _getBalance(_who);

    }



    function _getBalance(address _who) internal view returns (uint256) {

        return _balanceOf[_who];

    }



    function _addBalance(address _who, uint256 _value) internal returns (uint256 priorBalance) {

        priorBalance = _balanceOf[_who];

        _balanceOf[_who] = priorBalance.add(_value);

    }



    function _subBalance(address _who, uint256 _value) internal returns (uint256 result) {

        result = _balanceOf[_who].sub(_value);

        _balanceOf[_who] = result;

    }



    function _setBalance(address _who, uint256 _value) internal {

        _balanceOf[_who] = _value;

    }

}



// File: contracts/modularERC20/ModularStandardToken.sol



pragma solidity >=0.4.25 <0.6.0;







/**

 * @title Standard ERC20 token

 *

 * @dev Implementation of the basic standard token.

 * @dev https://github.com/ethereum/EIPs/issues/20

 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol

 */

contract ModularStandardToken is ModularBasicToken {

    using SafeMath for uint256;

    

    event Approval(address indexed owner, address indexed spender, uint256 value);

    

    /**

     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

     *

     * Beware that changing an allowance with this method brings the risk that someone may use both the old

     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     * @param _spender The address which will spend the funds.

     * @param _value The amount of tokens to be spent.

     */

    function approve(address _spender, uint256 _value) public returns (bool) {

        _approveAllArgs(_spender, _value, msg.sender);

        return true;

    }



    function _approveAllArgs(address _spender, uint256 _value, address _tokenHolder) internal {

        _setAllowance(_tokenHolder, _spender, _value);

        emit Approval(_tokenHolder, _spender, _value);

    }



    /**

     * @dev Increase the amount of tokens that an owner allowed to a spender.

     *

     * approve should be called when allowed[_spender] == 0. To increment

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * @param _spender The address which will spend the funds.

     * @param _addedValue The amount of tokens to increase the allowance by.

     */

    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {

        _increaseApprovalAllArgs(_spender, _addedValue, msg.sender);

        return true;

    }



    function _increaseApprovalAllArgs(address _spender, uint256 _addedValue, address _tokenHolder) internal {

        _addAllowance(_tokenHolder, _spender, _addedValue);

        emit Approval(_tokenHolder, _spender, _getAllowance(_tokenHolder, _spender));

    }



    /**

     * @dev Decrease the amount of tokens that an owner allowed to a spender.

     *

     * approve should be called when allowed[_spender] == 0. To decrement

     * allowed value is better to use this function to avoid 2 calls (and wait until

     * the first transaction is mined)

     * From MonolithDAO Token.sol

     * @param _spender The address which will spend the funds.

     * @param _subtractedValue The amount of tokens to decrease the allowance by.

     */

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {

        _decreaseApprovalAllArgs(_spender, _subtractedValue, msg.sender);

        return true;

    }



    function _decreaseApprovalAllArgs(address _spender, uint256 _subtractedValue, address _tokenHolder) internal {

        uint256 oldValue = _getAllowance(_tokenHolder, _spender);

        uint256 newValue;

        if (_subtractedValue > oldValue) {

            newValue = 0;

        } else {

            newValue = oldValue - _subtractedValue;

        }

        _setAllowance(_tokenHolder, _spender, newValue);

        emit Approval(_tokenHolder,_spender, newValue);

    }



    function allowance(address _who, address _spender) public view returns (uint256) {

        return _getAllowance(_who, _spender);

    }



    function _getAllowance(address _who, address _spender) internal view returns (uint256 value) {

        return _allowance[_who][_spender];

    }



    function _addAllowance(address _who, address _spender, uint256 _value) internal {

        _allowance[_who][_spender] = _allowance[_who][_spender].add(_value);

    }



    function _subAllowance(address _who, address _spender, uint256 _value) internal returns (uint256 newAllowance){

        newAllowance = _allowance[_who][_spender].sub(_value);

        _allowance[_who][_spender] = newAllowance;

    }



    function _setAllowance(address _who, address _spender, uint256 _value) internal {

        _allowance[_who][_spender] = _value;

    }

}



// File: contracts/modularERC20/ModularBurnableToken.sol



pragma solidity >=0.4.25 <0.6.0;





/**

 * @title Burnable Token

 * @dev Token that can be irreversibly burned (destroyed).

 */

contract ModularBurnableToken is ModularStandardToken {

    event Burn(address indexed burner, uint256 value);

    event Mint(address indexed to, uint256 value);

    uint256 constant CENT = 10 ** 6;



    function burn(uint256 _value) external {

        _burnAllArgs(msg.sender, _value - _value % CENT);

    }



    function _burnAllArgs(address _from, uint256 _value) internal {

        // no need to require value <= totalSupply, since that would imply the

        // sender's balance is greater than the totalSupply, which *should* be an assertion failure

        _subBalance(_from, _value);

        totalSupply_ = totalSupply_.sub(_value);

        emit Burn(_from, _value);

        emit Transfer(_from, address(0), _value);

    }

}



// File: contracts/BurnableTokenWithBounds.sol



pragma solidity >=0.4.25 <0.6.0;





/**

 * @title Burnable Token WithBounds

 * @dev Burning functions as redeeming money from the system. The platform will keep track of who burns coins,

 * and will send them back the equivalent amount of money (rounded down to the nearest cent).

 */

contract BurnableTokenWithBounds is ModularBurnableToken {



    event SetBurnBounds(uint256 newMin, uint256 newMax);



    function _burnAllArgs(address _burner, uint256 _value) internal {

        require(_value >= burnMin, "below min burn bound");

        require(_value <= burnMax, "exceeds max burn bound");

        super._burnAllArgs(_burner, _value);

    }



    //Change the minimum and maximum amount that can be burned at once. Burning

    //may be disabled by setting both to 0 (this will not be done under normal

    //operation, but we can't add checks to disallow it without losing a lot of

    //flexibility since burning could also be as good as disabled

    //by setting the minimum extremely high, and we don't want to lock

    //in any particular cap for the minimum)

    function setBurnBounds(uint256 _min, uint256 _max) external onlyOwner {

        require(_min <= _max, "min > max");

        burnMin = _min;

        burnMax = _max;

        emit SetBurnBounds(_min, _max);

    }

}



// File: contracts/CompliantDepositTokenWithHook.sol



pragma solidity >=0.4.25 <0.6.0;













contract CompliantDepositTokenWithHook is ReclaimerToken, RegistryClone, BurnableTokenWithBounds {



    bytes32 constant IS_REGISTERED_CONTRACT = "isRegisteredContract";

    bytes32 constant IS_DEPOSIT_ADDRESS = "isDepositAddress";

    uint256 constant REDEMPTION_ADDRESS_COUNT = 0x100000;

    bytes32 constant IS_BLACKLISTED = "isBlacklisted";

    uint256 _transferFee = 0;

    uint8   _transferFeeMode = 0;



    function canBurn() internal pure returns (bytes32);



    function setTransferFee(uint256 transferFee) public onlyOwner returns(bool){

        _transferFee = transferFee;

        return true;

    }



    function setTransferFeeMode(uint8 transferFeeMode) public onlyOwner returns (bool){

        _transferFeeMode = transferFeeMode;

        return true;

    }



    function transferFee() public view returns (uint256){

        return _transferFee;

    }



    function transferFeeMode() public view returns (uint8){

        return _transferFeeMode;

    }



    /**

    * @dev calculates fee required for the transfer

    * @param amount The address to transfer to.

    */

    function getTransactionFee(uint256 amount) public view returns (uint256){

        return amount.mul(_transferFee).div(8 ** 10);

    }



    /**

    * @dev transfer token for a specified address

    * @param _to The address to transfer to.

    * @param _value The amount to be transferred.

    */

    function transfer(address _to, uint256 _value) public returns (bool) {

        uint256 transfer_fee = getTransactionFee(_value);

        if(_transferFeeMode == 0 || transfer_fee == 0 ){

            _transferAllArgs(msg.sender, _to, _value);

        } else if(_transferFeeMode == 1){

            _transferAllArgs(msg.sender, owner, transfer_fee);

            _transferAllArgs(msg.sender, _to, _value);

        } else if(_transferFeeMode == 2){

            _transferAllArgs(msg.sender, owner, transfer_fee);

            _transferAllArgs(msg.sender, _to, _value.sub(transfer_fee));

        }

        return true;

    }



    /**

     * @dev Transfer tokens from one address to another

     * @param _from address The address which you want to send tokens from

     * @param _to address The address which you want to transfer to

     * @param _value uint256 the amount of tokens to be transferred

     */

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {

        uint256 transfer_fee = getTransactionFee(_value);

        if(_transferFeeMode == 0 || transfer_fee == 0 ){

            _transferFromAllArgs(_from, _to, _value, msg.sender);

        } else if(_transferFeeMode == 1){

            _transferFromAllArgs(_from, owner, transfer_fee, msg.sender);

            _transferFromAllArgs(_from, _to, _value, msg.sender);

        } else if(_transferFeeMode == 2){

            _transferFromAllArgs(_from, owner, transfer_fee, msg.sender);

            _transferFromAllArgs(_from, _to, _value.sub(transfer_fee), msg.sender);

        }

        return true;

    }



    function _burnFromAllowanceAllArgs(address _from, address _to, uint256 _value, address _spender) internal {

        _requireCanTransferFrom(_spender, _from, _to);

        _requireOnlyCanBurn(_to);

        require(_value >= burnMin, "below min burn bound");

        require(_value <= burnMax, "exceeds max burn bound");

        _subBalance(_from, _value);

        _subAllowance(_from, _spender, _value); 

        emit Transfer(_from, _to, _value);

        totalSupply_ = totalSupply_.sub(_value);

        emit Burn(_to, _value);

        emit Transfer(_to, address(0), _value);

    }



    function _burnFromAllArgs(address _from, address _to, uint256 _value) internal {

        _requireCanTransfer(_from, _to);

        _requireOnlyCanBurn(_to);

        require(_value >= burnMin, "below min burn bound");

        require(_value <= burnMax, "exceeds max burn bound");

        _subBalance(_from, _value);

        emit Transfer(_from, _to, _value);

        totalSupply_ = totalSupply_.sub(_value);

        emit Burn(_to, _value);

        emit Transfer(_to, address(0), _value);

    }



    function _transferFromAllArgs(address _from, address _to, uint256 _value, address _spender) internal {

        if (uint256(_to) < REDEMPTION_ADDRESS_COUNT) {

            _value -= _value % CENT;

            _burnFromAllowanceAllArgs(_from, _to, _value, _spender);

        } else {

            bool hasHook;

            address originalTo = _to;

            (_to, hasHook) = _requireCanTransferFrom(_spender, _from, _to);

            _addBalance(_to, _value);

            _subAllowance(_from, _spender, _value);

            _subBalance(_from, _value);

            emit Transfer(_from, originalTo, _value);

            if (originalTo != _to) {

                emit Transfer(originalTo, _to, _value);

                if (hasHook) {

                    TrueCoinReceiver(_to).tokenFallback(originalTo, _value);

                }

            } else {

                if (hasHook) {

                    TrueCoinReceiver(_to).tokenFallback(_from, _value);

                }

            }

        }

    }



    function _transferAllArgs(address _from, address _to, uint256 _value) internal {

        if (uint256(_to) < REDEMPTION_ADDRESS_COUNT) {

            _value -= _value % CENT;

            _burnFromAllArgs(_from, _to, _value);

        } else {

            bool hasHook;

            address finalTo;

            (finalTo, hasHook) = _requireCanTransfer(_from, _to);

            _subBalance(_from, _value);

            _addBalance(finalTo, _value);

            emit Transfer(_from, _to, _value);

            if (finalTo != _to) {

                emit Transfer(_to, finalTo, _value);

                if (hasHook) {

                    TrueCoinReceiver(finalTo).tokenFallback(_to, _value);

                }

            } else {

                if (hasHook) {

                    TrueCoinReceiver(finalTo).tokenFallback(_from, _value);

                }

            }

        }

    }



    function mint(address _to, uint256 _value) public onlyOwner {

        require(_to != address(0), "to address cannot be zero");

        bool hasHook;

        address originalTo = _to;

        (_to, hasHook) = _requireCanMint(_to);

        totalSupply_ = totalSupply_.add(_value);

        emit Mint(originalTo, _value);

        emit Transfer(address(0), originalTo, _value);

        if (_to != originalTo) {

            emit Transfer(originalTo, _to, _value);

        }

        _addBalance(_to, _value);

        if (hasHook) {

            if (_to != originalTo) {

                TrueCoinReceiver(_to).tokenFallback(originalTo, _value);

            } else {

                TrueCoinReceiver(_to).tokenFallback(address(0), _value);

            }

        }

    }



    event WipeBlacklistedAccount(address indexed account, uint256 balance);

    event SetRegistry(address indexed registry);



    /**

    * @dev Point to the registry that contains all compliance related data

    @param _registry The address of the registry instance

    */

    function setRegistry(Registry _registry) public onlyOwner {

        registry = _registry;

        emit SetRegistry(address(registry));

    }



    modifier onlyRegistry {

      require(msg.sender == address(registry));

      _;

    }



    function syncAttributeValue(address _who, bytes32 _attribute, uint256 _value) public onlyRegistry {

        attributes[_attribute][_who] = _value;

    }



    function _burnAllArgs(address _from, uint256 _value) internal {

        _requireCanBurn(_from);

        super._burnAllArgs(_from, _value);

    }



    // Destroy the tokens owned by a blacklisted account

    function wipeBlacklistedAccount(address _account) public onlyOwner {

        require(_isBlacklisted(_account), "_account is not blacklisted");

        uint256 oldValue = _getBalance(_account);

        _setBalance(_account, 0);

        totalSupply_ = totalSupply_.sub(oldValue);

        emit WipeBlacklistedAccount(_account, oldValue);

        emit Transfer(_account, address(0), oldValue);

    }



    function _isBlacklisted(address _account) internal view returns (bool blacklisted) {

        return attributes[IS_BLACKLISTED][_account] != 0;

    }



    function _requireCanTransfer(address _from, address _to) internal view returns (address, bool) {

        uint256 depositAddressValue = attributes[IS_DEPOSIT_ADDRESS][address(uint256(_to) >> 20)];

        if (depositAddressValue != 0) {

            _to = address(depositAddressValue);

        }

        require (attributes[IS_BLACKLISTED][_to] == 0, "blacklisted");

        require (attributes[IS_BLACKLISTED][_from] == 0, "blacklisted");

        return (_to, attributes[IS_REGISTERED_CONTRACT][_to] != 0);

    }



    function _requireCanTransferFrom(address _spender, address _from, address _to) internal view returns (address, bool) {

        require (attributes[IS_BLACKLISTED][_spender] == 0, "blacklisted");

        uint256 depositAddressValue = attributes[IS_DEPOSIT_ADDRESS][address(uint256(_to) >> 20)];

        if (depositAddressValue != 0) {

            _to = address(depositAddressValue);

        }

        require (attributes[IS_BLACKLISTED][_to] == 0, "blacklisted");

        require (attributes[IS_BLACKLISTED][_from] == 0, "blacklisted");

        return (_to, attributes[IS_REGISTERED_CONTRACT][_to] != 0);

    }



    function _requireCanMint(address _to) internal view returns (address, bool) {

        uint256 depositAddressValue = attributes[IS_DEPOSIT_ADDRESS][address(uint256(_to) >> 20)];

        if (depositAddressValue != 0) {

            _to = address(depositAddressValue);

        }

        require (attributes[IS_BLACKLISTED][_to] == 0, "blacklisted");

        return (_to, attributes[IS_REGISTERED_CONTRACT][_to] != 0);

    }



    function _requireOnlyCanBurn(address _from) internal view {

        require (attributes[canBurn()][_from] != 0, "cannot burn from this address");

    }



    function _requireCanBurn(address _from) internal view {

        require (attributes[IS_BLACKLISTED][_from] == 0, "blacklisted");

        require (attributes[canBurn()][_from] != 0, "cannot burn from this address");

    }



    function paused() public pure returns (bool) {

        return false;

    }

}



// File: contracts/Proxy/OwnedUpgradeabilityProxy.sol



pragma solidity >=0.4.25 <0.6.0;



/**

 * @title OwnedUpgradeabilityProxy

 * @dev This contract combines an upgradeability proxy with basic authorization control functionalities

 */

contract OwnedUpgradeabilityProxy {

    /**

    * @dev Event to show ownership has been transferred

    * @param previousOwner representing the address of the previous owner

    * @param newOwner representing the address of the new owner

    */

    event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

    * @dev Event to show ownership transfer is pending

    * @param currentOwner representing the address of the current owner

    * @param pendingOwner representing the address of the pending owner

    */

    event NewPendingOwner(address currentOwner, address pendingOwner);

    

    // Storage position of the owner and pendingOwner of the contract

    bytes32 private constant proxyOwnerPosition = 0x6004f6b6eb3de57beb988d207d67d1fd96d97f56565b653b6e80b856d7c1a35f;//keccak256("EURON.proxy.owner");

    bytes32 private constant pendingProxyOwnerPosition = 0x76a33b3ea4443d67022b6c5254816af27c5cfd5c856e0422ce98ad937f4d709d;//keccak256("EURON.pending.proxy.owner");



    /**

    * @dev the constructor sets the original owner of the contract to the sender account.

    */

    constructor() public {

        _setUpgradeabilityOwner(msg.sender);

    }



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyProxyOwner() {

        require(msg.sender == proxyOwner(), "only Proxy Owner");

        _;

    }



    /**

    * @dev Throws if called by any account other than the pending owner.

    */

    modifier onlyPendingProxyOwner() {

        require(msg.sender == pendingProxyOwner(), "only pending Proxy Owner");

        _;

    }



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function proxyOwner() public view returns (address owner) {

        bytes32 position = proxyOwnerPosition;

        assembly {

            owner := sload(position)

        }

    }



    /**

    * @dev Tells the address of the owner

    * @return the address of the owner

    */

    function pendingProxyOwner() public view returns (address pendingOwner) {

        bytes32 position = pendingProxyOwnerPosition;

        assembly {

            pendingOwner := sload(position)

        }

    }



    /**

    * @dev Sets the address of the owner

    */

    function _setUpgradeabilityOwner(address newProxyOwner) internal {

        bytes32 position = proxyOwnerPosition;

        assembly {

            sstore(position, newProxyOwner)

        }

    }



    /**

    * @dev Sets the address of the owner

    */

    function _setPendingUpgradeabilityOwner(address newPendingProxyOwner) internal {

        bytes32 position = pendingProxyOwnerPosition;

        assembly {

            sstore(position, newPendingProxyOwner)

        }

    }



    /**

    * @dev Allows the current owner to transfer control of the contract to a newOwner.

    *changes the pending owner to newOwner. But doesn't actually transfer

    * @param newOwner The address to transfer ownership to.

    */

    function transferProxyOwnership(address newOwner) external onlyProxyOwner {

        require(newOwner != address(0));

        _setPendingUpgradeabilityOwner(newOwner);

        emit NewPendingOwner(proxyOwner(), newOwner);

    }



    /**

    * @dev Allows the pendingOwner to claim ownership of the proxy

    */

    function claimProxyOwnership() external onlyPendingProxyOwner {

        emit ProxyOwnershipTransferred(proxyOwner(), pendingProxyOwner());

        _setUpgradeabilityOwner(pendingProxyOwner());

        _setPendingUpgradeabilityOwner(address(0));

    }



    /**

    * @dev Allows the proxy owner to upgrade the current version of the proxy.

    * @param implementation representing the address of the new implementation to be set.

    */

    function upgradeTo(address implementation) external onlyProxyOwner {

        address currentImplementation;

        bytes32 position = implementationPosition;

        assembly {

            currentImplementation := sload(position)

        }

        require(currentImplementation != implementation);

        assembly {

          sstore(position, implementation)

        }

        emit Upgraded(implementation);

    }

    /**

    * @dev This event will be emitted every time the implementation gets upgraded

    * @param implementation representing the address of the upgraded implementation

    */

    event Upgraded(address indexed implementation);



    // Storage position of the address of the current implementation

    bytes32 private constant implementationPosition = 0x84b64b507833ba7e4ea61b69390489bd134000b6d1333e6a1617aac294fa83f7; //keccak256("EURON.proxy.implementation");



    function implementation() public view returns (address impl) {

        bytes32 position = implementationPosition;

        assembly {

            impl := sload(position)

        }

    }



    /**

    * @dev Fallback function allowing to perform a delegatecall to the given implementation.

    * This function will return whatever the implementation call returns

    */

    function() external payable {

        bytes32 position = implementationPosition;

        

        assembly {

            let ptr := mload(0x40)

            calldatacopy(ptr, returndatasize, calldatasize)

            let result := delegatecall(gas, sload(position), ptr, calldatasize, returndatasize, returndatasize)

            returndatacopy(ptr, 0, returndatasize)



            switch result

            case 0 { revert(ptr, returndatasize) }

            default { return(ptr, returndatasize) }

        }

    }

}



// File: contracts/Admin/TokenController.sol



pragma solidity >=0.4.25 <0.6.0;













/** @title TokenController

@dev This contract allows us to split ownership of the EURON contract

into two addresses. One, called the "owner" address, has unfettered control of the EURON contract -

it can mint new tokens, transfer ownership of the contract, etc. However to make

extra sure that EURON is never compromised, this owner key will not be used in

day-to-day operations, allowing it to be stored at a heightened level of security.

Instead, the owner appoints an various "admin" address. 

There are 3 different types of admin addresses;  MintKey, MintRatifier, and MintPauser. 

MintKey can request and revoke mints one at a time.

MintPausers can pause individual mints or pause all mints.

MintRatifiers can approve and finalize mints with enough approval.



There are three levels of mints: instant mint, ratified mint, and multiSig mint. Each have a different threshold

and deduct from a different pool.

Instant mint has the lowest threshold and finalizes instantly without any ratifiers. Deduct from instant mint pool,

which can be refilled by one ratifier.

Ratify mint has the second lowest threshold and finalizes with one ratifier approval. Deduct from ratify mint pool,

which can be refilled by three ratifiers.

MultiSig mint has the highest threshold and finalizes with three ratifier approvals. Deduct from multiSig mint pool,

which can only be refilled by the owner.

*/



contract TokenController {

    using SafeMath for uint256;



    struct MintOperation {

        address to;

        uint256 value;

        uint256 requestedBlock;

        uint256 numberOfApproval;

        bool paused;

        mapping(address => bool) approved; 

    }



    address public owner;

    address public pendingOwner;



    bool public initialized;



    uint256 public instantMintThreshold;

    uint256 public ratifiedMintThreshold;

    uint256 public multiSigMintThreshold;





    uint256 public instantMintLimit; 

    uint256 public ratifiedMintLimit; 

    uint256 public multiSigMintLimit;



    uint256 public instantMintPool; 

    uint256 public ratifiedMintPool; 

    uint256 public multiSigMintPool;

    address[2] public ratifiedPoolRefillApprovals;



    uint8 constant public RATIFY_MINT_SIGS = 1; //number of approvals needed to finalize a Ratified Mint

    uint8 constant public MULTISIG_MINT_SIGS = 3; //number of approvals needed to finalize a MultiSig Mint



    bool public mintPaused;

    uint256 public mintReqInvalidBeforeThisBlock; //all mint request before this block are invalid

    address public mintKey;

    MintOperation[] public mintOperations; //list of a mint requests

    

    CompliantDepositTokenWithHook public token;

    OwnedUpgradeabilityProxy public token_proxy;

    Registry public registry;

    address public fastPause;



    bytes32 constant public IS_MINT_PAUSER = "isURONMintPausers";

    bytes32 constant public IS_MINT_RATIFIER = "isURONMintRatifier";

    bytes32 constant public IS_REDEMPTION_ADMIN = "isURONRedemptionAdmin";



    address constant public PAUSED_IMPLEMENTATION = 0xfA2350552ba1593E7D3Abd284C4d55ae26aAEa20; // ***To be changed the paused version of EURON in Production



    



    modifier onlyFastPauseOrOwner() {

        require(msg.sender == fastPause || msg.sender == owner, "must be pauser or owner");

        _;

    }



    modifier onlyMintKeyOrOwner() {

        require(msg.sender == mintKey || msg.sender == owner, "must be mintKey or owner");

        _;

    }



    modifier onlyMintPauserOrOwner() {

        require(registry.hasAttribute(msg.sender, IS_MINT_PAUSER) || msg.sender == owner, "must be pauser or owner");

        _;

    }



    modifier onlyMintRatifierOrOwner() {

        require(registry.hasAttribute(msg.sender, IS_MINT_RATIFIER) || msg.sender == owner, "must be ratifier or owner");

        _;

    }



    modifier onlyOwnerOrRedemptionAdmin() {

        require(registry.hasAttribute(msg.sender, IS_REDEMPTION_ADMIN) || msg.sender == owner, "must be Redemption admin or owner");

        _;

    }



    //mint operations by the mintkey cannot be processed on when mints are paused

    modifier mintNotPaused() {

        if (msg.sender != owner) {

            require(!mintPaused, "minting is paused");

        }

        _;

    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    event NewOwnerPending(address indexed currentOwner, address indexed pendingOwner);

    event SetRegistry(address indexed registry);

    event TransferChild(address indexed child, address indexed newOwner);

    event RequestReclaimContract(address indexed other);

    event SetToken(CompliantDepositTokenWithHook newContract);

    

    event RequestMint(address indexed to, uint256 indexed value, uint256 opIndex, address mintKey);

    event FinalizeMint(address indexed to, uint256 indexed value, uint256 opIndex, address mintKey);

    event InstantMint(address indexed to, uint256 indexed value, address indexed mintKey);

    

    event TransferMintKey(address indexed previousMintKey, address indexed newMintKey);

    event MintRatified(uint256 indexed opIndex, address indexed ratifier);

    event RevokeMint(uint256 opIndex);

    event AllMintsPaused(bool status);

    event MintPaused(uint opIndex, bool status);

    event MintApproved(address approver, uint opIndex);

    event FastPauseSet(address _newFastPause);



    event MintThresholdChanged(uint instant, uint ratified, uint multiSig);

    event MintLimitsChanged(uint instant, uint ratified, uint multiSig);

    event InstantPoolRefilled();

    event RatifyPoolRefilled();

    event MultiSigPoolRefilled();



    /*

    ========================================

    Ownership functions

    ========================================

    */



    function initialize() external {

        require(!initialized, "already initialized");

        owner = msg.sender;

        initialized = true;

    }



    /**

    * @dev Throws if called by any account other than the owner.

    */

    modifier onlyOwner() {

        require(msg.sender == owner, "only controller Owner");

        _;

    }



    /**

    * @dev Modifier throws if called by any account other than the pendingOwner.

    */

    modifier onlyPendingOwner() {

        require(msg.sender == pendingOwner);

        _;

    }



    /**

    * @dev Allows the current owner to set the pendingOwner address.

    * @param newOwner The address to transfer ownership to.

    */

    function transferOwnership(address newOwner) external onlyOwner {

        pendingOwner = newOwner;

        emit NewOwnerPending(owner, pendingOwner);

    }



    /**

    * @dev Allows the pendingOwner address to finalize the transfer.

    */

    function claimOwnership() external onlyPendingOwner {

        emit OwnershipTransferred(owner, pendingOwner);

        owner = pendingOwner;

        pendingOwner = address(0);

    }

    

    /*

    ========================================

    proxy functions

    ========================================

    */



    function transferEURONProxyOwnership(address _newOwner) external onlyOwner {

        OwnedUpgradeabilityProxy(token_proxy).transferProxyOwnership(_newOwner);

    }



    function claimEURONProxyOwnership() external onlyOwner {

        OwnedUpgradeabilityProxy(token_proxy).claimProxyOwnership();

    }



    function upgradeEURONProxyImplTo(address _implementation) external onlyOwner {

        OwnedUpgradeabilityProxy(token_proxy).upgradeTo(_implementation);

    }



    /*

    ========================================

    Minting functions

    ========================================

    */



    /**

     * @dev set the threshold for a mint to be considered an instant mint, ratify mint and multiSig mint

     Instant mint requires no approval, ratify mint requires 1 approval and multiSig mint requires 3 approvals

     */

    function setMintThresholds(uint256 _instant, uint256 _ratified, uint256 _multiSig) external onlyOwner {

        require(_instant <= _ratified && _ratified <= _multiSig);

        instantMintThreshold = _instant;

        ratifiedMintThreshold = _ratified;

        multiSigMintThreshold = _multiSig;

        emit MintThresholdChanged(_instant, _ratified, _multiSig);

    }





    /**

     * @dev set the limit of each mint pool. For example can only instant mint up to the instant mint pool limit

     before needing to refill

     */

    function setMintLimits(uint256 _instant, uint256 _ratified, uint256 _multiSig) external onlyOwner {

        require(_instant <= _ratified && _ratified <= _multiSig);

        instantMintLimit = _instant;

        if (instantMintPool > instantMintLimit) {

            instantMintPool = instantMintLimit;

        }

        ratifiedMintLimit = _ratified;

        if (ratifiedMintPool > ratifiedMintLimit) {

            ratifiedMintPool = ratifiedMintLimit;

        }

        multiSigMintLimit = _multiSig;

        if (multiSigMintPool > multiSigMintLimit) {

            multiSigMintPool = multiSigMintLimit;

        }

        emit MintLimitsChanged(_instant, _ratified, _multiSig);

    }



    /**

     * @dev Ratifier can refill instant mint pool

     */

    function refillInstantMintPool() external onlyMintRatifierOrOwner {

        ratifiedMintPool = ratifiedMintPool.sub(instantMintLimit.sub(instantMintPool));

        instantMintPool = instantMintLimit;

        emit InstantPoolRefilled();

    }



    /**

     * @dev Owner or 3 ratifiers can refill Ratified Mint Pool

     */

    function refillRatifiedMintPool() external onlyMintRatifierOrOwner {

        if (msg.sender != owner) {

            address[2] memory refillApprovals = ratifiedPoolRefillApprovals;

            require(msg.sender != refillApprovals[0] && msg.sender != refillApprovals[1]);

            if (refillApprovals[0] == address(0)) {

                ratifiedPoolRefillApprovals[0] = msg.sender;

                return;

            } 

            if (refillApprovals[1] == address(0)) {

                ratifiedPoolRefillApprovals[1] = msg.sender;

                return;

            } 

        }

        delete ratifiedPoolRefillApprovals; // clears the whole array

        multiSigMintPool = multiSigMintPool.sub(ratifiedMintLimit.sub(ratifiedMintPool));

        ratifiedMintPool = ratifiedMintLimit;

        emit RatifyPoolRefilled();

    }



    /**

     * @dev Owner can refill MultiSig Mint Pool

     */

    function refillMultiSigMintPool() external onlyOwner {

        multiSigMintPool = multiSigMintLimit;

        emit MultiSigPoolRefilled();

    }



    /**

     * @dev mintKey initiates a request to mint _value for account _to

     * @param _to the address to mint to

     * @param _value the amount requested

     */

    function requestMint(address _to, uint256 _value) external mintNotPaused onlyMintKeyOrOwner {

        MintOperation memory op = MintOperation(_to, _value, block.number, 0, false);

        emit RequestMint(_to, _value, mintOperations.length, msg.sender);

        mintOperations.push(op);

    }





    /**

     * @dev Instant mint without ratification if the amount is less than instantMintThreshold and instantMintPool

     * @param _to the address to mint to

     * @param _value the amount minted

     */

    function instantMint(address _to, uint256 _value) external mintNotPaused onlyMintKeyOrOwner {

        require(_value <= instantMintThreshold, "over the instant mint threshold");

        require(_value <= instantMintPool, "instant mint pool is dry");

        instantMintPool = instantMintPool.sub(_value);

        emit InstantMint(_to, _value, msg.sender);

        token.mint(_to, _value);

    }





    /**

     * @dev ratifier ratifies a request mint. If the number of ratifiers that signed off is greater than 

     the number of approvals required, the request is finalized

     * @param _index the index of the requestMint to ratify

     * @param _to the address to mint to

     * @param _value the amount requested

     */

    function ratifyMint(uint256 _index, address _to, uint256 _value) external mintNotPaused onlyMintRatifierOrOwner {

        MintOperation memory op = mintOperations[_index];

        require(op.to == _to, "to address does not match");

        require(op.value == _value, "amount does not match");

        require(!mintOperations[_index].approved[msg.sender], "already approved");

        mintOperations[_index].approved[msg.sender] = true;

        mintOperations[_index].numberOfApproval = mintOperations[_index].numberOfApproval.add(1);

        emit MintRatified(_index, msg.sender);

        if (hasEnoughApproval(mintOperations[_index].numberOfApproval, _value)){

            finalizeMint(_index);

        }

    }



    /**

     * @dev finalize a mint request, mint the amount requested to the specified address

     @param _index of the request (visible in the RequestMint event accompanying the original request)

     */

    function finalizeMint(uint256 _index) public mintNotPaused {

        MintOperation memory op = mintOperations[_index];

        address to = op.to;

        uint256 value = op.value;

        if (msg.sender != owner) {

            require(canFinalize(_index));

            _subtractFromMintPool(value);

        }

        delete mintOperations[_index];

        token.mint(to, value);

        emit FinalizeMint(to, value, _index, msg.sender);

    }



    /**

     * assumption: only invoked when canFinalize

     */

    function _subtractFromMintPool(uint256 _value) internal {

        if (_value <= ratifiedMintPool && _value <= ratifiedMintThreshold) {

            ratifiedMintPool = ratifiedMintPool.sub(_value);

        } else {

            multiSigMintPool = multiSigMintPool.sub(_value);

        }

    }



    /**

     * @dev compute if the number of approvals is enough for a given mint amount

     */

    function hasEnoughApproval(uint256 _numberOfApproval, uint256 _value) public view returns (bool) {

        if (_value <= ratifiedMintPool && _value <= ratifiedMintThreshold) {

            if (_numberOfApproval >= RATIFY_MINT_SIGS){

                return true;

            }

        }

        if (_value <= multiSigMintPool && _value <= multiSigMintThreshold) {

            if (_numberOfApproval >= MULTISIG_MINT_SIGS){

                return true;

            }

        }

        if (msg.sender == owner) {

            return true;

        }

        return false;

    }



    /**

     * @dev compute if a mint request meets all the requirements to be finalized

     utility function for a front end

     */

    function canFinalize(uint256 _index) public view returns(bool) {

        MintOperation memory op = mintOperations[_index];

        require(op.requestedBlock > mintReqInvalidBeforeThisBlock, "this mint is invalid"); //also checks if request still exists

        require(!op.paused, "this mint is paused");

        require(hasEnoughApproval(op.numberOfApproval, op.value), "not enough approvals");

        return true;

    }



    /** 

    *@dev revoke a mint request, Delete the mintOperation

    *@param index of the request (visible in the RequestMint event accompanying the original request)

    */

    function revokeMint(uint256 _index) external onlyMintKeyOrOwner {

        delete mintOperations[_index];

        emit RevokeMint(_index);

    }



    function mintOperationCount() public view returns (uint256) {

        return mintOperations.length;

    }



    /*

    ========================================

    Key management

    ========================================

    */



    /** 

    *@dev Replace the current mintkey with new mintkey 

    *@param _newMintKey address of the new mintKey

    */

    function transferMintKey(address _newMintKey) external onlyOwner {

        require(_newMintKey != address(0), "new mint key cannot be 0x0");

        emit TransferMintKey(mintKey, _newMintKey);

        mintKey = _newMintKey;

    }

 

    /*

    ========================================

    Mint Pausing

    ========================================

    */



    /** 

    *@dev invalidates all mint request initiated before the current block 

    */

    function invalidateAllPendingMints() external onlyOwner {

        mintReqInvalidBeforeThisBlock = block.number;

    }



    /** 

    *@dev pause any further mint request and mint finalizations 

    */

    function pauseMints() external onlyMintPauserOrOwner {

        mintPaused = true;

        emit AllMintsPaused(true);

    }



    /** 

    *@dev unpause any further mint request and mint finalizations 

    */

    function unpauseMints() external onlyOwner {

        mintPaused = false;

        emit AllMintsPaused(false);

    }



    /** 

    *@dev pause a specific mint request

    *@param  _opIndex the index of the mint request the caller wants to pause

    */

    function pauseMint(uint _opIndex) external onlyMintPauserOrOwner {

        mintOperations[_opIndex].paused = true;

        emit MintPaused(_opIndex, true);

    }



    /** 

    *@dev unpause a specific mint request

    *@param  _opIndex the index of the mint request the caller wants to unpause

    */

    function unpauseMint(uint _opIndex) external onlyOwner {

        mintOperations[_opIndex].paused = false;

        emit MintPaused(_opIndex, false);

    }



    /*

    ========================================

    set and claim contracts, administrative

    ========================================

    */



    /** 

    *@dev Set Transfer Fee

    */



    function setTransferFee(uint256 transferFee) external onlyOwner {

        token.setTransferFee(transferFee);

    }



    /** 

    *@dev Update this contract's token pointer to newContract (e.g. if the

    contract is upgraded)

    */

    function setToken(address _newContract) external onlyOwner {

        token = CompliantDepositTokenWithHook(_newContract);

        token_proxy = OwnedUpgradeabilityProxy(uint160(_newContract));

        emit SetToken(token);

    }



    /** 

    *@dev Update this contract's registry pointer to _registry

    */

    function setRegistry(Registry _registry) external onlyOwner {

        registry = _registry;

        emit SetRegistry( address(registry));

    }



    /** 

    *@dev Swap out token's permissions registry

    *@param _registry new registry for token

    */

    function setTokenRegistry(Registry _registry) external onlyOwner {

        token.setRegistry(_registry);

    }



    /** 

    *@dev Claim ownership of an arbitrary HasOwner contract

    */

    function issueClaimOwnership(address _other) public onlyOwner {

        HasOwner other = HasOwner(_other);

        other.claimOwnership();

    }



    /** 

    *@dev Transfer ownership of _child to _newOwner.

    Can be used e.g. to upgrade this TokenController contract.

    *@param _child contract that tokenController currently Owns 

    *@param _newOwner new owner/pending owner of _child

    */

    function transferChild(HasOwner _child, address _newOwner) external onlyOwner {

        _child.transferOwnership(_newOwner);

        emit TransferChild(address(_child), _newOwner);

    }



    /** 

    *@dev Transfer ownership of a contract from token to this TokenController.

    Can be used e.g. to reclaim balance sheet

    in order to transfer it to an upgraded EURON contract.

    *@param _other address of the contract to claim ownership of

    */

    function requestReclaimContract(Ownable _other) public onlyOwner {

        token.reclaimContract(_other);

        emit RequestReclaimContract( address(_other));

    }



    /** 

    *@dev send all ether in token address to the owner of tokenController 

    */

    function requestReclaimEther() external onlyOwner {

        address payable owners_address = address( uint160(owner));

        token.reclaimEther(owners_address);

    }



    /** 

    *@dev transfer all tokens of a particular type in token address to the

    owner of tokenController 

    *@param _token token address of the token to transfer

    */

    function requestReclaimToken(ERC20 _token) external onlyOwner {

        token.reclaimToken(_token, owner);

    }



    /** 

    *@dev set new contract to which specified address can send eth to to quickly pause token

    *@param _newFastPause address of the new contract

    */

    function setFastPause(address _newFastPause) external onlyOwner {

        fastPause = _newFastPause;

        emit FastPauseSet(_newFastPause);

    }



    /** 

    *@dev pause all pausable actions on EURON, mints/burn/transfer/approve

    */

    function pauseToken() external onlyFastPauseOrOwner {

        OwnedUpgradeabilityProxy(token_proxy).upgradeTo(PAUSED_IMPLEMENTATION);

    }

    

    /** 

    *@dev wipe balance of a blacklisted address

    *@param _blacklistedAddress address whose balance will be wiped

    */

    function wipeBlackListedEURON(address _blacklistedAddress) external onlyOwner {

        token.wipeBlacklistedAccount(_blacklistedAddress);

    }



    /** 

    *@dev Change the minimum and maximum amounts that EURON users can

    burn to newMin and newMax

    *@param _min minimum amount user can burn at a time

    *@param _max maximum amount user can burn at a time

    */

    function setBurnBounds(uint256 _min, uint256 _max) external onlyOwner {

        token.setBurnBounds(_min, _max);

    }



    /** 

    *@dev Owner can send ether balance in contract address

    *@param _to address to which the funds will be send to

    */

    function reclaimEther(address payable _to) external onlyOwner {

        _to.transfer(address(this).balance);

    }



    /** 

    *@dev Owner can send erc20 token balance in contract address

    *@param _token address of the token to send

    *@param _to address to which the funds will be send to

    */

    function reclaimToken(ERC20 _token, address _to) external onlyOwner {

        uint256 balance = _token.balanceOf(address(this));

        _token.transfer(_to, balance);

    }

}