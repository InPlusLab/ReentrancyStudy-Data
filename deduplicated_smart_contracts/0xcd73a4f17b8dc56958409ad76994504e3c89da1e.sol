/**

 *Submitted for verification at Etherscan.io on 2019-03-13

*/



// hevm: flattened sources of src/DPTICO.sol

pragma solidity >=0.4.8 <0.5.0 >=0.4.13 <0.5.0 >=0.4.23 <0.5.0;



////// lib/ds-auth/src/auth.sol

// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU General Public License as published by

// the Free Software Foundation, either version 3 of the License, or

// (at your option) any later version.



// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU General Public License for more details.



// You should have received a copy of the GNU General Public License

// along with this program.  If not, see <http://www.gnu.org/licenses/>.



/* pragma solidity ^0.4.23; */



contract DSAuthority {

    function canCall(

        address src, address dst, bytes4 sig

    ) public view returns (bool);

}



contract DSAuthEvents {

    event LogSetAuthority (address indexed authority);

    event LogSetOwner     (address indexed owner);

}



contract DSAuth is DSAuthEvents {

    DSAuthority  public  authority;

    address      public  owner;



    constructor() public {

        owner = msg.sender;

        emit LogSetOwner(msg.sender);

    }



    function setOwner(address owner_)

        public

        auth

    {

        owner = owner_;

        emit LogSetOwner(owner);

    }



    function setAuthority(DSAuthority authority_)

        public

        auth

    {

        authority = authority_;

        emit LogSetAuthority(authority);

    }



    modifier auth {

        require(isAuthorized(msg.sender, msg.sig));

        _;

    }



    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {

        if (src == address(this)) {

            return true;

        } else if (src == owner) {

            return true;

        } else if (authority == DSAuthority(0)) {

            return false;

        } else {

            return authority.canCall(src, this, sig);

        }

    }

}



////// lib/ds-math/src/math.sol

/// math.sol -- mixin for inline numerical wizardry



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU General Public License as published by

// the Free Software Foundation, either version 3 of the License, or

// (at your option) any later version.



// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU General Public License for more details.



// You should have received a copy of the GNU General Public License

// along with this program.  If not, see <http://www.gnu.org/licenses/>.



/* pragma solidity ^0.4.13; */



contract DSMath {

    function add(uint x, uint y) internal pure returns (uint z) {

        require((z = x + y) >= x);

    }

    function sub(uint x, uint y) internal pure returns (uint z) {

        require((z = x - y) <= x);

    }

    function mul(uint x, uint y) internal pure returns (uint z) {

        require(y == 0 || (z = x * y) / y == x);

    }



    function min(uint x, uint y) internal pure returns (uint z) {

        return x <= y ? x : y;

    }

    function max(uint x, uint y) internal pure returns (uint z) {

        return x >= y ? x : y;

    }

    function imin(int x, int y) internal pure returns (int z) {

        return x <= y ? x : y;

    }

    function imax(int x, int y) internal pure returns (int z) {

        return x >= y ? x : y;

    }



    uint constant WAD = 10 ** 18;

    uint constant RAY = 10 ** 27;



    function wmul(uint x, uint y) internal pure returns (uint z) {

        z = add(mul(x, y), WAD / 2) / WAD;

    }

    function rmul(uint x, uint y) internal pure returns (uint z) {

        z = add(mul(x, y), RAY / 2) / RAY;

    }

    function wdiv(uint x, uint y) internal pure returns (uint z) {

        z = add(mul(x, WAD), y / 2) / y;

    }

    function rdiv(uint x, uint y) internal pure returns (uint z) {

        z = add(mul(x, RAY), y / 2) / y;

    }



    // This famous algorithm is called "exponentiation by squaring"

    // and calculates x^n with x as fixed-point and n as regular unsigned.

    //

    // It's O(log n), instead of O(n) for naive repeated multiplication.

    //

    // These facts are why it works:

    //

    //  If n is even, then x^n = (x^2)^(n/2).

    //  If n is odd,  then x^n = x * x^(n-1),

    //   and applying the equation for even x gives

    //    x^n = x * (x^2)^((n-1) / 2).

    //

    //  Also, EVM division is flooring and

    //    floor[(n-1) / 2] = floor[n / 2].

    //

    function rpow(uint x, uint n) internal pure returns (uint z) {

        z = n % 2 != 0 ? x : RAY;



        for (n /= 2; n != 0; n /= 2) {

            x = rmul(x, x);



            if (n % 2 != 0) {

                z = rmul(z, x);

            }

        }

    }

}



////// lib/ds-note/src/note.sol

/// note.sol -- the `note' modifier, for logging calls as events



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU General Public License as published by

// the Free Software Foundation, either version 3 of the License, or

// (at your option) any later version.



// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU General Public License for more details.



// You should have received a copy of the GNU General Public License

// along with this program.  If not, see <http://www.gnu.org/licenses/>.



/* pragma solidity ^0.4.23; */



contract DSNote {

    event LogNote(

        bytes4   indexed  sig,

        address  indexed  guy,

        bytes32  indexed  foo,

        bytes32  indexed  bar,

        uint              wad,

        bytes             fax

    ) anonymous;



    modifier note {

        bytes32 foo;

        bytes32 bar;



        assembly {

            foo := calldataload(4)

            bar := calldataload(36)

        }



        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);



        _;

    }

}



////// lib/ds-stop/src/stop.sol

/// stop.sol -- mixin for enable/disable functionality



// Copyright (C) 2017  DappHub, LLC



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU General Public License as published by

// the Free Software Foundation, either version 3 of the License, or

// (at your option) any later version.



// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU General Public License for more details.



// You should have received a copy of the GNU General Public License

// along with this program.  If not, see <http://www.gnu.org/licenses/>.



/* pragma solidity ^0.4.23; */



/* import "ds-auth/auth.sol"; */

/* import "ds-note/note.sol"; */



contract DSStop is DSNote, DSAuth {



    bool public stopped;



    modifier stoppable {

        require(!stopped);

        _;

    }

    function stop() public auth note {

        stopped = true;

    }

    function start() public auth note {

        stopped = false;

    }



}



////// lib/ds-token/lib/erc20/src/erc20.sol

/// erc20.sol -- API for the ERC20 token standard



// See <https://github.com/ethereum/EIPs/issues/20>.



// This file likely does not meet the threshold of originality

// required for copyright to apply.  As a result, this is free and

// unencumbered software belonging to the public domain.



/* pragma solidity ^0.4.8; */



contract ERC20Events {

    event Approval(address indexed src, address indexed guy, uint wad);

    event Transfer(address indexed src, address indexed dst, uint wad);

}



contract ERC20 is ERC20Events {

    function totalSupply() public view returns (uint);

    function balanceOf(address guy) public view returns (uint);

    function allowance(address src, address guy) public view returns (uint);



    function approve(address guy, uint wad) public returns (bool);

    function transfer(address dst, uint wad) public returns (bool);

    function transferFrom(

        address src, address dst, uint wad

    ) public returns (bool);

}



////// lib/ds-token/src/base.sol

/// base.sol -- basic ERC20 implementation



// Copyright (C) 2015, 2016, 2017  DappHub, LLC



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU General Public License as published by

// the Free Software Foundation, either version 3 of the License, or

// (at your option) any later version.



// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU General Public License for more details.



// You should have received a copy of the GNU General Public License

// along with this program.  If not, see <http://www.gnu.org/licenses/>.



/* pragma solidity ^0.4.23; */



/* import "erc20/erc20.sol"; */

/* import "ds-math/math.sol"; */



contract DSTokenBase is ERC20, DSMath {

    uint256                                            _supply;

    mapping (address => uint256)                       _balances;

    mapping (address => mapping (address => uint256))  _approvals;



    constructor(uint supply) public {

        _balances[msg.sender] = supply;

        _supply = supply;

    }



    function totalSupply() public view returns (uint) {

        return _supply;

    }

    function balanceOf(address src) public view returns (uint) {

        return _balances[src];

    }

    function allowance(address src, address guy) public view returns (uint) {

        return _approvals[src][guy];

    }



    function transfer(address dst, uint wad) public returns (bool) {

        return transferFrom(msg.sender, dst, wad);

    }



    function transferFrom(address src, address dst, uint wad)

        public

        returns (bool)

    {

        if (src != msg.sender) {

            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);

        }



        _balances[src] = sub(_balances[src], wad);

        _balances[dst] = add(_balances[dst], wad);



        emit Transfer(src, dst, wad);



        return true;

    }



    function approve(address guy, uint wad) public returns (bool) {

        _approvals[msg.sender][guy] = wad;



        emit Approval(msg.sender, guy, wad);



        return true;

    }

}



////// lib/ds-token/src/token.sol

/// token.sol -- ERC20 implementation with minting and burning



// Copyright (C) 2015, 2016, 2017  DappHub, LLC



// This program is free software: you can redistribute it and/or modify

// it under the terms of the GNU General Public License as published by

// the Free Software Foundation, either version 3 of the License, or

// (at your option) any later version.



// This program is distributed in the hope that it will be useful,

// but WITHOUT ANY WARRANTY; without even the implied warranty of

// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// GNU General Public License for more details.



// You should have received a copy of the GNU General Public License

// along with this program.  If not, see <http://www.gnu.org/licenses/>.



/* pragma solidity ^0.4.23; */



/* import "ds-stop/stop.sol"; */



/* import "./base.sol"; */



contract DSToken is DSTokenBase(0), DSStop {



    bytes32  public  symbol;

    uint256  public  decimals = 18; // standard token precision. override to customize



    constructor(bytes32 symbol_) public {

        symbol = symbol_;

    }



    event Mint(address indexed guy, uint wad);

    event Burn(address indexed guy, uint wad);



    function approve(address guy) public stoppable returns (bool) {

        return super.approve(guy, uint(-1));

    }



    function approve(address guy, uint wad) public stoppable returns (bool) {

        return super.approve(guy, wad);

    }



    function transferFrom(address src, address dst, uint wad)

        public

        stoppable

        returns (bool)

    {

        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {

            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);

        }



        _balances[src] = sub(_balances[src], wad);

        _balances[dst] = add(_balances[dst], wad);



        emit Transfer(src, dst, wad);



        return true;

    }



    function push(address dst, uint wad) public {

        transferFrom(msg.sender, dst, wad);

    }

    function pull(address src, uint wad) public {

        transferFrom(src, msg.sender, wad);

    }

    function move(address src, address dst, uint wad) public {

        transferFrom(src, dst, wad);

    }



    function mint(uint wad) public {

        mint(msg.sender, wad);

    }

    function burn(uint wad) public {

        burn(msg.sender, wad);

    }

    function mint(address guy, uint wad) public auth stoppable {

        _balances[guy] = add(_balances[guy], wad);

        _supply = add(_supply, wad);

        emit Mint(guy, wad);

    }

    function burn(address guy, uint wad) public auth stoppable {

        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {

            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);

        }



        _balances[guy] = sub(_balances[guy], wad);

        _supply = sub(_supply, wad);

        emit Burn(guy, wad);

    }



    // Optional token name

    bytes32   public  name = "";



    function setName(bytes32 name_) public auth {

        name = name_;

    }

}



////// src/DPTICO.sol

/* pragma solidity ^0.4.23; */



/* import "ds-math/math.sol"; */

/* import "ds-auth/auth.sol"; */

/* import "ds-token/token.sol"; */

/* import "ds-stop/stop.sol"; */

/* import "ds-note/note.sol"; */



contract MedianizerLike {

    function peek() external view returns (bytes32, bool);

}



/**

 * @title DPT

 * @dev DPTICO contract.

 */

contract DPTICOEvents {

    event LogBuyToken(

        address owner,

        address sender,

        uint ethValue,

        uint dptValue,

        uint ethUsdRate,

        uint dptUsdRate

    );

    event LogFeedValid(bool feedValid);

}



contract DPTICO is DSAuth, DSStop, DSMath, DPTICOEvents {

    uint public dptUsdRate;              //usd price of 1 DPT token. 18 digit precision

    uint public ethUsdRate;              //price of ETH in USD. 18 digit precision

    MedianizerLike public priceFeed;     //address of the Makerdao price feed

    bool public feedValid;               //if true feed has valid USD/ETH rate

    ERC20 public dpt;                    //DPT token contract

    bool public manualUsdRate = true;    //if true enables token buy even if priceFeed does not provide valid data

    uint public minDptInvestmentAmount = 0; //minimal amount of DPT to buy, if equal with 0 than validation is disabled



    /**

    * @dev Constructor

    */

    constructor(address dpt_, address priceFeed_, uint dptUsdRate_, uint ethUsdRate_) public {

        dpt = ERC20(dpt_);

        priceFeed = MedianizerLike(priceFeed_);

        dptUsdRate = dptUsdRate_;

        ethUsdRate = ethUsdRate_;

    }



    /**

    * @dev Fallback function is used to buy tokens.

    */

    function () external payable {

        buyTokens();

    }



    /**

    * @dev Low level token purchase function.

    */

    function buyTokens() public payable stoppable {

        uint tokens;

        bool feedValidSave = feedValid;

        bytes32 ethUsdRateB;



        require(msg.value != 0, "Invalid amount");



        // receive ETH/USD price from external feed

        (ethUsdRateB, feedValid) = priceFeed.peek();



        // emit LogFeedValid event if validity of feed changes

        if (feedValidSave != feedValid) {

            emit LogFeedValid(feedValid);

        }



        // if feed is valid, load ETH/USD rate from it

        if (feedValid) {

            ethUsdRate = uint(ethUsdRateB);

        } else {

            // if feed invalid revert if manualUSDRate_ is NOT allowed

            require(manualUsdRate, "Manual rate not allowed");

        }



        tokens = wdiv(wmul(ethUsdRate, msg.value), dptUsdRate);



        // Validate invest amount, skip if minDptInvestmentAmount setted to 0

        require(tokens >= minDptInvestmentAmount, "Token amount must be greater or equal than minimal investment amount");



        address(owner).transfer(msg.value);

        dpt.transferFrom(owner, msg.sender, tokens);

        emit LogBuyToken(owner, msg.sender, msg.value, tokens, ethUsdRate, dptUsdRate);

    }



    /**

    * @dev Get tokenAmount price in ETH

    */

    function getPrice(uint tokenAmount) public view returns (uint) {

        bool feedValid_;

        uint ethUsdRate_;

        bytes32 ethUsdRateB;

        require(tokenAmount > 0, "Invalid amount");



        // receive ETH/USD price from external feed

        (ethUsdRateB, feedValid_) = priceFeed.peek();



        if (feedValid_) {

            ethUsdRate_ = uint(ethUsdRateB);

        } else {

            // load manual ETH/USD rate if enabled

            require(manualUsdRate, "Manual rate not allowed");

            ethUsdRate_ = ethUsdRate;

        }



        return wdiv(wmul(tokenAmount, dptUsdRate), ethUsdRate_);

    }



    /**

    * @dev Set exchange rate DPT/USD value.

    */

    function setDptRate(uint dptUsdRate_) public auth note {

        require(dptUsdRate_ > 0, "Invalid amount");

        dptUsdRate = dptUsdRate_;

    }



    /**

    * @dev Set exchange rate DPT/ETH value manually.

    *

    * This function should only be used if the priceFeed does not return

    * valid price data.

    *

    */

    function setEthRate(uint ethUsdRate_) public auth note {

        require(manualUsdRate, "Manual rate not allowed");

        ethUsdRate = ethUsdRate_;

    }



    /**

    * @dev Set the price feed

    */

    function setPriceFeed(address priceFeed_) public auth note {

        require(priceFeed_ != 0x0, "Wrong PriceFeed address");

        priceFeed = MedianizerLike(priceFeed_);

    }



    /**

    * @dev Set manual feed update

    *

    * If `manualUsdRate` is true, then `buyTokens()` will calculate the DPT amount based on latest valid `ethUsdRate`,

    * so `ethUsdRate` must be updated by admins if priceFeed fails to provide valid price data.

    *

    * If manualUsdRate is false, then buyTokens() will simply revert if priceFeed does not provide valid price data.

    */

    function setManualUsdRate(bool manualUsdRate_) public auth note {

        manualUsdRate = manualUsdRate_;

    }



    /**

    * @dev Set mininimal amount to buy

    *

    */

    function setMinDptInvestmentAmount(uint minDptInvestmentAmount_) public auth note {

        minDptInvestmentAmount = minDptInvestmentAmount_;

    }

}