/**

 *Submitted for verification at Etherscan.io on 2019-03-20

*/



pragma solidity ^0.4.24;



/**

 * @title Utility contract to allow pausing and unpausing of certain functions

 */

contract Pausable {



    event Pause(uint256 _timestammp);

    event Unpause(uint256 _timestamp);



    bool public paused = false;



    /**

    * @notice Modifier to make a function callable only when the contract is not paused.

    */

    modifier whenNotPaused() {

        require(!paused, "Contract is paused");

        _;

    }



    /**

    * @notice Modifier to make a function callable only when the contract is paused.

    */

    modifier whenPaused() {

        require(paused, "Contract is not paused");

        _;

    }



   /**

    * @notice Called by the owner to pause, triggers stopped state

    */

    function _pause() internal whenNotPaused {

        paused = true;

        /*solium-disable-next-line security/no-block-members*/

        emit Pause(now);

    }



    /**

    * @notice Called by the owner to unpause, returns to normal state

    */

    function _unpause() internal whenPaused {

        paused = false;

        /*solium-disable-next-line security/no-block-members*/

        emit Unpause(now);

    }



}



/**

 * @title Interface that every module contract should implement

 */

interface IModule {



    /**

     * @notice This function returns the signature of configure function

     */

    function getInitFunction() external pure returns (bytes4);



    /**

     * @notice Return the permission flags that are associated with a module

     */

    function getPermissions() external view returns(bytes32[]);



    /**

     * @notice Used to withdraw the fee by the factory owner

     */

    function takeFee(uint256 _amount) external returns(bool);



}



/**

 * @title Interface for all security tokens

 */

interface ISecurityToken {



    // Standard ERC20 interface

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address _owner) external view returns (uint256);

    function allowance(address _owner, address _spender) external view returns (uint256);

    function transfer(address _to, uint256 _value) external returns (bool);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);

    function approve(address _spender, uint256 _value) external returns (bool);

    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);

    function increaseApproval(address _spender, uint _addedValue) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);



    //transfer, transferFrom must respect the result of verifyTransfer

    function verifyTransfer(address _from, address _to, uint256 _value) external returns (bool success);



    /**

     * @notice Mints new tokens and assigns them to the target _investor.

     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)

     * @param _investor Address the tokens will be minted to

     * @param _value is the amount of tokens that will be minted to the investor

     */

    function mint(address _investor, uint256 _value) external returns (bool success);



    /**

     * @notice Mints new tokens and assigns them to the target _investor.

     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)

     * @param _investor Address the tokens will be minted to

     * @param _value is The amount of tokens that will be minted to the investor

     * @param _data Data to indicate validation

     */

    function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);



    /**

     * @notice Used to burn the securityToken on behalf of someone else

     * @param _from Address for whom to burn tokens

     * @param _value No. of tokens to be burned

     * @param _data Data to indicate validation

     */

    function burnFromWithData(address _from, uint256 _value, bytes _data) external;



    /**

     * @notice Used to burn the securityToken

     * @param _value No. of tokens to be burned

     * @param _data Data to indicate validation

     */

    function burnWithData(uint256 _value, bytes _data) external;



    event Minted(address indexed _to, uint256 _value);

    event Burnt(address indexed _burner, uint256 _value);



    // Permissions this to a Permission module, which has a key of 1

    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway

    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)

    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns (bool);



    /**

     * @notice Returns module list for a module type

     * @param _module Address of the module

     * @return bytes32 Name

     * @return address Module address

     * @return address Module factory address

     * @return bool Module archived

     * @return uint8 Module type

     * @return uint256 Module index

     * @return uint256 Name index



     */

    function getModule(address _module) external view returns(bytes32, address, address, bool, uint8, uint256, uint256);



    /**

     * @notice Returns module list for a module name

     * @param _name Name of the module

     * @return address[] List of modules with this name

     */

    function getModulesByName(bytes32 _name) external view returns (address[]);



    /**

     * @notice Returns module list for a module type

     * @param _type Type of the module

     * @return address[] List of modules with this type

     */

    function getModulesByType(uint8 _type) external view returns (address[]);



    /**

     * @notice Queries totalSupply at a specified checkpoint

     * @param _checkpointId Checkpoint ID to query as of

     */

    function totalSupplyAt(uint256 _checkpointId) external view returns (uint256);



    /**

     * @notice Queries balance at a specified checkpoint

     * @param _investor Investor to query balance for

     * @param _checkpointId Checkpoint ID to query as of

     */

    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns (uint256);



    /**

     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy

     */

    function createCheckpoint() external returns (uint256);



    /**

     * @notice Gets length of investors array

     * NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors

     * @return Length

     */

    function getInvestors() external view returns (address[]);



    /**

     * @notice returns an array of investors at a given checkpoint

     * NB - this length may differ from investorCount as it contains all investors that ever held tokens

     * @param _checkpointId Checkpoint id at which investor list is to be populated

     * @return list of investors

     */

    function getInvestorsAt(uint256 _checkpointId) external view returns(address[]);



    /**

     * @notice generates subset of investors

     * NB - can be used in batches if investor list is large

     * @param _start Position of investor to start iteration from

     * @param _end Position of investor to stop iteration at

     * @return list of investors

     */

    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[]);

    

    /**

     * @notice Gets current checkpoint ID

     * @return Id

     */

    function currentCheckpointId() external view returns (uint256);



    /**

    * @notice Gets an investor at a particular index

    * @param _index Index to return address from

    * @return Investor address

    */

    function investors(uint256 _index) external view returns (address);



   /**

    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.

    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.

    * @param _tokenContract Address of the ERC20Basic compliance token

    * @param _value Amount of POLY to withdraw

    */

    function withdrawERC20(address _tokenContract, uint256 _value) external;



    /**

    * @notice Allows owner to approve more POLY to one of the modules

    * @param _module Module address

    * @param _budget New budget

    */

    function changeModuleBudget(address _module, uint256 _budget) external;



    /**

     * @notice Changes the tokenDetails

     * @param _newTokenDetails New token details

     */

    function updateTokenDetails(string _newTokenDetails) external;



    /**

    * @notice Allows the owner to change token granularity

    * @param _granularity Granularity level of the token

    */

    function changeGranularity(uint256 _granularity) external;



    /**

    * @notice Removes addresses with zero balances from the investors list

    * @param _start Index in investors list at which to start removing zero balances

    * @param _iters Max number of iterations of the for loop

    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint

    */

    function pruneInvestors(uint256 _start, uint256 _iters) external;



    /**

     * @notice Freezes all the transfers

     */

    function freezeTransfers() external;



    /**

     * @notice Un-freezes all the transfers

     */

    function unfreezeTransfers() external;



    /**

     * @notice Ends token minting period permanently

     */

    function freezeMinting() external;



    /**

     * @notice Mints new tokens and assigns them to the target investors.

     * Can only be called by the STO attached to the token or by the Issuer (Security Token contract owner)

     * @param _investors A list of addresses to whom the minted tokens will be delivered

     * @param _values A list of the amount of tokens to mint to corresponding addresses from _investor[] list

     * @return Success

     */

    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success);



    /**

     * @notice Function used to attach a module to the security token

     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it

     * @dev to control restrictions on transfers.

     * @dev You are allowed to add a new moduleType if:

     * @dev - there is no existing module of that type yet added

     * @dev - the last member of the module list is replacable

     * @param _moduleFactory is the address of the module factory to be added

     * @param _data is data packed into bytes used to further configure the module (See STO usage)

     * @param _maxCost max amount of POLY willing to pay to module. (WIP)

     */

    function addModule(

        address _moduleFactory,

        bytes _data,

        uint256 _maxCost,

        uint256 _budget

    ) external;



    /**

    * @notice Archives a module attached to the SecurityToken

    * @param _module address of module to archive

    */

    function archiveModule(address _module) external;



    /**

    * @notice Unarchives a module attached to the SecurityToken

    * @param _module address of module to unarchive

    */

    function unarchiveModule(address _module) external;



    /**

    * @notice Removes a module attached to the SecurityToken

    * @param _module address of module to archive

    */

    function removeModule(address _module) external;



    /**

     * @notice Used by the issuer to set the controller addresses

     * @param _controller address of the controller

     */

    function setController(address _controller) external;



    /**

     * @notice Used by a controller to execute a forced transfer

     * @param _from address from which to take tokens

     * @param _to address where to send tokens

     * @param _value amount of tokens to transfer

     * @param _data data to indicate validation

     * @param _log data attached to the transfer by controller to emit in event

     */

    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;



    /**

     * @notice Used by a controller to execute a foced burn

     * @param _from address from which to take tokens

     * @param _value amount of tokens to transfer

     * @param _data data to indicate validation

     * @param _log data attached to the transfer by controller to emit in event

     */

    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) external;



    /**

     * @notice Used by the issuer to permanently disable controller functionality

     * @dev enabled via feature switch "disableControllerAllowed"

     */

     function disableController() external;



     /**

     * @notice Used to get the version of the securityToken

     */

     function getVersion() external view returns(uint8[]);



     /**

     * @notice Gets the investor count

     */

     function getInvestorCount() external view returns(uint256);



     /**

      * @notice Overloaded version of the transfer function

      * @param _to receiver of transfer

      * @param _value value of transfer

      * @param _data data to indicate validation

      * @return bool success

      */

     function transferWithData(address _to, uint256 _value, bytes _data) external returns (bool success);



     /**

      * @notice Overloaded version of the transferFrom function

      * @param _from sender of transfer

      * @param _to receiver of transfer

      * @param _value value of transfer

      * @param _data data to indicate validation

      * @return bool success

      */

     function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external returns(bool);



     /**

      * @notice Provides the granularity of the token

      * @return uint256

      */

     function granularity() external view returns(uint256);

}



/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

interface IERC20 {

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address _owner) external view returns (uint256);

    function allowance(address _owner, address _spender) external view returns (uint256);

    function transfer(address _to, uint256 _value) external returns (bool);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);

    function approve(address _spender, uint256 _value) external returns (bool);

    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);

    function increaseApproval(address _spender, uint _addedValue) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



/**

 * @title Storage for Module contract

 * @notice Contract is abstract

 */

contract ModuleStorage {



    /**

     * @notice Constructor

     * @param _securityToken Address of the security token

     * @param _polyAddress Address of the polytoken

     */

    constructor (address _securityToken, address _polyAddress) public {

        securityToken = _securityToken;

        factory = msg.sender;

        polyToken = IERC20(_polyAddress);

    }

    

    address public factory;



    address public securityToken;



    bytes32 public constant FEE_ADMIN = "FEE_ADMIN";



    IERC20 public polyToken;



}



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

  address public owner;





  event OwnershipRenounced(address indexed previousOwner);

  event OwnershipTransferred(

    address indexed previousOwner,

    address indexed newOwner

  );





  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  constructor() public {

    owner = msg.sender;

  }



  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  /**

   * @dev Allows the current owner to relinquish control of the contract.

   */

  function renounceOwnership() public onlyOwner {

    emit OwnershipRenounced(owner);

    owner = address(0);

  }



  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function transferOwnership(address _newOwner) public onlyOwner {

    _transferOwnership(_newOwner);

  }



  /**

   * @dev Transfers control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function _transferOwnership(address _newOwner) internal {

    require(_newOwner != address(0));

    emit OwnershipTransferred(owner, _newOwner);

    owner = _newOwner;

  }

}



/**

 * @title Interface that any module contract should implement

 * @notice Contract is abstract

 */

contract Module is IModule, ModuleStorage {



    /**

     * @notice Constructor

     * @param _securityToken Address of the security token

     * @param _polyAddress Address of the polytoken

     */

    constructor (address _securityToken, address _polyAddress) public

    ModuleStorage(_securityToken, _polyAddress)

    {

    }



    //Allows owner, factory or permissioned delegate

    modifier withPerm(bytes32 _perm) {

        bool isOwner = msg.sender == Ownable(securityToken).owner();

        bool isFactory = msg.sender == factory;

        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), "Permission check failed");

        _;

    }



    modifier onlyOwner {

        require(msg.sender == Ownable(securityToken).owner(), "Sender is not owner");

        _;

    }



    modifier onlyFactory {

        require(msg.sender == factory, "Sender is not factory");

        _;

    }



    modifier onlyFactoryOwner {

        require(msg.sender == Ownable(factory).owner(), "Sender is not factory owner");

        _;

    }



    modifier onlyFactoryOrOwner {

        require((msg.sender == Ownable(securityToken).owner()) || (msg.sender == factory), "Sender is not factory or owner");

        _;

    }



    /**

     * @notice used to withdraw the fee by the factory owner

     */

    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {

        require(polyToken.transferFrom(securityToken, Ownable(factory).owner(), _amount), "Unable to take fee");

        return true;

    }



}



/**

 * @title Interface to be implemented by all STO modules

 */

interface ISTO {

    /**

     * @notice Returns the total no. of tokens sold

     */

    function getTokensSold() external view returns (uint256);

}



/**

 * @title Storage layout for the STO contract

 */

contract STOStorage {



    mapping (uint8 => bool) public fundRaiseTypes;

    mapping (uint8 => uint256) public fundsRaised;



    // Start time of the STO

    uint256 public startTime;

    // End time of the STO

    uint256 public endTime;

    // Time STO was paused

    uint256 public pausedTime;

    // Number of individual investors

    uint256 public investorCount;

    // Address where ETH & POLY funds are delivered

    address public wallet;

     // Final amount of tokens sold

    uint256 public totalTokensSold;



}



/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {



  /**

  * @dev Multiplies two numbers, throws on overflow.

  */

  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {

    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the

    // benefit is lost if 'b' is also tested.

    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

    if (a == 0) {

      return 0;

    }



    c = a * b;

    assert(c / a == b);

    return c;

  }



  /**

  * @dev Integer division of two numbers, truncating the quotient.

  */

  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    // assert(b > 0); // Solidity automatically throws when dividing by 0

    // uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return a / b;

  }



  /**

  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).

  */

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  /**

  * @dev Adds two numbers, throws on overflow.

  */

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {

    c = a + b;

    assert(c >= a);

    return c;

  }

}



/**

 * @title Interface to be implemented by all STO modules

 */

contract STO is ISTO, STOStorage, Module, Pausable  {

    using SafeMath for uint256;



    enum FundRaiseType { ETH, POLY, SC }



    // Event

    event SetFundRaiseTypes(FundRaiseType[] _fundRaiseTypes);



    /**

     * @notice Returns funds raised by the STO

     */

    function getRaised(FundRaiseType _fundRaiseType) public view returns (uint256) {

        return fundsRaised[uint8(_fundRaiseType)];

    }



    /**

     * @notice Pause (overridden function)

     */

    function pause() public onlyOwner {

        /*solium-disable-next-line security/no-block-members*/

        require(now < endTime, "STO has been finalized");

        super._pause();

    }



    /**

     * @notice Unpause (overridden function)

     */

    function unpause() public onlyOwner {

        super._unpause();

    }



    function _setFundRaiseType(FundRaiseType[] _fundRaiseTypes) internal {

        // FundRaiseType[] parameter type ensures only valid values for _fundRaiseTypes

        require(_fundRaiseTypes.length > 0 && _fundRaiseTypes.length <= 3, "Raise type is not specified");

        fundRaiseTypes[uint8(FundRaiseType.ETH)] = false;

        fundRaiseTypes[uint8(FundRaiseType.POLY)] = false;

        fundRaiseTypes[uint8(FundRaiseType.SC)] = false;

        for (uint8 j = 0; j < _fundRaiseTypes.length; j++) {

            fundRaiseTypes[uint8(_fundRaiseTypes[j])] = true;

        }

        emit SetFundRaiseTypes(_fundRaiseTypes);

    }



    /**

    * @notice Reclaims ERC20Basic compatible tokens

    * @dev We duplicate here due to the overriden owner & onlyOwner

    * @param _tokenContract The address of the token contract

    */

    function reclaimERC20(address _tokenContract) external onlyOwner {

        require(_tokenContract != address(0), "Invalid address");

        IERC20 token = IERC20(_tokenContract);

        uint256 balance = token.balanceOf(address(this));

        require(token.transfer(msg.sender, balance), "Transfer failed");

    }



    /**

    * @notice Reclaims ETH

    * @dev We duplicate here due to the overriden owner & onlyOwner

    */

    function reclaimETH() external onlyOwner {

        msg.sender.transfer(address(this).balance);

    }



}



/**

 * @title Helps contracts guard agains reentrancy attacks.

 * @author Remco Bloemen <[email protected]π.com>

 * @notice If you mark a function `nonReentrant`, you should also

 * mark it `external`.

 */

contract ReentrancyGuard {



  /**

   * @dev We use a single lock for the whole contract.

   */

  bool private reentrancyLock = false;



  /**

   * @dev Prevents a contract from calling itself, directly or indirectly.

   * @notice If you mark a function `nonReentrant`, you should also

   * mark it `external`. Calling one nonReentrant function from

   * another is not supported. Instead, you can implement a

   * `private` function doing the actual work, and a `external`

   * wrapper marked as `nonReentrant`.

   */

  modifier nonReentrant() {

    require(!reentrancyLock);

    reentrancyLock = true;

    _;

    reentrancyLock = false;

  }



}



/**

 * @title STO module for standard capped crowdsale

 */

contract CappedSTO is STO, ReentrancyGuard {

    using SafeMath for uint256;



    // Determine whether users can invest on behalf of a beneficiary

    bool public allowBeneficialInvestments = false;

    // How many token units a buyer gets (multiplied by 10^18) per wei / base unit of POLY

    // If rate is 10^18, buyer will get 1 token unit for every wei / base unit of poly.

    uint256 public rate;

    //How many token base units this STO will be allowed to sell to investors

    // 1 full token = 10^decimals_of_token base units

    uint256 public cap;



    mapping (address => uint256) public investors;



    /**

    * Event for token purchase logging

    * @param purchaser who paid for the tokens

    * @param beneficiary who got the tokens

    * @param value weis paid for purchase

    * @param amount amount of tokens purchased

    */

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);



    event SetAllowBeneficialInvestments(bool _allowed);



    constructor (address _securityToken, address _polyAddress) public

    Module(_securityToken, _polyAddress)

    {

    }



    //////////////////////////////////

    /**

    * @notice fallback function ***DO NOT OVERRIDE***

    */

    function () external payable {

        buyTokens(msg.sender);

    }



    /**

     * @notice Function used to intialize the contract variables

     * @param _startTime Unix timestamp at which offering get started

     * @param _endTime Unix timestamp at which offering get ended

     * @param _cap Maximum No. of token base units for sale

     * @param _rate Token units a buyer gets multiplied by 10^18 per wei / base unit of POLY

     * @param _fundRaiseTypes Type of currency used to collect the funds

     * @param _fundsReceiver Ethereum account address to hold the funds

     */

    function configure(

        uint256 _startTime,

        uint256 _endTime,

        uint256 _cap,

        uint256 _rate,

        FundRaiseType[] _fundRaiseTypes,

        address _fundsReceiver

    )

    public

    onlyFactory

    {

        require(endTime == 0, "Already configured");

        require(_rate > 0, "Rate of token should be greater than 0");

        require(_fundsReceiver != address(0), "Zero address is not permitted");

        /*solium-disable-next-line security/no-block-members*/

        require(_startTime >= now && _endTime > _startTime, "Date parameters are not valid");

        require(_cap > 0, "Cap should be greater than 0");

        require(_fundRaiseTypes.length == 1, "It only selects single fund raise type");

        startTime = _startTime;

        endTime = _endTime;

        cap = _cap;

        rate = _rate;

        wallet = _fundsReceiver;

        _setFundRaiseType(_fundRaiseTypes);

    }



    /**

     * @notice This function returns the signature of configure function

     */

    function getInitFunction() public pure returns (bytes4) {

        return bytes4(keccak256("configure(uint256,uint256,uint256,uint256,uint8[],address)"));

    }



    /**

     * @notice Function to set allowBeneficialInvestments (allow beneficiary to be different to funder)

     * @param _allowBeneficialInvestments Boolean to allow or disallow beneficial investments

     */

    function changeAllowBeneficialInvestments(bool _allowBeneficialInvestments) public onlyOwner {

        require(_allowBeneficialInvestments != allowBeneficialInvestments, "Does not change value");

        allowBeneficialInvestments = _allowBeneficialInvestments;

        emit SetAllowBeneficialInvestments(allowBeneficialInvestments);

    }



    /**

      * @notice Low level token purchase ***DO NOT OVERRIDE***

      * @param _beneficiary Address performing the token purchase

      */

    function buyTokens(address _beneficiary) public payable nonReentrant {

        if (!allowBeneficialInvestments) {

            require(_beneficiary == msg.sender, "Beneficiary address does not match msg.sender");

        }



        require(!paused, "Should not be paused");

        require(fundRaiseTypes[uint8(FundRaiseType.ETH)], "Mode of investment is not ETH");



        uint256 weiAmount = msg.value;

        uint256 refund = _processTx(_beneficiary, weiAmount);

        weiAmount = weiAmount.sub(refund);



        _forwardFunds(refund);

    }



    /**

      * @notice low level token purchase

      * @param _investedPOLY Amount of POLY invested

      */

    function buyTokensWithPoly(uint256 _investedPOLY) public nonReentrant{

        require(!paused, "Should not be paused");

        require(fundRaiseTypes[uint8(FundRaiseType.POLY)], "Mode of investment is not POLY");

        uint256 refund = _processTx(msg.sender, _investedPOLY);

        _forwardPoly(msg.sender, wallet, _investedPOLY.sub(refund));

    }



    /**

    * @notice Checks whether the cap has been reached.

    * @return bool Whether the cap was reached

    */

    function capReached() public view returns (bool) {

        return totalTokensSold >= cap;

    }



    /**

     * @notice Return the total no. of tokens sold

     */

    function getTokensSold() public view returns (uint256) {

        return totalTokensSold;

    }



    /**

     * @notice Return the permissions flag that are associated with STO

     */

    function getPermissions() public view returns(bytes32[]) {

        bytes32[] memory allPermissions = new bytes32[](0);

        return allPermissions;

    }



    /**

     * @notice Return the STO details

     * @return Unixtimestamp at which offering gets start.

     * @return Unixtimestamp at which offering ends.

     * @return Number of token base units this STO will be allowed to sell to investors.

     * @return Token units a buyer gets(multiplied by 10^18) per wei / base unit of POLY

     * @return Amount of funds raised

     * @return Number of individual investors this STO have.

     * @return Amount of tokens get sold.

     * @return Boolean value to justify whether the fund raise type is POLY or not, i.e true for POLY.

     */

    function getSTODetails() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool) {

        return (

            startTime,

            endTime,

            cap,

            rate,

            (fundRaiseTypes[uint8(FundRaiseType.POLY)]) ? fundsRaised[uint8(FundRaiseType.POLY)]: fundsRaised[uint8(FundRaiseType.ETH)],

            investorCount,

            totalTokensSold,

            (fundRaiseTypes[uint8(FundRaiseType.POLY)])

        );

    }



    // -----------------------------------------

    // Internal interface (extensible)

    // -----------------------------------------

    /**

      * Processing the purchase as well as verify the required validations

      * @param _beneficiary Address performing the token purchase

      * @param _investedAmount Value in wei involved in the purchase

    */

    function _processTx(address _beneficiary, uint256 _investedAmount) internal returns(uint256 refund) {



        _preValidatePurchase(_beneficiary, _investedAmount);

        // calculate token amount to be created

        uint256 tokens;

        (tokens, refund) = _getTokenAmount(_investedAmount);

        _investedAmount = _investedAmount.sub(refund);



        // update state

        if (fundRaiseTypes[uint8(FundRaiseType.POLY)]) {

            fundsRaised[uint8(FundRaiseType.POLY)] = fundsRaised[uint8(FundRaiseType.POLY)].add(_investedAmount);

        } else {

            fundsRaised[uint8(FundRaiseType.ETH)] = fundsRaised[uint8(FundRaiseType.ETH)].add(_investedAmount);

        }

        totalTokensSold = totalTokensSold.add(tokens);



        _processPurchase(_beneficiary, tokens);

        emit TokenPurchase(msg.sender, _beneficiary, _investedAmount, tokens);

    }



    /**

    * @notice Validation of an incoming purchase.

      Use require statements to revert state when conditions are not met. Use super to concatenate validations.

    * @param _beneficiary Address performing the token purchase

    * @param _investedAmount Value in wei involved in the purchase

    */

    function _preValidatePurchase(address _beneficiary, uint256 _investedAmount) internal view {

        require(_beneficiary != address(0), "Beneficiary address should not be 0x");

        require(_investedAmount != 0, "Amount invested should not be equal to 0");

        /*solium-disable-next-line security/no-block-members*/

        require(now >= startTime && now <= endTime, "Offering is closed/Not yet started");

    }



    /**

    * @notice Source of tokens.

      Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.

    * @param _beneficiary Address performing the token purchase

    * @param _tokenAmount Number of tokens to be emitted

    */

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {

        require(ISecurityToken(securityToken).mint(_beneficiary, _tokenAmount), "Error in minting the tokens");

    }



    /**

    * @notice Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.

    * @param _beneficiary Address receiving the tokens

    * @param _tokenAmount Number of tokens to be purchased

    */

    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {

        if (investors[_beneficiary] == 0) {

            investorCount = investorCount + 1;

        }

        investors[_beneficiary] = investors[_beneficiary].add(_tokenAmount);



        _deliverTokens(_beneficiary, _tokenAmount);

    }



    /**

    * @notice Overrides to extend the way in which ether is converted to tokens.

    * @param _investedAmount Value in wei to be converted into tokens

    * @return Number of tokens that can be purchased with the specified _investedAmount

    * @return Remaining amount that should be refunded to the investor

    */

    function _getTokenAmount(uint256 _investedAmount) internal view returns (uint256 tokens, uint256 refund) {

        tokens = _investedAmount.mul(rate);

        tokens = tokens.div(uint256(10) ** 18);

        if (totalTokensSold.add(tokens) > cap) {

            tokens = cap.sub(totalTokensSold);

        }

        uint256 granularity = ISecurityToken(securityToken).granularity();

        tokens = tokens.div(granularity);

        tokens = tokens.mul(granularity);

        require(tokens > 0, "Cap reached");

        refund = _investedAmount.sub((tokens.mul(uint256(10) ** 18)).div(rate));

    }



    /**

    * @notice Determines how ETH is stored/forwarded on purchases.

    */

    function _forwardFunds(uint256 _refund) internal {

        wallet.transfer(msg.value.sub(_refund));

        msg.sender.transfer(_refund);

    }



    /**

     * @notice Internal function used to forward the POLY raised to beneficiary address

     * @param _beneficiary Address of the funds reciever

     * @param _to Address who wants to ST-20 tokens

     * @param _fundsAmount Amount invested by _to

     */

    function _forwardPoly(address _beneficiary, address _to, uint256 _fundsAmount) internal {

        polyToken.transferFrom(_beneficiary, _to, _fundsAmount);

    }



}



/**

 * @title Interface that every module factory contract should implement

 */

interface IModuleFactory {



    event ChangeFactorySetupFee(uint256 _oldSetupCost, uint256 _newSetupCost, address _moduleFactory);

    event ChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);

    event ChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);

    event GenerateModuleFromFactory(

        address _module,

        bytes32 indexed _moduleName,

        address indexed _moduleFactory,

        address _creator,

        uint256 _setupCost,

        uint256 _timestamp

    );

    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);



    //Should create an instance of the Module, or throw

    function deploy(bytes _data) external returns(address);



    /**

     * @notice Type of the Module factory

     */

    function getTypes() external view returns(uint8[]);



    /**

     * @notice Get the name of the Module

     */

    function getName() external view returns(bytes32);



    /**

     * @notice Returns the instructions associated with the module

     */

    function getInstructions() external view returns (string);



    /**

     * @notice Get the tags related to the module factory

     */

    function getTags() external view returns (bytes32[]);



    /**

     * @notice Used to change the setup fee

     * @param _newSetupCost New setup fee

     */

    function changeFactorySetupFee(uint256 _newSetupCost) external;



    /**

     * @notice Used to change the usage fee

     * @param _newUsageCost New usage fee

     */

    function changeFactoryUsageFee(uint256 _newUsageCost) external;



    /**

     * @notice Used to change the subscription fee

     * @param _newSubscriptionCost New subscription fee

     */

    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) external;



    /**

     * @notice Function use to change the lower and upper bound of the compatible version st

     * @param _boundType Type of bound

     * @param _newVersion New version array

     */

    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external;



   /**

     * @notice Get the setup cost of the module

     */

    function getSetupCost() external view returns (uint256);



    /**

     * @notice Used to get the lower bound

     * @return Lower bound

     */

    function getLowerSTVersionBounds() external view returns(uint8[]);



     /**

     * @notice Used to get the upper bound

     * @return Upper bound

     */

    function getUpperSTVersionBounds() external view returns(uint8[]);



}



/**

 * @title Helper library use to compare or validate the semantic versions

 */



library VersionUtils {



    /**

     * @notice This function is used to validate the version submitted

     * @param _current Array holds the present version of ST

     * @param _new Array holds the latest version of the ST

     * @return bool

     */

    function isValidVersion(uint8[] _current, uint8[] _new) internal pure returns(bool) {

        bool[] memory _temp = new bool[](_current.length);

        uint8 counter = 0;

        for (uint8 i = 0; i < _current.length; i++) {

            if (_current[i] < _new[i])

                _temp[i] = true;

            else

                _temp[i] = false;

        }



        for (i = 0; i < _current.length; i++) {

            if (i == 0) {

                if (_current[i] <= _new[i])

                    if(_temp[0]) {

                        counter = counter + 3;

                        break;

                    } else

                        counter++;

                else

                    return false;

            } else {

                if (_temp[i-1])

                    counter++;

                else if (_current[i] <= _new[i])

                    counter++;

                else

                    return false;

            }

        }

        if (counter == _current.length)

            return true;

    }



    /**

     * @notice Used to compare the lower bound with the latest version

     * @param _version1 Array holds the lower bound of the version

     * @param _version2 Array holds the latest version of the ST

     * @return bool

     */

    function compareLowerBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {

        require(_version1.length == _version2.length, "Input length mismatch");

        uint counter = 0;

        for (uint8 j = 0; j < _version1.length; j++) {

            if (_version1[j] == 0)

                counter ++;

        }

        if (counter != _version1.length) {

            counter = 0;

            for (uint8 i = 0; i < _version1.length; i++) {

                if (_version2[i] > _version1[i])

                    return true;

                else if (_version2[i] < _version1[i])

                    return false;

                else

                    counter++;

            }

            if (counter == _version1.length - 1)

                return true;

            else

                return false;

        } else

            return true;

    }



    /**

     * @notice Used to compare the upper bound with the latest version

     * @param _version1 Array holds the upper bound of the version

     * @param _version2 Array holds the latest version of the ST

     * @return bool

     */

    function compareUpperBound(uint8[] _version1, uint8[] _version2) internal pure returns(bool) {

        require(_version1.length == _version2.length, "Input length mismatch");

        uint counter = 0;

        for (uint8 j = 0; j < _version1.length; j++) {

            if (_version1[j] == 0)

                counter ++;

        }

        if (counter != _version1.length) {

            counter = 0;

            for (uint8 i = 0; i < _version1.length; i++) {

                if (_version1[i] > _version2[i])

                    return true;

                else if (_version1[i] < _version2[i])

                    return false;

                else

                    counter++;

            }

            if (counter == _version1.length - 1)

                return true;

            else

                return false;

        } else

            return true;

    }





    /**

     * @notice Used to pack the uint8[] array data into uint24 value

     * @param _major Major version

     * @param _minor Minor version

     * @param _patch Patch version

     */

    function pack(uint8 _major, uint8 _minor, uint8 _patch) internal pure returns(uint24) {

        return (uint24(_major) << 16) | (uint24(_minor) << 8) | uint24(_patch);

    }



    /**

     * @notice Used to convert packed data into uint8 array

     * @param _packedVersion Packed data

     */

    function unpack(uint24 _packedVersion) internal pure returns (uint8[]) {

        uint8[] memory _unpackVersion = new uint8[](3);

        _unpackVersion[0] = uint8(_packedVersion >> 16);

        _unpackVersion[1] = uint8(_packedVersion >> 8);

        _unpackVersion[2] = uint8(_packedVersion);

        return _unpackVersion;

    }





}



/**

 * @title Interface that any module factory contract should implement

 * @notice Contract is abstract

 */

contract ModuleFactory is IModuleFactory, Ownable {



    IERC20 public polyToken;

    uint256 public usageCost;

    uint256 public monthlySubscriptionCost;



    uint256 public setupCost;

    string public description;

    string public version;

    bytes32 public name;

    string public title;



    // @notice Allow only two variables to be stored

    // 1. lowerBound 

    // 2. upperBound

    // @dev (0.0.0 will act as the wildcard) 

    // @dev uint24 consists packed value of uint8 _major, uint8 _minor, uint8 _patch

    mapping(string => uint24) compatibleSTVersionRange;



    /**

     * @notice Constructor

     * @param _polyAddress Address of the polytoken

     */

    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public {

        polyToken = IERC20(_polyAddress);

        setupCost = _setupCost;

        usageCost = _usageCost;

        monthlySubscriptionCost = _subscriptionCost;

    }



    /**

     * @notice Used to change the fee of the setup cost

     * @param _newSetupCost new setup cost

     */

    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {

        emit ChangeFactorySetupFee(setupCost, _newSetupCost, address(this));

        setupCost = _newSetupCost;

    }



    /**

     * @notice Used to change the fee of the usage cost

     * @param _newUsageCost new usage cost

     */

    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {

        emit ChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));

        usageCost = _newUsageCost;

    }



    /**

     * @notice Used to change the fee of the subscription cost

     * @param _newSubscriptionCost new subscription cost

     */

    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {

        emit ChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));

        monthlySubscriptionCost = _newSubscriptionCost;



    }



    /**

     * @notice Updates the title of the ModuleFactory

     * @param _newTitle New Title that will replace the old one.

     */

    function changeTitle(string _newTitle) public onlyOwner {

        require(bytes(_newTitle).length > 0, "Invalid title");

        title = _newTitle;

    }



    /**

     * @notice Updates the description of the ModuleFactory

     * @param _newDesc New description that will replace the old one.

     */

    function changeDescription(string _newDesc) public onlyOwner {

        require(bytes(_newDesc).length > 0, "Invalid description");

        description = _newDesc;

    }



    /**

     * @notice Updates the name of the ModuleFactory

     * @param _newName New name that will replace the old one.

     */

    function changeName(bytes32 _newName) public onlyOwner {

        require(_newName != bytes32(0),"Invalid name");

        name = _newName;

    }



    /**

     * @notice Updates the version of the ModuleFactory

     * @param _newVersion New name that will replace the old one.

     */

    function changeVersion(string _newVersion) public onlyOwner {

        require(bytes(_newVersion).length > 0, "Invalid version");

        version = _newVersion;

    }



    /**

     * @notice Function use to change the lower and upper bound of the compatible version st

     * @param _boundType Type of bound

     * @param _newVersion new version array

     */

    function changeSTVersionBounds(string _boundType, uint8[] _newVersion) external onlyOwner {

        require(

            keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked("lowerBound")) ||

            keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked("upperBound")),

            "Must be a valid bound type"

        );

        require(_newVersion.length == 3);

        if (compatibleSTVersionRange[_boundType] != uint24(0)) { 

            uint8[] memory _currentVersion = VersionUtils.unpack(compatibleSTVersionRange[_boundType]);

            require(VersionUtils.isValidVersion(_currentVersion, _newVersion), "Failed because of in-valid version");

        }

        compatibleSTVersionRange[_boundType] = VersionUtils.pack(_newVersion[0], _newVersion[1], _newVersion[2]);

        emit ChangeSTVersionBound(_boundType, _newVersion[0], _newVersion[1], _newVersion[2]);

    }



    /**

     * @notice Used to get the lower bound

     * @return lower bound

     */

    function getLowerSTVersionBounds() external view returns(uint8[]) {

        return VersionUtils.unpack(compatibleSTVersionRange["lowerBound"]);

    }



    /**

     * @notice Used to get the upper bound

     * @return upper bound

     */

    function getUpperSTVersionBounds() external view returns(uint8[]) {

        return VersionUtils.unpack(compatibleSTVersionRange["upperBound"]);

    }



    /**

     * @notice Get the setup cost of the module

     */

    function getSetupCost() external view returns (uint256) {

        return setupCost;

    }



   /**

    * @notice Get the name of the Module

    */

    function getName() public view returns(bytes32) {

        return name;

    }



}



/**

 * @title Utility contract for reusable code

 */

library Util {



   /**

    * @notice Changes a string to upper case

    * @param _base String to change

    */

    function upper(string _base) internal pure returns (string) {

        bytes memory _baseBytes = bytes(_base);

        for (uint i = 0; i < _baseBytes.length; i++) {

            bytes1 b1 = _baseBytes[i];

            if (b1 >= 0x61 && b1 <= 0x7A) {

                b1 = bytes1(uint8(b1)-32);

            }

            _baseBytes[i] = b1;

        }

        return string(_baseBytes);

    }



    /**

     * @notice Changes the string into bytes32

     * @param _source String that need to convert into bytes32

     */

    /// Notice - Maximum Length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.

    function stringToBytes32(string memory _source) internal pure returns (bytes32) {

        return bytesToBytes32(bytes(_source), 0);

    }



    /**

     * @notice Changes bytes into bytes32

     * @param _b Bytes that need to convert into bytes32

     * @param _offset Offset from which to begin conversion

     */

    /// Notice - Maximum length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.

    function bytesToBytes32(bytes _b, uint _offset) internal pure returns (bytes32) {

        bytes32 result;



        for (uint i = 0; i < _b.length; i++) {

            result |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);

        }

        return result;

    }



    /**

     * @notice Changes the bytes32 into string

     * @param _source that need to convert into string

     */

    function bytes32ToString(bytes32 _source) internal pure returns (string result) {

        bytes memory bytesString = new bytes(32);

        uint charCount = 0;

        for (uint j = 0; j < 32; j++) {

            byte char = byte(bytes32(uint(_source) * 2 ** (8 * j)));

            if (char != 0) {

                bytesString[charCount] = char;

                charCount++;

            }

        }

        bytes memory bytesStringTrimmed = new bytes(charCount);

        for (j = 0; j < charCount; j++) {

            bytesStringTrimmed[j] = bytesString[j];

        }

        return string(bytesStringTrimmed);

    }



    /**

     * @notice Gets function signature from _data

     * @param _data Passed data

     * @return bytes4 sig

     */

    function getSig(bytes _data) internal pure returns (bytes4 sig) {

        uint len = _data.length < 4 ? _data.length : 4;

        for (uint i = 0; i < len; i++) {

            sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));

        }

    }





}



/**

 * @title Factory for deploying CappedSTO module

 */

contract CappedSTOFactory is ModuleFactory {



    /**

     * @notice Constructor

     * @param _polyAddress Address of the polytoken

     */

    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public

    ModuleFactory(_polyAddress, _setupCost, _usageCost, _subscriptionCost)

    {

        version = "2.1.0";

        name = "CappedSTO";

        title = "Capped STO";

        description = "This smart contract creates a maximum number of tokens (i.e. hard cap) which the total aggregate of tokens acquired by all investors cannot exceed. Security tokens are sent to the investor upon reception of the funds (ETH or POLY), and any security tokens left upon termination of the offering will not be minted.";

        compatibleSTVersionRange["lowerBound"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));

        compatibleSTVersionRange["upperBound"] = VersionUtils.pack(uint8(0), uint8(0), uint8(0));

    }



     /**

     * @notice Used to launch the Module with the help of factory

     * @return address Contract address of the Module

     */

    function deploy(bytes _data) external returns(address) {

        if(setupCost > 0)

            require(polyToken.transferFrom(msg.sender, owner, setupCost), "Sufficent Allowance is not provided");

        //Check valid bytes - can only call module init function

        CappedSTO cappedSTO = new CappedSTO(msg.sender, address(polyToken));

        //Checks that _data is valid (not calling anything it shouldn't)

        require(Util.getSig(_data) == cappedSTO.getInitFunction(), "Invalid data");

        /*solium-disable-next-line security/no-low-level-calls*/

        require(address(cappedSTO).call(_data), "Unsuccessfull call");

        /*solium-disable-next-line security/no-block-members*/

        emit GenerateModuleFromFactory(address(cappedSTO), getName(), address(this), msg.sender, setupCost, now);

        return address(cappedSTO);

    }



    /**

     * @notice Type of the Module factory

     */

    function getTypes() external view returns(uint8[]) {

        uint8[] memory res = new uint8[](1);

        res[0] = 3;

        return res;

    }



    /**

     * @notice Returns the instructions associated with the module

     */

    function getInstructions() external view returns(string) {

        /*solium-disable-next-line max-len*/

        return "Initialises a capped STO. Init parameters are _startTime (time STO starts), _endTime (time STO ends), _cap (cap in tokens for STO), _rate (POLY/ETH to token rate), _fundRaiseType (whether you are raising in POLY or ETH), _polyToken (address of POLY token), _fundsReceiver (address which will receive funds)";

    }



    /**

     * @notice Get the tags related to the module factory

     */

    function getTags() external view returns(bytes32[]) {

        bytes32[] memory availableTags = new bytes32[](4);

        availableTags[0] = "Capped";

        availableTags[1] = "Non-refundable";

        availableTags[2] = "POLY";

        availableTags[3] = "ETH";

        return availableTags;

    }



}