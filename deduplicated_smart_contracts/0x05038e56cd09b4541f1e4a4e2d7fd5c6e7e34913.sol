/**

 *Submitted for verification at Etherscan.io on 2019-01-10

*/



pragma solidity ^0.4.11;



/**

 * @title SafeMath

 * @dev Math operations with safety checks that throw on error

 */

library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a * b;

    assert(a == 0 || c / a == b);

    return c;

  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    // assert(b > 0); // Solidity automatically throws when dividing by 0

    uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;

  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a + b;

    assert(c >= a);

    return c;

  }

}



contract owned {

    address public owner;



    function owned() {

        owner = msg.sender;

    }



    modifier onlyOwner {

        if (msg.sender != owner) throw;

        _;

    }



    function transferOwnership(address newOwner) onlyOwner {

        owner = newOwner;

    }

}





contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }



contract token {

    /* Public variables of the token */

    string public standard = "BezantToken";

    string public name;

    string public symbol;

    uint8 public decimals;

    uint256 public totalSupply;



    /* This creates an array with all balances */

    mapping (address => uint256) public balanceOf;

    mapping (address => mapping (address => uint256)) public allowance;



    /* This generates a public event on the blockchain that will notify clients */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /* Initializes contract with initial supply tokens to the creator of the contract */

    function token(

        uint256 initialSupply,

        string tokenName,

        uint8 decimalUnits,

        string tokenSymbol

        ) {

        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens

        totalSupply = initialSupply;                        // Update total supply

        name = tokenName;                                   // Set the name for display purposes

        symbol = tokenSymbol;                               // Set the symbol for display purposes

        decimals = decimalUnits;                            // Amount of decimals for display purposes

    }



    /* Send coins */

    function transfer(address _to, uint256 _value) {

        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough

        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows

        balanceOf[msg.sender] -= _value;                     // Subtract from the sender

        balanceOf[_to] += _value;                            // Add the same to the recipient

        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place

    }



    /* Allow another contract to spend some tokens in your behalf */

    function approve(address _spender, uint256 _value)

        returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        return true;

    }



    /* Approve and then communicate the approved contract in a single tx */

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)

        returns (bool success) {

        tokenRecipient spender = tokenRecipient(_spender);

        if (approve(_spender, _value)) {

            spender.receiveApproval(msg.sender, _value, this, _extraData);

            return true;

        }

    }



    /* A contract attempts _ to get the coins */

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough

        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows

        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance

        balanceOf[_from] -= _value;                          // Subtract from the sender

        balanceOf[_to] += _value;                            // Add the same to the recipient

        allowance[_from][msg.sender] -= _value;

        Transfer(_from, _to, _value);

        return true;

    }



    /* This unnamed function is called whenever someone tries to send ether to it */

    function () {

        throw;     // Prevents accidental sending of ether

    }

}



contract BezantToken is owned, token {



    uint256 public sellPrice;

    uint256 public buyPrice;



    mapping(address=>bool) public frozenAccount;





    /* This generates a public event on the blockchain that will notify clients */

    event FrozenFunds(address target, bool frozen);



    /* Initializes contract with initial supply tokens to the creator of the contract */

    uint256 public constant initialSupply = 1000000000 * 10**18;

    uint8 public constant decimalUnits = 18;

    string public tokenName = "BezantToken ";

    string public tokenSymbol = "BZNT";

    function BezantToken() token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}

     /* Send coins */

    function transfer(address _to, uint256 _value) {

        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough

        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows

        if (frozenAccount[msg.sender]) throw;                // Check if frozen

        balanceOf[msg.sender] -= _value;                     // Subtract from the sender

        balanceOf[_to] += _value;                            // Add the same to the recipient

        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place

    }





    /* A contract attempts to get the coins */

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        if (frozenAccount[_from]) throw;                        // Check if frozen

        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough

        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows

        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance

        balanceOf[_from] -= _value;                          // Subtract from the sender

        balanceOf[_to] += _value;                            // Add the same to the recipient

        allowance[_from][msg.sender] -= _value;

        Transfer(_from, _to, _value);

        return true;

    }



    function mintToken(address target, uint256 mintedAmount) onlyOwner {

        balanceOf[target] += mintedAmount;

        totalSupply += mintedAmount;

        Transfer(0, this, mintedAmount);

        Transfer(this, target, mintedAmount);

    }



    function freezeAccount(address target, bool freeze) onlyOwner {

        frozenAccount[target] = freeze;

        FrozenFunds(target, freeze);

    }



    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {

        sellPrice = newSellPrice;

        buyPrice = newBuyPrice;

    }



    function buy() payable {

        uint amount = msg.value / buyPrice;                // calculates the amount

        if (balanceOf[this] < amount) throw;               // checks if it has enough to sell

        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance

        balanceOf[this] -= amount;                         // subtracts amount from seller's balance

        Transfer(this, msg.sender, amount);                // execute an event reflecting the change

    }



    function sell(uint256 amount) {

        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell

        balanceOf[this] += amount;                         // adds the amount to owner's balance

        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance

        if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important

            throw;                                         // to do this last to avoid recursion attacks

        } else {

            Transfer(msg.sender, this, amount);            // executes an event reflecting on the change

        }

    }

}



contract Ownable {

  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  constructor() public{

    owner = msg.sender;

  }

  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }

  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param newOwner The address to transfer ownership to.

   */

  function transferOwnership(address newOwner) onlyOwner public {

    require(newOwner != address(0));

    emit OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }

}



/**

 * @title Crowdsale

 * @dev Crowdsale is a base contract for managing a token crowdsale.

 * Crowdsales have a start and end timestamps, where investors can make

 * token purchases and the crowdsale will assign them tokens based

 * on a token per ETH rate. Funds collected are forwarded to a wallet

 * as they arrive.

 */

contract Crowdsale is Ownable {

  using SafeMath for uint256;



  // The token being sold

  token myToken;

  

  // address where funds are collected

  address public wallet;

  

  // rate => tokens per ether

  uint256 public rate = 450000 ; 



  // amount of raised money in wei

  uint256 public weiRaised;



  /**

   * event for token purchase logging

   * @param beneficiary who got the tokens

   * @param value weis paid for purchase

   * @param amount amount of tokens purchased

   */

  event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);





  constructor(address tokenContractAddress, address _walletAddress) public{

    wallet = _walletAddress;

    myToken = token(tokenContractAddress);

  }



  // fallback function can be used to buy tokens

  function () payable public{

    buyTokens(msg.sender);

  }



  function getBalance() public constant returns(uint256){

      return myToken.balanceOf(this);

  }    



  // low level token purchase function

  function buyTokens(address beneficiary) public payable {

    require(beneficiary != 0x0);

    require(msg.value >= 20000000000000000);// min contribution 0.02ETH

    require(msg.value <= 1000000000000000000);// max contribution 1ETH



    uint256 weiAmount = msg.value;



    // calculate token amount to be created

    uint256 tokens = weiAmount.mul(rate).div(100);



    // update state

    weiRaised = weiRaised.add(weiAmount);



    myToken.transfer(beneficiary, tokens);



    emit TokenPurchase(beneficiary, weiAmount, tokens);

  }



  // to change rate

  function updateRate(uint256 new_rate) onlyOwner public{

    rate = new_rate;

  }





  // send ether to the fund collection wallet

  // override to create custom fund forwarding mechanisms

  function forwardFunds() onlyOwner public {

    wallet.transfer(address(this).balance);

  }



  function transferBackTo(uint256 tokens, address beneficiary) onlyOwner public returns (bool){

    myToken.transfer(beneficiary, tokens);

    return true;

  }



}