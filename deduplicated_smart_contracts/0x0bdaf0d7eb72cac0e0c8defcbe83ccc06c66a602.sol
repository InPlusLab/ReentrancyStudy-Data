/**

 *Submitted for verification at Etherscan.io on 2018-09-18

*/



pragma solidity ^0.4.24;



contract Token {

    function transfer(address _to, uint _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    function approve(address _spender, uint256 _value) public returns (bool success);

    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);

    function balanceOf(address _owner) public view returns (uint256 balance);

}





contract Ownable {

    address public owner;



    modifier onlyOwner() {

        require(msg.sender == owner, "Sender is not the owner");

        _;

    }



    constructor() public {

        owner = msg.sender; 

    }



    /**

        @dev Transfers the ownership of the contract.



        @param _to Address of the new owner

    */

    function transferTo(address _to) public onlyOwner returns (bool) {

        require(_to != address(0), "Can't transfer to 0x0");

        owner = _to;

        return true;

    }

}





/**

    @dev Defines the interface of a standard RCN oracle.



    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,

    it's primarily used by the exchange but could be used by any other agent.

*/

contract Oracle is Ownable {

    uint256 public constant VERSION = 4;



    event NewSymbol(bytes32 _currency);



    mapping(bytes32 => bool) public supported;

    bytes32[] public currencies;



    /**

        @dev Returns the url where the oracle exposes a valid "oracleData" if needed

    */

    function url() public view returns (string);



    /**

        @dev Returns a valid convertion rate from the currency given to RCN



        @param symbol Symbol of the currency

        @param data Generic data field, could be used for off-chain signing

    */

    function getRate(bytes32 symbol, bytes data) public returns (uint256 rate, uint256 decimals);



    /**

        @dev Adds a currency to the oracle, once added it cannot be removed



        @param ticker Symbol of the currency



        @return if the creation was done successfully

    */

    function addCurrency(string ticker) public onlyOwner returns (bool) {

        bytes32 currency = encodeCurrency(ticker);

        NewSymbol(currency);

        supported[currency] = true;

        currencies.push(currency);

        return true;

    }



    /**

        @return the currency encoded as a bytes32

    */

    function encodeCurrency(string currency) public pure returns (bytes32 o) {

        require(bytes(currency).length <= 32);

        assembly {

            o := mload(add(currency, 32))

        }

    }

    

    /**

        @return the currency string from a encoded bytes32

    */

    function decodeCurrency(bytes32 b) public pure returns (string o) {

        uint256 ns = 256;

        while (true) { if (ns == 0 || (b<<ns-8) != 0) break; ns -= 8; }

        assembly {

            ns := div(ns, 8)

            o := mload(0x40)

            mstore(0x40, add(o, and(add(add(ns, 0x20), 0x1f), not(0x1f))))

            mstore(o, ns)

            mstore(add(o, 32), b)

        }

    }

    

}



contract Engine {

    uint256 public VERSION;

    string public VERSION_NAME;



    enum Status { initial, lent, paid, destroyed }

    struct Approbation {

        bool approved;

        bytes data;

        bytes32 checksum;

    }



    function getTotalLoans() public view returns (uint256);

    function getOracle(uint index) public view returns (Oracle);

    function getBorrower(uint index) public view returns (address);

    function getCosigner(uint index) public view returns (address);

    function ownerOf(uint256) public view returns (address owner);

    function getCreator(uint index) public view returns (address);

    function getAmount(uint index) public view returns (uint256);

    function getPaid(uint index) public view returns (uint256);

    function getDueTime(uint index) public view returns (uint256);

    function getApprobation(uint index, address _address) public view returns (bool);

    function getStatus(uint index) public view returns (Status);

    function isApproved(uint index) public view returns (bool);

    function getPendingAmount(uint index) public returns (uint256);

    function getCurrency(uint index) public view returns (bytes32);

    function cosign(uint index, uint256 cost) external returns (bool);

    function approveLoan(uint index) public returns (bool);

    function transfer(address to, uint256 index) public returns (bool);

    function takeOwnership(uint256 index) public returns (bool);

    function withdrawal(uint index, address to, uint256 amount) public returns (bool);

    function identifierToIndex(bytes32 signature) public view returns (uint256);

}





/**

    @dev Defines the interface of a standard RCN cosigner.



    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions

    of the insurance and the cost of the given are defined by the cosigner. 



    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the

    agent should be passed as params when the lender calls the "lend" method on the engine.

    

    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine

    should be able to call the "claim" method to receive the benefit; the cosigner can define aditional requirements to

    call this method, like the transfer of the ownership of the loan.

*/

contract Cosigner {

    uint256 public constant VERSION = 2;

    

    /**

        @return the url of the endpoint that exposes the insurance offers.

    */

    function url() external view returns (string);

    

    /**

        @dev Retrieves the cost of a given insurance, this amount should be exact.



        @return the cost of the cosign, in RCN wei

    */

    function cost(address engine, uint256 index, bytes data, bytes oracleData) external view returns (uint256);

    

    /**

        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of

        the insurance it must call the method "cosign" of the engine. If the cosigner does not call that method, or

        does not return true to this method, the operation fails.



        @return true if the cosigner accepts the liability

    */

    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);

    

    /**

        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the

        current lender of the loan.



        @return true if the claim was done correctly.

    */

    function claim(address engine, uint256 index, bytes oracleData) external returns (bool);

}



library SafeMath {

    function add(uint256 x, uint256 y) internal pure returns(uint256) {

        uint256 z = x + y;

        require((z >= x) && (z >= y));

        return z;

    }



    function sub(uint256 x, uint256 y) internal pure returns(uint256) {

        require(x >= y);

        uint256 z = x - y;

        return z;

    }



    function mult(uint256 x, uint256 y) internal pure returns(uint256) {

        uint256 z = x * y;

        require((x == 0)||(z/x == y));

        return z;

    }

}





contract SafeWithdraw is Ownable {

    /**

        @dev Withdraws tokens from the contract.



        @param token Token to withdraw

        @param to Destination of the tokens

        @param amountOrId Amount/ID to withdraw 

    */

    function withdrawTokens(Token token, address to, uint256 amountOrId) external onlyOwner returns (bool) {

        require(to != address(0));

        return token.transfer(to, amountOrId);

    }

}



contract BytesUtils {

    function readBytes32(bytes data, uint256 index) internal pure returns (bytes32 o) {

        require(data.length / 32 > index);

        assembly {

            o := mload(add(data, add(32, mul(32, index))))

        }

    }

}



contract TokenConverter {

    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;

    function getReturn(Token _fromToken, Token _toToken, uint256 _fromAmount) external view returns (uint256 amount);

    function convert(Token _fromToken, Token _toToken, uint256 _fromAmount, uint256 _minReturn) external payable returns (uint256 amount);

}







interface IERC721Receiver {

    function onERC721Received(

        address _oldOwner,

        uint256 _tokenId,

        bytes   _userData

    ) external returns (bytes4);

}



contract ERC721Base {

    using SafeMath for uint256;



    uint256 private _count;



    mapping(uint256 => address) private _holderOf;

    mapping(address => uint256[]) private _assetsOf;

    mapping(address => mapping(address => bool)) private _operators;

    mapping(uint256 => address) private _approval;

    mapping(uint256 => uint256) private _indexOfAsset;



    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);

    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);

    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);



    //

    // Global Getters

    //



    /**

     * @dev Gets the total amount of assets stored by the contract

     * @return uint256 representing the total amount of assets

     */

    function totalSupply() external view returns (uint256) {

        return _totalSupply();

    }

    function _totalSupply() internal view returns (uint256) {

        return _count;

    }



    //

    // Asset-centric getter functions

    //



    /**

     * @dev Queries what address owns an asset. This method does not throw.

     * In order to check if the asset exists, use the `exists` function or check if the

     * return value of this call is `0`.

     * @return uint256 the assetId

     */

    function ownerOf(uint256 assetId) external view returns (address) {

        return _ownerOf(assetId);

    }

    function _ownerOf(uint256 assetId) internal view returns (address) {

        return _holderOf[assetId];

    }



    //

    // Holder-centric getter functions

    //

    /**

     * @dev Gets the balance of the specified address

     * @param owner address to query the balance of

     * @return uint256 representing the amount owned by the passed address

     */

    function balanceOf(address owner) external view returns (uint256) {

        return _balanceOf(owner);

    }

    function _balanceOf(address owner) internal view returns (uint256) {

        return _assetsOf[owner].length;

    }



    //

    // Authorization getters

    //



    /**

     * @dev Query whether an address has been authorized to move any assets on behalf of someone else

     * @param operator the address that might be authorized

     * @param assetHolder the address that provided the authorization

     * @return bool true if the operator has been authorized to move any assets

     */

    function isApprovedForAll(address operator, address assetHolder)

        external view returns (bool)

    {

        return _isApprovedForAll(operator, assetHolder);

    }

    function _isApprovedForAll(address operator, address assetHolder)

        internal view returns (bool)

    {

        return _operators[assetHolder][operator];

    }



    /**

     * @dev Query what address has been particularly authorized to move an asset

     * @param assetId the asset to be queried for

     * @return bool true if the asset has been approved by the holder

     */

    function getApprovedAddress(uint256 assetId) external view returns (address) {

        return _getApprovedAddress(assetId);

    }

    function _getApprovedAddress(uint256 assetId) internal view returns (address) {

        return _approval[assetId];

    }



    /**

     * @dev Query if an operator can move an asset.

     * @param operator the address that might be authorized

     * @param assetId the asset that has been `approved` for transfer

     * @return bool true if the asset has been approved by the holder

     */

    function isAuthorized(address operator, uint256 assetId) external view returns (bool) {

        return _isAuthorized(operator, assetId);

    }

    function _isAuthorized(address operator, uint256 assetId) internal view returns (bool)

    {

        require(operator != 0, "Operator can't be 0");

        address owner = _ownerOf(assetId);

        if (operator == owner) {

            return true;

        }

        return _isApprovedForAll(operator, owner) || _getApprovedAddress(assetId) == operator;

    }



    //

    // Authorization

    //



    /**

     * @dev Authorize a third party operator to manage (send) msg.sender's asset

     * @param operator address to be approved

     * @param authorized bool set to true to authorize, false to withdraw authorization

     */

    function setApprovalForAll(address operator, bool authorized) external {

        return _setApprovalForAll(operator, authorized);

    }

    function _setApprovalForAll(address operator, bool authorized) internal {

        if (authorized) {

            _addAuthorization(operator, msg.sender);

        } else {

            _clearAuthorization(operator, msg.sender);

        }

        emit ApprovalForAll(operator, msg.sender, authorized);

    }



    /**

     * @dev Authorize a third party operator to manage one particular asset

     * @param operator address to be approved

     * @param assetId asset to approve

     */

    function approve(address operator, uint256 assetId) external {

        address holder = _ownerOf(assetId);

        require(msg.sender == holder || _isApprovedForAll(msg.sender, holder));

        require(operator != holder);

        if (_getApprovedAddress(assetId) != operator) {

            _approval[assetId] = operator;

            emit Approval(holder, operator, assetId);

        }

    }



    function _addAuthorization(address operator, address holder) private {

        _operators[holder][operator] = true;

    }



    function _clearAuthorization(address operator, address holder) private {

        _operators[holder][operator] = false;

    }



    //

    // Internal Operations

    //



    function _addAssetTo(address to, uint256 assetId) internal {

        _holderOf[assetId] = to;



        uint256 length = _balanceOf(to);



        _assetsOf[to].push(assetId);



        _indexOfAsset[assetId] = length;



        _count = _count.add(1);

    }



    function _removeAssetFrom(address from, uint256 assetId) internal {

        uint256 assetIndex = _indexOfAsset[assetId];

        uint256 lastAssetIndex = _balanceOf(from).sub(1);

        uint256 lastAssetId = _assetsOf[from][lastAssetIndex];



        _holderOf[assetId] = 0;



        // Insert the last asset into the position previously occupied by the asset to be removed

        _assetsOf[from][assetIndex] = lastAssetId;



        // Resize the array

        _assetsOf[from][lastAssetIndex] = 0;

        _assetsOf[from].length--;



        // Remove the array if no more assets are owned to prevent pollution

        if (_assetsOf[from].length == 0) {

            delete _assetsOf[from];

        }



        // Update the index of positions for the asset

        _indexOfAsset[assetId] = 0;

        _indexOfAsset[lastAssetId] = assetIndex;



        _count = _count.sub(1);

    }



    function _clearApproval(address holder, uint256 assetId) internal {

        if (_ownerOf(assetId) == holder && _approval[assetId] != 0) {

            _approval[assetId] = 0;

            emit Approval(holder, 0, assetId);

        }

    }



    //

    // Supply-altering functions

    //



    function _generate(uint256 assetId, address beneficiary) internal {

        require(_holderOf[assetId] == 0);



        _addAssetTo(beneficiary, assetId);



        emit Transfer(0x0, beneficiary, assetId);

    }



    function _destroy(uint256 assetId) internal {

        address holder = _holderOf[assetId];

        require(holder != 0);



        _removeAssetFrom(holder, assetId);



        emit Transfer(holder, 0x0, assetId);

    }



    //

    // Transaction related operations

    //



    modifier onlyHolder(uint256 assetId) {

        require(_ownerOf(assetId) == msg.sender, "Not holder");

        _;

    }



    modifier onlyAuthorized(uint256 assetId) {

        require(_isAuthorized(msg.sender, assetId), "Not authorized");

        _;

    }



    modifier isCurrentOwner(address from, uint256 assetId) {

        require(_ownerOf(assetId) == from, "Not current owner");

        _;

    }



    /**

     * @dev Alias of `safeTransferFrom(from, to, assetId, '')`

     *

     * @param from address that currently owns an asset

     * @param to address to receive the ownership of the asset

     * @param assetId uint256 ID of the asset to be transferred

     */

    function safeTransferFrom(address from, address to, uint256 assetId) external {

        return _doTransferFrom(from, to, assetId, "", true);

    }



    /**

     * @dev Securely transfers the ownership of a given asset from one address to

     * another address, calling the method `onNFTReceived` on the target address if

     * there's code associated with it

     *

     * @param from address that currently owns an asset

     * @param to address to receive the ownership of the asset

     * @param assetId uint256 ID of the asset to be transferred

     * @param userData bytes arbitrary user information to attach to this transfer

     */

    function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) external {

        return _doTransferFrom(from, to, assetId, userData, true);

    }



    /**

     * @dev Transfers the ownership of a given asset from one address to another address

     * Warning! This function does not attempt to verify that the target address can send

     * tokens.

     *

     * @param from address sending the asset

     * @param to address to receive the ownership of the asset

     * @param assetId uint256 ID of the asset to be transferred

     */

    function transferFrom(address from, address to, uint256 assetId) external {

        return _doTransferFrom(from, to, assetId, "", false);

    }



    function _doTransferFrom(

        address from,

        address to,

        uint256 assetId,

        bytes userData,

        bool doCheck

    )

        onlyAuthorized(assetId)

        internal

    {

        _moveToken(from, to, assetId, userData, doCheck);

    }



    function _moveToken(

        address from,

        address to,

        uint256 assetId,

        bytes userData,

        bool doCheck

    )

        isCurrentOwner(from, assetId)

        internal

    {

        address holder = _holderOf[assetId];

        _removeAssetFrom(holder, assetId);

        _clearApproval(holder, assetId);

        _addAssetTo(to, assetId);



        if (doCheck && _isContract(to)) {

            // Equals to bytes4(keccak256("onERC721Received(address,uint256,bytes)"))

            bytes4 ERC721_RECEIVED = bytes4(0xf0b9e5ba);

            require(

                IERC721Receiver(to).onERC721Received(

                    holder, assetId, userData

                ) == ERC721_RECEIVED

            , "Contract onERC721Received failed");

        }



        emit Transfer(holder, to, assetId);

    }



    /**

     * Internal function that moves an asset from one holder to another

     */



    /**

     * @dev Returns `true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise

     * @param    _interfaceID The interface identifier, as specified in ERC-165

     */

    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {



        if (_interfaceID == 0xffffffff) {

            return false;

        }

        return _interfaceID == 0x01ffc9a7 || _interfaceID == 0x80ac58cd;

    }



    //

    // Utilities

    //



    function _isContract(address addr) internal view returns (bool) {

        uint size;

        assembly { size := extcodesize(addr) }

        return size > 0;

    }

}





contract LandMarket {

    struct Auction {

        // Auction ID

        bytes32 id;

        // Owner of the NFT

        address seller;

        // Price (in wei) for the published item

        uint256 price;

        // Time when this sale ends

        uint256 expiresAt;

    }



    mapping (uint256 => Auction) public auctionByAssetId;

    function executeOrder(uint256 assetId, uint256 price) public;

}



contract Land {

    function updateLandData(int x, int y, string data) public;

    function decodeTokenId(uint value) view public returns (int, int);

    function safeTransferFrom(address from, address to, uint256 assetId) public;

    function ownerOf(uint256 landID) public view returns (address);

}



/**

    @notice The contract is used to handle all the lifetime of a mortgage, uses RCN for the Loan and Decentraland for the parcels. 



    Implements the Cosigner interface of RCN, and when is tied to a loan it creates a new ERC721 to handle the ownership of the mortgage.



    When the loan is resolved (paid, pardoned or defaulted), the mortgaged parcel can be recovered. 



    Uses a token converter to buy the Decentraland parcel with MANA using the RCN tokens received.

*/

contract MortgageManager is Cosigner, ERC721Base, SafeWithdraw, BytesUtils {

    using SafeMath for uint256;



    uint256 constant internal PRECISION = (10**18);

    uint256 constant internal RCN_DECIMALS = 18;



    bytes32 public constant MANA_CURRENCY = 0x4d414e4100000000000000000000000000000000000000000000000000000000;

    uint256 public constant REQUIRED_ALLOWANCE = 1000000000 * 10**18;



    function name() public pure returns (string _name) {

        _name = "Decentraland RCN Mortgage";

    }



    function symbol() public pure returns (string _symbol) {

        _symbol = "LAND-RCN-Mortgage";

    }



    event RequestedMortgage(uint256 _id, address _borrower, address _engine, uint256 _loanId, uint256 _landId, uint256 _deposit, address _tokenConverter);

    event StartedMortgage(uint256 _id);

    event CanceledMortgage(address _from, uint256 _id);

    event PaidMortgage(address _from, uint256 _id);

    event DefaultedMortgage(uint256 _id);

    event UpdatedLandData(address _updater, uint256 _parcel, string _data);

    event SetCreator(address _creator, bool _status);



    Token public rcn;

    Token public mana;

    Land public land;

    LandMarket public landMarket;

    

    constructor(Token _rcn, Token _mana, Land _land, LandMarket _landMarket) public {

        rcn = _rcn;

        mana = _mana;

        land = _land;

        landMarket = _landMarket;

        mortgages.length++;

    }



    enum Status { Pending, Ongoing, Canceled, Paid, Defaulted }



    struct Mortgage {

        address owner;

        Engine engine;

        uint256 loanId;

        uint256 deposit;

        uint256 landId;

        uint256 landCost;

        Status status;

        // ERC-721

        TokenConverter tokenConverter;

    }



    uint256 internal flagReceiveLand;



    Mortgage[] public mortgages;



    mapping(address => bool) public creators;



    mapping(uint256 => uint256) public mortgageByLandId;

    mapping(address => mapping(uint256 => uint256)) public loanToLiability;



    function url() external view returns (string) {

        return "";

    }



    /**

        @notice Sets a new third party creator

        

        The third party creator can request loans for other borrowers. The creator should be a trusted contract, it could potentially take funds.

    

        @param creator Address of the creator

        @param authorized Enables or disables the permission



        @return true If the operation was executed

    */

    function setCreator(address creator, bool authorized) external onlyOwner returns (bool) {

        emit SetCreator(creator, authorized);

        creators[creator] = authorized;

        return true;

    }



    /**

        @notice Returns the cost of the cosigner



        This cosigner does not have any risk or maintenance cost, so its free.



        @return 0, because it's free

    */

    function cost(address, uint256, bytes, bytes) external view returns (uint256) {

        return 0;

    }



    /**

        @notice Requests a mortgage with a loan identifier



        @dev The loan should exist in the designated engine



        @param engine RCN Engine

        @param loanIdentifier Identifier of the loan asociated with the mortgage

        @param deposit MANA to cover part of the cost of the parcel

        @param landId ID of the parcel to buy with the mortgage

        @param tokenConverter Token converter used to exchange RCN - MANA



        @return id The id of the mortgage

    */

    function requestMortgage(

        Engine engine,

        bytes32 loanIdentifier,

        uint256 deposit,

        uint256 landId,

        TokenConverter tokenConverter

    ) external returns (uint256 id) {

        return requestMortgageId(engine, engine.identifierToIndex(loanIdentifier), deposit, landId, tokenConverter);

    }



    /**

        @notice Request a mortgage with a loan id



        @dev The loan should exist in the designated engine



        @param engine RCN Engine

        @param loanId Id of the loan asociated with the mortgage

        @param deposit MANA to cover part of the cost of the parcel

        @param landId ID of the parcel to buy with the mortgage

        @param tokenConverter Token converter used to exchange RCN - MANA



        @return id The id of the mortgage

    */

    function requestMortgageId(

        Engine engine,

        uint256 loanId,

        uint256 deposit,

        uint256 landId,

        TokenConverter tokenConverter

    ) public returns (uint256 id) {

        // Validate the associated loan

        require(engine.getCurrency(loanId) == MANA_CURRENCY, "Loan currency is not MANA");

        address borrower = engine.getBorrower(loanId);

        require(engine.getStatus(loanId) == Engine.Status.initial, "Loan status is not inital");

        require(msg.sender == engine.getBorrower(loanId) ||

               (msg.sender == engine.getCreator(loanId) && creators[msg.sender]),

            "Creator should be borrower or authorized");

        require(engine.isApproved(loanId), "Loan is not approved");

        require(rcn.allowance(borrower, this) >= REQUIRED_ALLOWANCE, "Manager cannot handle borrower's funds");

        require(tokenConverter != address(0), "Token converter not defined");

        require(loanToLiability[engine][loanId] == 0, "Liability for loan already exists");



        // Get the current parcel cost

        uint256 landCost;

        (, , landCost, ) = landMarket.auctionByAssetId(landId);

        uint256 loanAmount = engine.getAmount(loanId);



        // We expect a 10% extra for convertion losses

        // the remaining will be sent to the borrower

        require((loanAmount + deposit) >= ((landCost / 10) * 11), "Not enought total amount");



        // Pull the deposit and lock the tokens

        require(mana.transferFrom(msg.sender, this, deposit), "Error pulling mana");



        // Create the liability

        id = mortgages.push(Mortgage({

            owner: borrower,

            engine: engine,

            loanId: loanId,

            deposit: deposit,

            landId: landId,

            landCost: landCost,

            status: Status.Pending,

            tokenConverter: tokenConverter

        })) - 1;



        loanToLiability[engine][loanId] = id;



        emit RequestedMortgage({

            _id: id,

            _borrower: borrower,

            _engine: engine,

            _loanId: loanId,

            _landId: landId,

            _deposit: deposit,

            _tokenConverter: tokenConverter

        });

    }



    /**

        @notice Cancels an existing mortgage

        @dev The mortgage status should be pending

        @param id Id of the mortgage

        @return true If the operation was executed



    */

    function cancelMortgage(uint256 id) external returns (bool) {

        Mortgage storage mortgage = mortgages[id];

        

        // Only the owner of the mortgage and if the mortgage is pending

        require(msg.sender == mortgage.owner, "Only the owner can cancel the mortgage");

        require(mortgage.status == Status.Pending, "The mortgage is not pending");

        

        mortgage.status = Status.Canceled;



        // Transfer the deposit back to the borrower

        require(mana.transfer(msg.sender, mortgage.deposit), "Error returning MANA");



        emit CanceledMortgage(msg.sender, id);

        return true;

    }



    /**

        @notice Request the cosign of a loan



        Buys the parcel and locks its ownership until the loan status is resolved.

        Emits an ERC721 to manage the ownership of the mortgaged property.

    

        @param engine Engine of the loan

        @param index Index of the loan

        @param data Data with the mortgage id

        @param oracleData Oracle data to calculate the loan amount



        @return true If the cosign was performed

    */

    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool) {

        // The first word of the data MUST contain the index of the target mortgage

        Mortgage storage mortgage = mortgages[uint256(readBytes32(data, 0))];

        

        // Validate that the loan matches with the mortgage

        // and the mortgage is still pending

        require(mortgage.engine == engine, "Engine does not match");

        require(mortgage.loanId == index, "Loan id does not match");

        require(mortgage.status == Status.Pending, "Mortgage is not pending");



        // Update the status of the mortgage to avoid reentrancy

        mortgage.status = Status.Ongoing;



        // Mint mortgage ERC721 Token

        _generate(uint256(readBytes32(data, 0)), mortgage.owner);



        // Transfer the amount of the loan in RCN to this contract

        uint256 loanAmount = convertRate(engine.getOracle(index), engine.getCurrency(index), oracleData, engine.getAmount(index));

        require(rcn.transferFrom(mortgage.owner, this, loanAmount), "Error pulling RCN from borrower");

        

        // Convert the RCN into MANA using the designated

        // and save the received MANA

        uint256 boughtMana = convertSafe(mortgage.tokenConverter, rcn, mana, loanAmount);

        delete mortgage.tokenConverter;



        // Load the new cost of the parcel, it may be changed

        uint256 currentLandCost;

        (, , currentLandCost, ) = landMarket.auctionByAssetId(mortgage.landId);

        require(currentLandCost <= mortgage.landCost, "Parcel is more expensive than expected");

        

        // Buy the land and lock it into the mortgage contract

        require(mana.approve(landMarket, currentLandCost));

        flagReceiveLand = mortgage.landId;

        landMarket.executeOrder(mortgage.landId, currentLandCost);

        require(mana.approve(landMarket, 0));

        require(flagReceiveLand == 0, "ERC721 callback not called");

        require(land.ownerOf(mortgage.landId) == address(this), "Error buying parcel");



        // Calculate the remaining amount to send to the borrower and 

        // check that we didn't expend any contract funds.

        uint256 totalMana = boughtMana.add(mortgage.deposit);        



        // Return rest of MANA to the owner

        require(mana.transfer(mortgage.owner, totalMana.sub(currentLandCost)), "Error returning MANA");

        

        // Cosign contract, 0 is the RCN required

        require(mortgage.engine.cosign(index, 0), "Error performing cosign");

        

        // Save mortgage id registry

        mortgageByLandId[mortgage.landId] = uint256(readBytes32(data, 0));



        // Emit mortgage event

        emit StartedMortgage(uint256(readBytes32(data, 0)));



        return true;

    }



    /**

        @notice Converts tokens using a token converter

        @dev Does not trust the token converter, validates the return amount

        @param converter Token converter used

        @param from Tokens to sell

        @param to Tokens to buy

        @param amount Amount to sell

        @return bought Bought amount

    */

    function convertSafe(

        TokenConverter converter,

        Token from,

        Token to,

        uint256 amount

    ) internal returns (uint256 bought) {

        require(from.approve(converter, amount));

        uint256 prevBalance = to.balanceOf(this);

        bought = converter.convert(from, to, amount, 1);

        require(to.balanceOf(this).sub(prevBalance) >= bought, "Bought amount incorrect");

        require(from.approve(converter, 0));

    }



    /**

        @notice Claims the mortgage when the loan status is resolved and transfers the ownership of the parcel to which corresponds.



        @dev Deletes the mortgage ERC721



        @param engine RCN Engine

        @param loanId Loan ID

        

        @return true If the claim succeded

    */

    function claim(address engine, uint256 loanId, bytes) external returns (bool) {

        uint256 mortgageId = loanToLiability[engine][loanId];

        Mortgage storage mortgage = mortgages[mortgageId];



        // Validate that the mortgage wasn't claimed

        require(mortgage.status == Status.Ongoing, "Mortgage not ongoing");

        require(mortgage.loanId == loanId, "Mortgage don't match loan id");



        if (mortgage.engine.getStatus(loanId) == Engine.Status.paid || mortgage.engine.getStatus(loanId) == Engine.Status.destroyed) {

            // The mortgage is paid

            require(_isAuthorized(msg.sender, mortgageId), "Sender not authorized");



            mortgage.status = Status.Paid;

            // Transfer the parcel to the borrower

            land.safeTransferFrom(this, msg.sender, mortgage.landId);

            emit PaidMortgage(msg.sender, mortgageId);

        } else if (isDefaulted(mortgage.engine, loanId)) {

            // The mortgage is defaulted

            require(msg.sender == mortgage.engine.ownerOf(loanId), "Sender not lender");

            

            mortgage.status = Status.Defaulted;

            // Transfer the parcel to the lender

            land.safeTransferFrom(this, msg.sender, mortgage.landId);

            emit DefaultedMortgage(mortgageId);

        } else {

            revert("Mortgage not defaulted/paid");

        }



        // ERC721 Delete asset

        _destroy(mortgageId);



        // Delete mortgage id registry

        delete mortgageByLandId[mortgage.landId];



        return true;

    }



    /**

        @notice Defines a custom logic that determines if a loan is defaulted or not.



        @param engine RCN Engines

        @param index Index of the loan



        @return true if the loan is considered defaulted

    */

    function isDefaulted(Engine engine, uint256 index) public view returns (bool) {

        return engine.getStatus(index) == Engine.Status.lent &&

            engine.getDueTime(index).add(7 days) <= block.timestamp;

    }



    /**

        @dev An alternative version of the ERC721 callback, required by a bug in the parcels contract

    */

    function onERC721Received(uint256 _tokenId, address, bytes) external returns (bytes4) {

        if (msg.sender == address(land) && flagReceiveLand == _tokenId) {

            flagReceiveLand = 0;

            return bytes4(keccak256("onERC721Received(address,uint256,bytes)"));

        }

    }



    /**

        @notice Callback used to accept the ERC721 parcel tokens



        @dev Only accepts tokens if flag is set to tokenId, resets the flag when called

    */

    function onERC721Received(address, uint256 _tokenId, bytes) external returns (bytes4) {

        if (msg.sender == address(land) && flagReceiveLand == _tokenId) {

            flagReceiveLand = 0;

            return bytes4(keccak256("onERC721Received(address,uint256,bytes)"));

        }

    }



    /**

        @dev Reads data from a bytes array

    */

    function getData(uint256 id) public pure returns (bytes o) {

        assembly {

            o := mload(0x40)

            mstore(0x40, add(o, and(add(add(32, 0x20), 0x1f), not(0x1f))))

            mstore(o, 32)

            mstore(add(o, 32), id)

        }

    }

    

    /**

        @notice Enables the owner of a parcel to update the data field



        @param id Id of the mortgage

        @param data New data



        @return true If data was updated

    */

    function updateLandData(uint256 id, string data) external returns (bool) {

        Mortgage memory mortgage = mortgages[id];

        require(_isAuthorized(msg.sender, id), "Sender not authorized");

        int256 x;

        int256 y;

        (x, y) = land.decodeTokenId(mortgage.landId);

        land.updateLandData(x, y, data);

        emit UpdatedLandData(msg.sender, id, data);

        return true;

    }



    /**

        @dev Replica of the convertRate function of the RCN Engine, used to apply the oracle rate

    */

    function convertRate(Oracle oracle, bytes32 currency, bytes data, uint256 amount) internal returns (uint256) {

        if (oracle == address(0)) {

            return amount;

        } else {

            uint256 rate;

            uint256 decimals;

            

            (rate, decimals) = oracle.getRate(currency, data);



            require(decimals <= RCN_DECIMALS, "Decimals exceeds max decimals");

            return (amount.mult(rate).mult((10**(RCN_DECIMALS-decimals)))) / PRECISION;

        }

    }

}