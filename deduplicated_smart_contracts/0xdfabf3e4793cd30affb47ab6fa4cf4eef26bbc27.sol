/**

 *Submitted for verification at Etherscan.io on 2018-11-12

*/



pragma solidity ^0.4.24;



/**

 * @title Ownable

 * @dev The Ownable contract has an owner address, and provides basic authorization control

 * functions, this simplifies the implementation of "user permissions".

 */

contract Ownable {

  address public owner;





  event OwnershipRenounced(address indexed previousOwner);

  event OwnershipTransferred(

    address indexed previousOwner,

    address indexed newOwner

  );





  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  constructor() public {

    owner = msg.sender;

  }



  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }



  /**

   * @dev Allows the current owner to relinquish control of the contract.

   */

  function renounceOwnership() public onlyOwner {

    emit OwnershipRenounced(owner);

    owner = address(0);

  }



  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function transferOwnership(address _newOwner) public onlyOwner {

    _transferOwnership(_newOwner);

  }



  /**

   * @dev Transfers control of the contract to a newOwner.

   * @param _newOwner The address to transfer ownership to.

   */

  function _transferOwnership(address _newOwner) internal {

    require(_newOwner != address(0));

    emit OwnershipTransferred(owner, _newOwner);

    owner = _newOwner;

  }

}



/**

 * @title ERC20 interface

 * @dev see https://github.com/ethereum/EIPs/issues/20

 */

interface IERC20 {

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address _owner) external view returns (uint256);

    function allowance(address _owner, address _spender) external view returns (uint256);

    function transfer(address _to, uint256 _value) external returns (bool);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);

    function approve(address _spender, uint256 _value) external returns (bool);

    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);

    function increaseApproval(address _spender, uint _addedValue) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



/**

 * @title Utility contract to allow owner to retreive any ERC20 sent to the contract

 */

contract ReclaimTokens is Ownable {



    /**

    * @notice Reclaim all ERC20Basic compatible tokens

    * @param _tokenContract The address of the token contract

    */

    function reclaimERC20(address _tokenContract) external onlyOwner {

        require(_tokenContract != address(0), "Invalid address");

        IERC20 token = IERC20(_tokenContract);

        uint256 balance = token.balanceOf(address(this));

        require(token.transfer(owner, balance), "Transfer failed");

    }

}



/**

 * @title Core functionality for registry upgradability

 */

contract PolymathRegistry is ReclaimTokens {



    mapping (bytes32 => address) public storedAddresses;



    event ChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);



    /**

     * @notice Gets the contract address

     * @param _nameKey is the key for the contract address mapping

     * @return address

     */

    function getAddress(string _nameKey) external view returns(address) {

        bytes32 key = keccak256(bytes(_nameKey));

        require(storedAddresses[key] != address(0), "Invalid address key");

        return storedAddresses[key];

    }



    /**

     * @notice Changes the contract address

     * @param _nameKey is the key for the contract address mapping

     * @param _newAddress is the new contract address

     */

    function changeAddress(string _nameKey, address _newAddress) external onlyOwner {

        bytes32 key = keccak256(bytes(_nameKey));

        emit ChangeAddress(_nameKey, storedAddresses[key], _newAddress);

        storedAddresses[key] = _newAddress;

    }





}