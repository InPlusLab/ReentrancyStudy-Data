/**

 *Submitted for verification at Etherscan.io on 2018-09-11

*/



pragma solidity ^0.4.2;



contract StephenZhengToken {

    string  public name = "Stephen Zheng Token";

    string  public symbol = "SZZT";

    string  public standard = "Stephen Zheng Token v1.0";

    uint256 public totalSupply;



    event Transfer(

        address indexed _from,

        address indexed _to,

        uint256 _value

    );



    event Approval(

        address indexed _owner,

        address indexed _spender,

        uint256 _value

    );



    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;



    function StephenZhengToken () public {

        totalSupply = 1000000000;

        balanceOf[msg.sender] = totalSupply;

    }



    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value);



        balanceOf[msg.sender] -= _value;

        balanceOf[_to] += _value;



        emit Transfer(msg.sender, _to, _value);



        return true;

    }



    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;



        emit Approval(msg.sender, _spender, _value);



        return true;

    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(_value <= balanceOf[_from]);

        require(_value <= allowance[_from][msg.sender]);



        balanceOf[_from] -= _value;

        balanceOf[_to] += _value;



        allowance[_from][msg.sender] -= _value;



        emit Transfer(_from, _to, _value);



        return true;

    }

}



contract StephenZhengTokenSale {

    address admin;

    StephenZhengToken public tokenContract;

    uint256 public tokenPrice;

    uint256 public tokensSold;



    event Sell(address _buyer, uint256 _amount);



    function StephenZhengTokenSale(StephenZhengToken _tokenContract, uint256 _tokenPrice) public {

        admin = msg.sender;

        tokenContract = _tokenContract;

        tokenPrice = _tokenPrice;

    }



    function multiply(uint x, uint y) internal pure returns (uint z) {

        require(y == 0 || (z = x * y) / y == x);

    }



    function buyTokens(uint256 _numberOfTokens) public payable {

        require(msg.value == multiply(_numberOfTokens, tokenPrice));

        require(tokenContract.balanceOf(this) >= _numberOfTokens);

        require(tokenContract.transfer(msg.sender, _numberOfTokens));



        tokensSold += _numberOfTokens;



        emit Sell(msg.sender, _numberOfTokens);

    }



    function endSale() public {

        require(msg.sender == admin);

        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));



        selfdestruct(admin);

    }

}