/**

 *Submitted for verification at Etherscan.io on 2019-05-29

*/



pragma solidity ^0.4.21;



/**

 * Math operations with safety checks

 */

library SafeMath {



	function mul(uint256 a, uint256 b) internal constant returns (uint256) {

		uint256 c = a * b;

		require(a == 0 || c / a == b);

		return c;

	}



	function div(uint256 a, uint256 b) internal constant returns (uint256) {

		uint256 c = a / b;

		return c;

	}



	function sub(uint256 a, uint256 b) internal constant returns (uint256) {

		require(b <= a);

		return a - b;

	}



	function add(uint256 a, uint256 b) internal constant returns (uint256) {

		uint256 c = a + b;

		require(c>=a && c>=b);

		return c;

	}

}



contract UNBInterface {



	/// total amount of tokens

	uint256 public totalSupply;



	/// @notice send `_value` token to `_to` from `msg.sender`

	/// @param _to The address of the recipient

	/// @param _value The amount of token to be transferred

	/// @return Whether the transfer was successful or not

	function transfer(address _to, uint256 _value) public returns (bool success);



	/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`

	/// @param _from The address of the sender

	/// @param _to The address of the recipient

	/// @param _value The amount of token to be transferred

	/// @return Whether the transfer was successful or not

	function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);



	/// @param _owner The address from which the balance will be retrieved

	/// @return The balance

	function balanceOf(address _owner) public view returns (uint256 balance);



	/// @notice `msg.sender` approves `_spender` to spend `_value` tokens

	/// @param _spender The address of the account able to transfer the tokens

	/// @param _value The amount of tokens to be approved for transfer

	/// @return Whether the approval was successful or not

	function approve(address _spender, uint256 _value) public returns (bool success);



	/// @param _owner The address of the account owning tokens

	/// @param _spender The address of the account able to transfer the tokens

	/// @return Amount of remaining tokens allowed to spent

	function allowance(address _owner, address _spender) public view returns (uint256 remaining);



	// solhint-disable-next-line no-simple-event-func-name

	event Transfer(address indexed _from, address indexed _to, uint256 _value);



	event Approval(address indexed _owner, address indexed _spender, uint256 _value);

	

	/* This notifies clients about the amount burnt */

    event Burn(address indexed from, uint256 value);

	

	/* This notifies clients about the amount frozen */

    event Freeze(address indexed from, uint256 value);

	

	/* This notifies clients about the amount unfrozen */

    event Unfreeze(address indexed from, uint256 value);

}



contract UNB is UNBInterface {



	using SafeMath for uint256;



    uint256 constant private MAX_UINT256 = 2**256 - 1;

    

    mapping (address => uint256) public balances;

	

	mapping (address => uint256) public freezes;

    

    mapping (address => mapping (address => uint256)) public allowed;



    /*

    NOTE:

    The following variables are OPTIONAL vanities. One does not have to include them.

    They allow one to customise the token contract & in no way influences the core functionality.

    Some wallets/

    

    

     might not even bother to look at this information.

    */

    string public name;                   //fancy name: eg Simon Bucks

    uint8 public decimals;                //How many decimals to show.

    string public symbol;                 //An identifier: eg SBX



    function UNB (

        uint256 _initialAmount,

        string _tokenName,

        uint8 _decimalUnits,

        string _tokenSymbol

    ) public {

        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens

        totalSupply = _initialAmount;                        // Update total supply

        name = _tokenName;                                   // Set the name for display purposes

        decimals = _decimalUnits;                            // Amount of decimals for display purposes

        symbol = _tokenSymbol;                               // Set the symbol for display purposes

    }



    /// @notice send `_value` token to `_to` from `msg.sender`

    /// @param _to The address of the recipient

    /// @param _value The amount of token to be transferred

    /// @return Whether the transfer was successful or not

    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(_to != 0x0);

        require(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]);

        balances[msg.sender] -= _value;

        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars

        return true;

    }



    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`

    /// @param _from The address of the sender

    /// @param _to The address of the recipient

    /// @param _value The amount of token to be transferred

    /// @return Whether the transfer was successful or not

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        uint256 allowance = allowed[_from][msg.sender];

        require(balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to]);

        require(_to != 0x0);

        balances[_to] += _value;

        balances[_from] -= _value;

        if (allowance < MAX_UINT256) {

            allowed[_from][msg.sender] -= _value;

        }

        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars

        return true;

    }



    /// @param _owner The address from which the balance will be retrieved

    /// @return The balance

    function balanceOf(address _owner) public view returns (uint256 balance) {

        return balances[_owner];

    }



    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens

    /// @param _spender The address of the account able to transfer the tokens

    /// @param _value The amount of tokens to be approved for transfer

    /// @return Whether the approval was successful or not

    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars

        return true;

    }



    /// @param _owner The address of the account owning tokens

    /// @param _spender The address of the account able to transfer the tokens

    /// @return Amount of remaining tokens allowed to spent

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {

        return allowed[_owner][_spender];

    }

	

	function burn(uint256 _value) public returns (bool success) {

		require(_value > 0); 

        require(balances[msg.sender] >= _value);            // Check if the sender has enough

        balances[msg.sender] = balances[msg.sender].sub(_value);                      // Subtract from the sender

        totalSupply = totalSupply.sub(_value);                                // Updates totalSupply

        emit Burn(msg.sender, _value);

        return true;

    }

	

	function freeze(uint256 _value) public returns (bool success) {

		require(_value > 0); 

        require(balances[msg.sender] >= _value);            // Check if the sender has enough

        balances[msg.sender] = balances[msg.sender].sub(_value);                      // Subtract from the sender

        freezes[msg.sender] = freezes[msg.sender].add(_value);                                // Updates totalSupply

        emit Freeze(msg.sender, _value);

        return true;

    }

	

	function unfreeze(uint256 _value) public returns (bool success) {

		require(_value > 0); 

		require(freezes[msg.sender] >= _value);// Check if the sender has enough

        freezes[msg.sender] = freezes[msg.sender].sub(_value);                      // Subtract from the sender

		balances[msg.sender] = balances[msg.sender].add(_value);

        emit Unfreeze(msg.sender, _value);

        return true;

    }

}