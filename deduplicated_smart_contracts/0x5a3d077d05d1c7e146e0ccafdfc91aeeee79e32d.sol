{{

  "language": "Solidity",

  "sources": {

    "src/Asset/erc1155/AssetApproveExtension.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../../Libraries/BytesUtil.sol\";\n\ncontract AssetApproveExtension { // will expect TheSandBox721\n\n    mapping(address => mapping(address => uint256)) approvalMessages;\n    // TODO mapping(address => mapping (uint256 => bool)) usedApprovalMessages;\n\n    // TODO remove as we can use erc1155 totkensReceived hook\n    function setApprovalForAllAndCall(address _target, bytes memory _data) public payable returns(bytes memory){\n        require(BytesUtil.doFirstParamEqualsAddress(_data, msg.sender), \"first param != sender\");\n        _setApprovalForAllFrom(msg.sender, _target, true);\n        (bool success, bytes memory returnData) = _target.call.value(msg.value)(_data);\n        require(success, \"Something went wrong with the extra call.\");\n        return returnData;\n    }\n\n    function approveAllViaSignedMessage(address _target, uint256 _nonce, bytes calldata signature) external {\n        address signer; // TODO ecrecover(hash, v, r, s);\n        require(approvalMessages[signer][_target]++ == _nonce);\n        _setApprovalForAllFrom(signer, _target, true);\n    }\n\n    // TODO 2 signatures one for approve and one for call ?\n    function approveAllAndCallViaSignedMessage(address _target, uint256 _nonce, bytes calldata _data, bytes calldata signature) external payable returns(bytes memory){\n        address signer; // TODO ecrecover(hash, v, r, s);\n        require(BytesUtil.doFirstParamEqualsAddress(_data, signer), \"first param != signer\");\n        require(approvalMessages[signer][_target]++ == _nonce);\n        _setApprovalForAllFrom(signer, _target, true);\n        (bool success, bytes memory returnData) = _target.call.value(msg.value)(_data);\n        require(success, \"Something went wrong with the extra call.\");\n        return returnData;\n    }\n\n    function _setApprovalForAllFrom(address owner, address _operator, bool _approved) internal;\n\n    \n}"

    },

    "src/Asset/ERC1155ERC721.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Interfaces/ERC1155.sol\";\n\nimport \"../Libraries/AddressUtils.sol\";\nimport \"../Libraries/ObjectLib32.sol\";\nimport \"../Libraries/SafeMath.sol\";\nimport \"../Libraries/BytesUtil.sol\";\n\nimport \"../Interfaces/ERC721.sol\";\nimport \"../Interfaces/ERC721TokenReceiver.sol\";\nimport \"../Interfaces/ERC20.sol\";\nimport \"../Sand.sol\";\n\nimport \"./Interfaces/MintingFeeCollector.sol\";\n\nimport { ProxyImplementation } from \"../Libraries/ProxyImplementation.sol\";\n\ncontract ERC1155ERC721 is ProxyImplementation, ERC1155, ERC721 {\n\n    ////////////////// Super Operators ///////////////////////////////////////////////////////\n    // Allowing extension without redeploy\n    mapping(address => bool) internal mSuperOperators;\n    address public admin;\n    event AdminChanged(address oldAdmin, address newAdmin);\n    function changeAdmin(address _admin) external {\n        require(msg.sender == admin, \"only admin can change admin\");\n        emit AdminChanged(admin, _admin);\n        admin = _admin;\n    }\n    event SuperOperator(address superOperator, bool enabled);\n    function setSuperOperator(address _superOperator, bool _enabled) external {\n        require(msg.sender == admin, \"only admin is allowed to add super operators\");\n        mSuperOperators[_superOperator] = _enabled; \n        emit SuperOperator(_superOperator, _enabled);\n    }\n    function isSuperOperator(address who) public view returns(bool) {\n        return mSuperOperators[who];\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n\n    // LIBRARIES /////////////////////////////////////////////////////////////////////////\n    using AddressUtils for address;\n    using ObjectLib32 for ObjectLib32.Operations;\n    using ObjectLib32 for uint256;\n    using SafeMath for uint256;\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    // CONSTANTS //////////////////////////////////////////////////////////////////////////////////\n    bytes4 constant private ERC1155_REJECTED = 0xafed434d; // keccak256(\"reject_erc1155_tokens()\")\n    bytes4 constant private ERC1155_RECEIVED = 0xf23a6e61; // TODO use latest spec // better yet : generate it\n    bytes4 constant private ERC1155_BATCH_RECEIVED = 0xbc197c81; // TODO use latest spec // better yet : generate it\n    bytes4 constant private ERC721_RECEIVED = 0x150b7a02; // TODO use latest spec // better yet : generate it\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    // STORAGE /////////////////////////////////////////////////////////////////////////////////////  \n    uint88 nextSubId;\n    mapping(address => uint256) numNFTPerAddress; // required for erc721\n    mapping(uint256 => address) owners; // required for erc721\n    mapping(address => mapping(uint256 => uint256)) packedTokenBalance; // required for erc1155\n    mapping(address => mapping(address => bool)) operatorsForAll; // required for erc721 and erc1155\n    mapping(uint256 => address) erc721_operators; // required for erc721\n    mapping(uint256 => address) creators; // use only for when changing original creator // TODO\n    mapping (uint256 => string) public erc721_metadataURIs; // required for erc721\n    mapping (uint256 => bytes32) public erc1155_metadataURIHashes; // required for extraction\n    \n\n    uint256 public mintingFee;\n    address feeCollector;\n    Sand _sandContract;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    constructor(Sand sand, address _feeCollector, address _admin) public {\n        initERC1155ERC721(sand, _feeCollector, _admin);\n    }\n\n    function initERC1155ERC721(Sand sand, address _feeCollector, address _admin) public phase('ERC1155ERC721'){\n         nextSubId = 1; // set here to non-zero so it can cover the cost of first minting\n        _sandContract = sand;\n        feeCollector = _feeCollector;\n        admin = _admin;\n    }\n\n    function sandContract() internal view returns(Sand) {\n        return _sandContract;\n    }\n\n    function setFeeCollection(address _newFeeCollector, uint256 _newFee) external {\n        require(msg.sender == feeCollector, \"only feeCollector can update\");\n        feeCollector = _newFeeCollector;\n        mintingFee = _newFee;\n    }\n\n    function mint(address _sender, uint256 _sandAmount, uint88 _subId, string calldata _uri, uint256 _supply, address _owner, bytes calldata _data) external returns (uint256 tokenId) {\n        require(_owner != address(0), \"Invalid owner\");\n        require(msg.sender == _sender || msg.sender == address(_sandContract), \"sender != msg.sender && sandContract\");\n        require(_sandAmount == mintingFee, \"fee not matching\");\n        if(_sandAmount > 0) {\n            _sandContract.transferFrom(_sender, feeCollector, _sandAmount);\n        }\n        require(bytes(_uri).length > 0, \"uri cannot be an empty string\");\n        if(_subId == 0) {\n            tokenId = uint256(_sender) * 2**(256-160) + 0 * 2**(256-160-8) + nextSubId;\n            nextSubId++;\n        } else {\n            tokenId = uint256(_sender) * 2**(256-160) + 1 * 2**(256-160-8) + _subId;\n        }\n        _mint(_uri, _supply, _sender, _owner, tokenId, _data);\n        if(feeCollector.isContract()) {\n            MintingFeeCollector(feeCollector).single_minted(tokenId, _sandAmount);\n        }\n    }\n\n    function _mint(string memory _uri, uint256 _supply, address _creator, address _owner, uint256 tokenId, bytes memory _data) internal {\n        if(_supply == 1) { // ERC721\n            require(bytes(erc721_metadataURIs[tokenId]).length == 0, \"tokenId already used\");\n            numNFTPerAddress[_owner] ++;\n            owners[tokenId] = _owner;\n            emit Transfer(address(0), _owner, tokenId);\n            erc721_metadataURIs[tokenId] = _uri;\n        } else {\n            require(uint256(erc1155_metadataURIHashes[tokenId]) == 0, \"tokenId already used\");\n            (uint256 bin, uint256 index) = tokenId.getTokenBinIndex();\n            packedTokenBalance[_owner][bin] =\n            packedTokenBalance[_owner][bin].updateTokenBalance(\n                index, _supply, ObjectLib32.Operations.REPLACE\n            );\n            erc1155_metadataURIHashes[tokenId] = keccak256(abi.encodePacked(_uri));\n        }\n\n        emit TransferSingle(_creator, address(0), _owner, tokenId, _supply);\n        emit URI(_uri, tokenId);\n\n        require(_checkERC1155AndCallSafeTransfer(_creator, address(0), _owner, tokenId, _supply, _data, _supply == 1, false));\n    }\n\n    function mintMultiple(address _sender, uint256 _sandAmount, uint88 firstSubId, string calldata _uris, uint16[] calldata lengths, uint256[] calldata _supplies, address _owner, bytes calldata _data) external { \n        require(_owner != address(0), \"Invalid owner\");\n        require(msg.sender == _sender || msg.sender == address(_sandContract), \"sender != msg.sender && sandContract\");\n        require(_sandAmount == mintingFee * _supplies.length, \"fee not matching\");\n        if(_sandAmount > 0) {\n            _sandContract.transferFrom(_sender, feeCollector, _sandAmount);\n        }\n        require(lengths.length == _supplies.length, \"Inconsistent array length between args lengths and supplies.\");\n        uint256[] memory tokenIds = generateTokenIds(_sender, firstSubId, _supplies.length);\n        _mintBatchesWithNFTs(_sender, _uris, lengths, _supplies, 0, _owner, tokenIds[0]);\n        emit TransferBatch(_sender, address(0), _owner, tokenIds, _supplies);\n        require(_checkERC1155AndCallSafeBatchTransfer(_sender, address(0), _owner, tokenIds, _supplies, _data));\n        if(feeCollector.isContract()) {\n            MintingFeeCollector(feeCollector).multiple_minted(tokenIds, mintingFee);\n        }\n    }\n\n    function generateTokenIds(address _creator, uint88 firstSubId, uint256 numTokens) internal returns (uint256[] memory){\n        uint256[] memory tokenIds = new uint256[](numTokens);\n        uint256 baseId;\n        if(firstSubId == 0) {\n            baseId = uint256(_creator) * 2**(256-160) + nextSubId;\n            nextSubId = uint88(nextSubId + numTokens);\n        } else {\n            baseId = uint256(_creator) * 2**(256-160) + 1 * 2**(256-160-8) + firstSubId;\n        }\n        for(uint16 i = 0; i < numTokens; i++) {\n            tokenIds[i] = baseId + i;\n        }\n        return tokenIds;\n    }\n\n    function mintMultipleWithNFT(address _sender, uint256 _sandAmount, uint88 firstSubId, string calldata _uris, uint16[] calldata lengths, uint256[] calldata _supplies, uint16 numNFTs, address _owner, bytes calldata _data) external { \n        require(_owner != address(0), \"Invalid owner\");\n        require(msg.sender == _sender || msg.sender == address(_sandContract), \"sender != msg.sender && sandContract\");\n        require(lengths.length == _supplies.length + numNFTs, \"Inconsistent array length between args lengths and supplies.\");\n        require(_sandAmount == mintingFee * lengths.length , \"fee not matching\");\n        if(_sandAmount > 0) {\n            _sandContract.transferFrom(_sender, feeCollector, _sandAmount);\n        }\n        uint256[] memory tokenIds = generateTokenIds(_sender, firstSubId, lengths.length);\n        _mintBatchesWithNFTs(_sender, _uris, lengths, _supplies, numNFTs, _owner, tokenIds[0]);\n        emit TransferBatch(_sender, address(0), _owner, tokenIds, _supplies);\n        require(_checkERC1155AndCallSafeBatchTransfer(_sender, address(0), _owner, tokenIds, _supplies, _data));\n        if(feeCollector.isContract()) {\n            MintingFeeCollector(feeCollector).multiple_minted(tokenIds, mintingFee);\n        }\n    }\n\n    function _mintBatchesWithNFTs(address _creator, string memory _uris, uint16[] memory lengths, uint256[] memory _supplies, uint16 numNFTs, address _owner, uint256 _firstId) internal {\n        bytes memory stringBytes = bytes(_uris);\n        uint32 readingPointer = _mintBatches(stringBytes, lengths, _supplies, _creator, _owner, _firstId);\n        // deal with NFT last. they do not care of balance packing\n        if(numNFTs > 0 ) {\n            _mintNFTs(stringBytes, readingPointer, uint16(_supplies.length), lengths, numNFTs, _creator, _owner, _firstId);\n        }\n    }\n\n    function _mintBatches(bytes memory stringBytes, uint16[] memory lengths, uint256[] memory _supplies, address _creator, address _owner, uint256 _firstId) internal returns (uint32 readingPointer) {\n        readingPointer = 0x20;\n        for (uint16 offset = 0; offset < uint16(_supplies.length); offset += 8) {\n            readingPointer = _mintBatch(stringBytes, readingPointer, offset, lengths, _supplies, _creator, _owner, _firstId + offset);\n        }\n    }\n\n    function _mintNFTs(bytes memory stringBytes, uint32 readingPointer, uint16 offset, uint16[] memory lengths, uint32 numNFTs, address _creator, address _owner, uint256 _firstId) internal {\n        for (uint16 i = 0; i < numNFTs; i++) {\n            numNFTPerAddress[_owner] ++;\n            uint256 _id = _firstId+i+offset;\n            require(bytes(erc721_metadataURIs[_id]).length == 0, \"tokenId already used\");\n            owners[_id] = _owner;\n            emit Transfer(address(0), _owner, _id);\n            uint ptr;\n            assembly {\n                ptr := add(stringBytes, readingPointer)\n            }\n            bytes memory tmp = BytesUtil.toBytes(ptr, lengths[offset + i]);\n            readingPointer += lengths[offset + i];\n            erc721_metadataURIs[_id] = string(tmp);\n            emit TransferSingle(_creator, address(0), _owner, _id, 1);\n            emit URI(string(tmp), _id);\n        }\n    }\n\n    function _mintBatch(bytes memory stringBytes, uint32 readingPointer, uint16 offset, uint16[] memory lengths, uint256[] memory _supplies, address _creator, address _owner, uint256 _fromId) internal returns(uint32 newReadingPointer) {\n        uint16 batchSize = uint16(_supplies.length) - offset;\n        if(batchSize > 8) {\n            batchSize = 8;//ObjectLib32.TYPES_PER_UINT256;\n        }\n        \n        (uint256 bin,) = _fromId.getTokenBinIndex();\n        (uint32 readingPointer, uint256 newBalance) = _packMintBatch(\n            stringBytes,\n            readingPointer,\n            offset,\n            lengths,\n            _supplies,\n            packedTokenBalance[_owner][bin],\n            _fromId,\n            batchSize\n        );\n        packedTokenBalance[_owner][bin] = newBalance;\n        return readingPointer;\n    }\n\n    function _packMintBatch(\n        bytes memory stringBytes, \n        uint32 readingPointer,\n        uint16 offset,\n        uint16[] memory lengths, \n        uint256[] memory _supplies, \n        uint256 _packedBalance, \n        uint256 firstId,\n        uint16 batchSize\n    ) internal returns (\n        uint32 newReadingPointer,\n        uint256 newBalance\n    ) {\n        newReadingPointer = readingPointer;\n        newBalance = _packedBalance;\n        (,uint256 index) = firstId.getTokenBinIndex();\n        for (uint256 i = 0; i < batchSize; i++) {\n            require(uint256(erc1155_metadataURIHashes[firstId + i]) == 0, \"tokenId already used\");\n            uint256 j = offset + i;\n            uint256 ptr;\n            assembly {\n                ptr := add(stringBytes, newReadingPointer)\n            }\n            bytes memory tmp = BytesUtil.toBytes(ptr, lengths[j]);\n            newReadingPointer += lengths[j];\n            require(_supplies[j] > 1, \"Minting with supply 1 not supported yet.\");\n            newBalance = newBalance.updateTokenBalance(index + i, _supplies[j], ObjectLib32.Operations.REPLACE);\n            erc1155_metadataURIHashes[firstId + i] = keccak256(tmp);\n            emit URI(string(tmp), firstId + i);\n        }\n    }\n    \n    function _transferFrom(address _from, address _to, uint256 _id, uint256 _value) internal {\n        require(_to != address(0), \"Invalid to address\");\n        if(_from != msg.sender && msg.sender != address(_sandContract)) {\n            require(mSuperOperators[msg.sender] || operatorsForAll[_from][msg.sender] || erc721_operators[_id] == msg.sender, \"Operator not approved\");\n        }\n\n        if(owners[_id] != address(0)) { // NFT \n            require(_value == 1, \"cannot transfer nft if amount not 1\");\n            numNFTPerAddress[_from] --;\n            numNFTPerAddress[_to] ++;\n            owners[_id] = _to;\n            if(erc721_operators[_id] != address(0)) { erc721_operators[_id] = address(0); }\n            emit Transfer(_from, _to, _id);\n        } else {\n            (uint256 bin, uint256 index) = (_id & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFF).getTokenBinIndex();\n            packedTokenBalance[_from][bin] =\n                packedTokenBalance[_from][bin].updateTokenBalance(\n                    index, _value, ObjectLib32.Operations.SUB\n            );\n            packedTokenBalance[_to][bin] =\n                packedTokenBalance[_to][bin].updateTokenBalance(\n                    index, _value, ObjectLib32.Operations.ADD\n            );\n        }\n\n        emit TransferSingle(msg.sender == address(_sandContract) ? _from : msg.sender, _from, _to, _id, _value);\n    }\n\n    // function transferFrom(address _from, address _to, uint256 _id, uint256 _value) external {\n    //     _transferFrom(_from, _to, _id, _value);\n    // }\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external {\n        _transferFrom(_from, _to, _id, _value);\n        require(_checkERC1155AndCallSafeTransfer(msg.sender == address(_sandContract) ? _from : msg.sender, _from, _to, _id, _value, _data, false, false));\n    }\n\n\n    // function batchTransferFrom(address _from, address _to, uint256[]calldata  _ids, uint256[] calldata _values) external {\n    //     _batchTransferFrom(_from, _to, _ids, _values);\n    // }\n\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external {\n        _batchTransferFrom(_from, _to, _ids, _values);\n        require(_checkERC1155AndCallSafeBatchTransfer(msg.sender == address(_sandContract) ? _from : msg.sender, _from, _to, _ids, _values, _data));\n    }\n\n    // NOTE: call data should be optimized to order _ids so packedBalance can be used efficiently\n    function _batchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) internal {\n        require(_ids.length == _values.length, \"Inconsistent array length between args\");\n        require(_to != address(0), \"Invalid recipient\");\n        bool authorized = mSuperOperators[msg.sender] || operatorsForAll[_from][msg.sender] || _from == msg.sender || msg.sender == address(_sandContract);\n\n        uint256 bin;\n        uint256 index;\n        uint256 balFrom;\n        uint256 balTo; \n\n        // Last bin updated       \n        uint256 lastBin;\n        for (uint256 i = 0; i < _ids.length; i++) {\n            require(authorized || erc721_operators[_ids[i]] == msg.sender, \"Operators not approved\");\n            if(owners[_ids[i]] != address(0)) { // NFT \n                require(owners[_ids[i]] == _from, \"not owner\");\n                require(_values[i] == 1, \"cannot transfer nft if amount not 1\");\n                numNFTPerAddress[_from] --;\n                numNFTPerAddress[_to] ++;\n                owners[_ids[i]] = _to;\n                erc721_operators[_ids[i]] = address(0);\n                emit Transfer(_from, _to, _ids[i]);\n            } else {\n                (bin, index) = (_ids[i] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFF).getTokenBinIndex();\n                // If first bin\n                if (i == 0) {\n                    lastBin = bin;\n                    balFrom = ObjectLib32.updateTokenBalance(packedTokenBalance[_from][bin], index, _values[i], ObjectLib32.Operations.SUB);\n                    balTo = ObjectLib32.updateTokenBalance(packedTokenBalance[_to][bin], index, _values[i], ObjectLib32.Operations.ADD); \n                } else {\n                    // If new bin\n                    if (bin != lastBin) { // _ids need to be ordered appropriately to benefit for optimization\n                        // Update storage balance of previous bin\n                        packedTokenBalance[_from][lastBin] = balFrom;\n                        packedTokenBalance[_to][lastBin] = balTo;\n\n                        // Load current bin balance in memory\n                        balFrom = packedTokenBalance[_from][bin];\n                        balTo = packedTokenBalance[_to][bin];\n\n                        // Bin will be the most recent bin\n                        lastBin = bin;\n                    }\n\n                    // Update memory balance\n                    balFrom = balFrom.updateTokenBalance(index, _values[i], ObjectLib32.Operations.SUB);\n                    balTo = balTo.updateTokenBalance(index, _values[i], ObjectLib32.Operations.ADD);    \n                }\n            }\n        }\n\n        if(bin != 0 || index != 0) { // at least one MCFT\n            // Update storage of the last bin visited\n            packedTokenBalance[_from][bin] = balFrom;\n            packedTokenBalance[_to][bin] = balTo;    \n        }\n        \n        emit TransferBatch(msg.sender == address(_sandContract) ? _from : msg.sender, _from, _to, _ids, _values);\n    }\n\n    function balanceOf(address _owner, uint256 _id) public view returns (uint256) {\n        if(owners[_id] != address(0)) {\n            if(owners[_id] == _owner) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n        (uint256 bin, uint256 index) = (_id & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFF).getTokenBinIndex();\n        return packedTokenBalance[_owner][bin].getValueInBin(index);\n    }\n\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory){\n        require(_owners.length == _ids.length, \"Inconsistent array length between args\");\n        uint256[] memory balances = new uint256[](_ids.length);\n        for(uint256 i = 0; i < _ids.length; i++){\n            balances[i] = balanceOf(_owners[i], _ids[i]);\n        }\n        return balances;\n    }\n\n    function creatorOf(uint256 _id) public view returns (address) {\n        address storedCreator = creators[_id];\n        if(storedCreator == address(0) && (owners[_id] != address(0) || uint256(erc1155_metadataURIHashes[_id]) != 0)) {\n            return address(_id / 2**(256-160));\n        }\n        return storedCreator;\n    }\n\n    // function transferCreatorship(uint256 _id, )\n\n    // TODO renable vy reinjecting supply into the token id ?\n    // function supplyOf(uint256 _id) public pure returns (uint256) {\n    //     return uint56(_id) / 2**24;\n    // }\n\n    // Operators /////////////////////////////////////////////////////////////////////////////////////\n\n    function setApprovalForAllFor(address _sender, address _operator, bool _approved) external {\n        require(msg.sender == _sender || msg.sender == address(_sandContract) || mSuperOperators[msg.sender], \"require meta approval\");\n        _setApprovalForAll(_sender, _operator, _approved);\n    }\n    function setApprovalForAll(address _operator, bool _approved) external {\n        _setApprovalForAll(msg.sender, _operator, _approved);\n    }\n    function _setApprovalForAll(address _sender, address _operator, bool _approved) internal {\n        require(!mSuperOperators[_operator], \"super operator can't have their approvalForAll changed\");\n        operatorsForAll[_sender][_operator] = _approved;\n        emit ApprovalForAll(_sender, _operator, _approved);\n    }\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator) {\n        return operatorsForAll[_owner][_operator] || mSuperOperators[_operator];\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    // ERC721 ///////////////////////////////////////\n    function balanceOf(address _owner) external view returns (uint256 _balance) {\n        require(_owner != address(0));\n        return numNFTPerAddress[_owner];\n    }\n    function ownerOf(uint256 _id) external view returns (address _owner){\n        _owner = owners[_id];\n        require(_owner != address(0));\n    }\n    \n    function approveFor(address _sender, address _operator, uint256 _id) external {\n        address owner = owners[_id];\n        require(msg.sender == _sender || msg.sender == address(_sandContract) || mSuperOperators[msg.sender] || operatorsForAll[_sender][msg.sender], \"require operators\");\n        require(owner == _sender);\n        erc721_operators[_id] = _operator;\n        emit Approval(owner, _operator, _id);\n    }\n    function approve(address _operator, uint256 _id) external {\n        address owner = owners[_id];\n        require(owner == msg.sender || mSuperOperators[msg.sender] || operatorsForAll[owner][msg.sender]);\n        erc721_operators[_id] = _operator;\n        emit Approval(owner, _operator, _id);\n    }\n    function getApproved(uint256 _id) external view returns (address _operator){\n        require(owners[_id] != address(0));\n        return erc721_operators[_id];\n    }\n    function transferFrom(address _from, address _to, uint256 _id) external{\n        require(_to != address(0));\n        require(owners[_id] == _from);\n        if(msg.sender != _from && msg.sender != address(_sandContract)) {\n            require(operatorsForAll[_from][msg.sender] || erc721_operators[_id] == msg.sender || mSuperOperators[msg.sender], \"Operator not approved\");\n        }\n        _transferFrom(_from, _to, _id, 1);\n        require(_checkERC1155AndCallSafeTransfer(msg.sender == address(_sandContract) ? _from : msg.sender, _from, _to, _id, 1, \"\", true, false));\n    }\n    function safeTransferFrom(address _from, address _to, uint256 _id) external {\n        safeTransferFrom(_from, _to, _id, \"\");\n    }\n    function safeTransferFrom(address _from, address _to, uint256 _id, bytes memory _data) public {\n        require(_to != address(0));\n        require(owners[_id] == _from);\n        if(msg.sender != _from && msg.sender != address(_sandContract)) {\n            require(operatorsForAll[_from][msg.sender] || erc721_operators[_id] == msg.sender || mSuperOperators[msg.sender], \"Operator not approved\");\n        }\n        _transferFrom(_from, _to, _id, 1);\n        require(_checkERC1155AndCallSafeTransfer(msg.sender == address(_sandContract) ? _from : msg.sender, _from, _to, _id, 1, _data, true, true));\n    }\n    function name() external pure returns (string memory _name) {\n        return \"ASSET NFT\";\n    }\n    function symbol() external pure returns (string memory _symbol) {\n        return \"ASSET\";\n    }\n    function tokenURI(uint256 _id) public view returns (string memory) {\n        return string(erc721_metadataURIs[_id]);\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function supportsInterface(bytes4 id)\n    external\n    view\n    returns (bool) { // ERC1155       // ERC721           // ERC721 metadata\n        return id == 0xd9b67a26 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n    ///////////////////////////////////////// INTERNAL //////////////////////////////////////////////\n\n    function _checkERC1155AndCallSafeTransfer(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes memory _data,\n        bool erc721,\n        bool erc721Safe\n    )\n    internal\n    returns (bool)\n    {\n        if (!_to.isContract()) {\n            return true;\n        }\n        (bool success, bytes memory returnData) = _to.call(\n            abi.encodeWithSignature(\n                \"onERC1155Received(address,address,uint256,uint256,bytes)\",\n                _operator,\n                _from,\n                _id,\n                _value,\n                _data\n            )\n        );\n        bytes4 retval = 0x0;\n        if(returnData.length > 0) {\n            assembly {\n                retval := mload(add(returnData, 32))\n            }\n        }\n        if(retval == ERC1155_REJECTED) {\n            return false;\n        } else if(retval == ERC1155_RECEIVED) {\n            return true;\n        } else if(erc721) {\n            if(erc721Safe) {\n                return _checkERC721AndCallSafeTransfer(_operator, _from, _to, _id, _data);\n            } else {\n                return true;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    function _checkERC1155AndCallSafeBatchTransfer(\n        address _operator,\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes memory _data\n    )\n    internal\n    returns (bool)\n    {\n        if (!_to.isContract()) {\n            return true;\n        }\n        bytes4 retval = ERC1155TokenReceiver(_to).onERC1155BatchReceived(\n            _operator, _from, _ids, _values, _data);\n        return (retval == ERC1155_BATCH_RECEIVED);\n    }\n\n    function _checkERC721AndCallSafeTransfer(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _id,\n        bytes memory _data\n    )\n    internal\n    returns (bool)\n    {\n        if (!_to.isContract()) {\n            return true;\n        }\n        return (ERC721TokenReceiver(_to).onERC721Received(_operator, _from, _id, _data) == ERC721_RECEIVED);\n    }\n\n    ////////////////////////////// ERC721 EXTRACTION /////////////////////////////// \n\n    event Extraction(uint256 indexed _fromId, uint256 _toId, string _uri); \n    \n    function _burnERC1155(address _from, uint256 _id, uint256 _amount) internal {\n        (uint256 bin, uint256 index) = (_id & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFF).getTokenBinIndex();\n        packedTokenBalance[_from][bin] = packedTokenBalance[_from][bin].updateTokenBalance(index, _amount, ObjectLib32.Operations.SUB);\n        packedTokenBalance[address(0)][bin] = packedTokenBalance[address(0)][bin].updateTokenBalance(index, _amount, ObjectLib32.Operations.ADD);\n        emit TransferSingle(msg.sender == address(_sandContract) ? _from : msg.sender, _from, address(0), _id, _amount);\n    }\n\n    // TODO enable ?\n    function extractERC721(address _sender, uint256 _id, string calldata _uri) external {\n        require(msg.sender == _sender || msg.sender == address(_sandContract) || mSuperOperators[msg.sender], \"require meta approval\");\n        require(erc1155_metadataURIHashes[_id] != 0, \"Not an ERC1155 Token\");\n        require(erc1155_metadataURIHashes[_id] == keccak256(abi.encodePacked(_uri)), \"URI hash does not match\");\n        _burnERC1155(_sender, _id, 1);\n        address creator = creatorOf(_id);\n        uint256 newTokenId = uint256(creator) * 2**(256-160) + 0 * 2**(256-160-8) + nextSubId;\n        nextSubId++;\n        _mint(_uri, 1, creator, _sender, newTokenId, \"\");\n        emit Extraction(_id, newTokenId, _uri);\n    }\n}"

    },

    "src/Asset/Interfaces/MintingFeeCollector.sol": {

      "content": "pragma solidity 0.5.2;\n\ninterface MintingFeeCollector {\n    function multiple_minted(uint256[] calldata tokenIds, uint256 feePerToken) external;\n    function single_minted(uint256 tokenId, uint256 fee) external;\n}"

    },

    "src/Asset.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./Asset/ERC1155ERC721.sol\";\nimport \"./TheSandbox712.sol\";\nimport \"./Sand.sol\";\n\ncontract Asset is ProxyImplementation, TheSandbox712, ERC1155ERC721 { // TODO remove TheSandbox712 unless we need to add Approval extension or other that require signed message\n\n  constructor(Sand _sandContract, address _feeCollector, address _admin) public ERC1155ERC721(_sandContract, _feeCollector, _admin) {\n      initAsset(_sandContract, _feeCollector, _admin);\n  }\n\n  function initAsset(Sand _sandContract, address _feeCollector, address _admin) public phase('ASSET') {\n      init712();\n      initERC1155ERC721(_sandContract, _feeCollector, _admin);\n  }\n}\n"

    },

    "src/Auctions/AssetSignedAuction.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Libraries/SigUtil.sol\";\nimport \"../Libraries/PriceUtil.sol\";\nimport \"../Sand.sol\";\nimport \"../Asset.sol\";\nimport \"../Interfaces/ERC20.sol\";\nimport \"../TheSandbox712.sol\";\n\ncontract AssetSignedAuction is TheSandbox712{\n\n    bytes32 constant AUCTION_TYPEHASH = keccak256(\"Auction(address token,uint256 offerId,uint256 startingPrice,uint256 endingPrice,uint256 startedAt,uint256 duration,uint256 packs,bytes ids,bytes amounts)\");\n\n    // TODO: review event values\n    // TODO remove underscore\n    event OfferClaimed(\n        address indexed _seller, \n        address indexed _buyer, \n        address _token, \n        uint256 _buyAmount, \n        uint256[] _auctionData, \n        uint256[] ids, \n        uint256[] amounts, \n        bytes _signature // TODO remove and use offerId \n    ); \n    event OfferCancelled(address indexed _seller, uint256 _offerId); \n\n    uint256 constant MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    \n    // Stack too deep, grouping parameters\n    // AuctionData:   \n    uint256 constant AuctionData_OfferId = 0;\n    uint256 constant AuctionData_StartingPrice = 1;\n    uint256 constant AuctionData_EndingPrice = 2;\n    uint256 constant AuctionData_StartedAt = 3;\n    uint256 constant AuctionData_Duration = 4;\n    uint256 constant AuctionData_Packs = 5;\n\n    mapping (address => mapping (uint256 => uint256)) claimed;\n\n    Asset asset;\n    Sand sand;\n    constructor(Sand _sand, Asset _asset) public {\n        asset = _asset;\n        sand = _sand;\n        init712();\n    }\n\n    function claimSellerOffer(\n        address buyer, \n        address payable seller, \n        address token, \n        uint256 buyAmount, \n        uint256[] calldata auctionData, \n        uint256[] calldata ids, \n        uint256[] calldata amounts, \n        bytes calldata signature\n    ) external payable {\n        require(msg.sender == buyer || msg.sender == address(sand), \"invalid buyer\");\n\n        // TODO: do we remove seller from the argument list? and recover it ?\n        require(seller == recover(token, auctionData, ids, amounts, signature), \"Signature mismatches\");\n\n        require(claimed[seller][auctionData[AuctionData_OfferId]] != MAX_UINT256, \"Auction cancelled\");\n        require(SafeMath.add(claimed[seller][auctionData[AuctionData_OfferId]], buyAmount) <= auctionData[AuctionData_Packs], \"Buy amount exceeds sell amount\");\n\n        require(auctionData[AuctionData_StartedAt] <= block.timestamp, \"Auction didn't start yet\"); \n        require(auctionData[AuctionData_StartedAt] + auctionData[AuctionData_Duration] > block.timestamp, \"Auction finished\"); \n\n        _executeDeal(token, buyer, seller, auctionData, ids, amounts, buyAmount);\n        emit OfferClaimed(seller, buyer, token, buyAmount, auctionData, ids, amounts, signature);\n    }\n\n    function _executeDeal(\n        address token,\n        address buyer,\n        address payable seller,\n        uint256[] memory auctionData,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        uint256 buyAmount\n    ) internal {\n        uint256 offer = PriceUtil.calculateCurrentPrice(\n            auctionData[AuctionData_StartingPrice], \n            auctionData[AuctionData_EndingPrice], \n            auctionData[AuctionData_Duration], \n            block.timestamp - auctionData[AuctionData_StartedAt]\n        ) * buyAmount;\n        \n        claimed[seller][auctionData[AuctionData_OfferId]] += buyAmount;\n\n        if(token != address(0)) {\n            ERC20(token).transferFrom(buyer, seller, offer); // require approval/ for SAND we can add it to the list of defaultOperators / superOperators\n        } else {\n            require(buyer == msg.sender, \"for ETH based offers, the buyer need to be the sender\");\n            require(msg.value >= offer, \"not enough ETH\"); // in case the aucction could store ETH for other reasons\n            seller.transfer(offer);    \n            msg.sender.transfer(msg.value - offer);\n        }\n\n        uint256[] memory packAmounts = new uint[](amounts.length);\n        for(uint256 i = 0; i < packAmounts.length; i++){\n            packAmounts[i] = amounts[i] * buyAmount;\n        }\n        asset.safeBatchTransferFrom(seller, buyer, ids, packAmounts, '');\n    }\n\n    function cancelSellerOffer(uint256 offerId) external {\n        claimed[msg.sender][offerId] = MAX_UINT256;\n\n        emit OfferCancelled(msg.sender, offerId);\n    }\n\n    // Make public for testing\n    function recover(address token, uint256[] memory auctionData, uint256[] memory ids, uint256[] memory amounts, bytes memory signature) internal view returns (address) {\n        return SigUtil.recover(\n            // This recreates the message that was signed on the client.\n            keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator(), hashAuction(token, auctionData, ids, amounts))), \n            signature\n        );\n    }\n    \n    function hashAuction(address token, uint256[] memory auctionData, uint256[] memory ids, uint256[] memory amounts) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                AUCTION_TYPEHASH, \n                token, \n                auctionData[AuctionData_OfferId], \n                auctionData[AuctionData_StartingPrice], \n                auctionData[AuctionData_EndingPrice], \n                auctionData[AuctionData_StartedAt], \n                auctionData[AuctionData_Duration], \n                auctionData[AuctionData_Packs],\n                keccak256(abi.encodePacked(ids)), \n                keccak256(abi.encodePacked(amounts))\n            )\n        );\n    }\n}"

    },

    "src/Auctions/BuyerMinting.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Libraries/SigUtil.sol\";\nimport \"../Libraries/PriceUtil.sol\";\nimport \"../Sand.sol\";\nimport \"../Asset.sol\";\nimport \"../Interfaces/ERC20.sol\";\nimport \"../TheSandbox712.sol\";\n\ncontract BuyerMinting is TheSandbox712{\n\n    // bytes32 constant AUCTION_TYPEHASH = keccak256(\"MintAuction(address token,uint256 offerId,uint256 startingPrice,uint256 endingPrice,uint256 startedAt,uint256 duration,uint256 packs,string uris,bytes lengths,bytes _supplies)\");\n\n    // mapping (address => mapping (uint256 => uint256)) claimed;\n\n    // Asset asset;\n    // Sand sand;\n    // constructor(Sand _sand, Asset _asset) public {\n    //     asset = _asset;\n    //     sand = _sand;\n    //     init712();\n    // }\n\n    // function claimMintOffer(\n    //     address buyer, \n    //     address payable seller, \n    //     address token, \n    //     uint256 buyAmount, \n    //     uint256[] calldata auctionData, \n    //     string uris,\n    //     uint256[] lengths,\n    //     uint256[] indexes,\n    //     uint256[] amounts,\n    //     bytes calldata signature\n    // ) external payable {\n        \n    //     if(notMintedYet) {\n    //         ids = asset.mintMultipleWithNFT(creator, sandAmount, uris, lengths, supplies, numNFTs, creator); // TODO minting should return the i\n    //     } else {\n    //         // TODO ids need to passed to the call and uris need to be checked\n    //         // => this means 2 asset with same uri can't exist => problem with extraction\n    //     }\n    //     uint256[] memory packAmounts = new uint[](amounts.length);\n    //     for(uint256 i = 0; i < packAmounts.length; i++){\n    //         packAmounts[i] = amounts[i] * buyAmount;\n    //     }\n    //     asset.batchTransferFrom(seller, buyer, ids, packAmounts);\n    // }\n\n}"

    },

    "src/GenericMetaTransaction.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./Libraries/BytesUtil.sol\";\nimport \"./Libraries/AddressUtils.sol\";\nimport \"./Libraries/SigUtil.sol\";\nimport \"./Libraries/SafeMath.sol\";\nimport \"./Interfaces/ERC1271.sol\";\nimport \"./Interfaces/ERC20.sol\";\nimport \"./Interfaces/ERC1271Constants.sol\";\nimport \"./TheSandbox712.sol\";\n\ncontract GenericMetaTransaction is TheSandbox712, ERC1271Constants{\n    using SafeMath for uint256;\n    using AddressUtils for address;\n\n    bytes32 constant ERC20METATRANSACTION_TYPEHASH = keccak256(\"ERC20MetaTransaction(address from,address to,address gasToken,bytes data,uint256 nonce,uint256 gasPrice,uint256 txGas,uint256 gasLimit,uint256 tokenGasPrice,address relayer)\");\n    mapping(address => uint256) nonces;\n\n    uint256 constant BASE_GAS = 112000; // TODO calculate accurately\n    uint256 constant WORST_CASE_EPSILON = 10000; // TODO calculate accurately\n    uint256 constant INIT_GAS = 23000; // TODO calculate accurately\n\n    event MetaTx(bool success, bytes returnData); // TODO specify event as part of ERC-1776\n\n    constructor() public {\n        init712();\n    }\n\n    function ensureParametersValidity(\n        address _from,\n        address _gasToken,\n        uint256[4] memory params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer\n    ) internal view {\n        require(_relayer == address(0) || _relayer == msg.sender, \"wrong relayer\");\n        require(nonces[_from]+1 == params[0], \"nonce out of order\");\n        require(ERC20(_gasToken).balanceOf(_from) >= (params[2].add(BASE_GAS)).mul(params[3]), \"_from not enough balance\");\n        require(tx.gasprice == params[1], \"gasPrice != signer gasPrice\"); // need to provide same gasPrice as requested by signer // TODO consider allowing higher value\n    }\n\n    function encodeData(\n        bytes32 typeHash,\n        address _from,\n        address _to,\n        address _gasToken,\n        bytes memory _data,\n        uint256[4] memory params,\n        address _relayer\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            typeHash,\n            _from,\n            _to,\n            _gasToken,\n            keccak256(_data),\n            params[0],\n            params[1],\n            params[2],\n            BASE_GAS + params[2], // expect signing gasLimit = BASE_GAS + txGas\n            params[3],\n            _relayer\n        ));\n    }\n\n    function ensureCorrectSigner(\n        address _from,\n        address _to,\n        address _gasToken,\n        bytes memory _data,\n        uint256[4] memory params,\n        address _relayer,\n        bytes memory _sig,\n        bytes32 typeHash,\n        bool signedOnBehalf\n    ) internal view {\n        bytes memory data = abi.encodePacked(\n            \"\\x19\\x01\",\n            domainSeparator(),\n            encodeData(\n                typeHash,\n                _from,\n                _to,\n                _gasToken,\n                _data,\n                params,\n                _relayer\n            )\n        );\n        if(signedOnBehalf) {\n            require(ERC1271(_from).isValidSignature(data, _sig) == ERC1271_MAGICVALUE, \"invalid signature\");\n        } else {\n            address signer = SigUtil.recover(keccak256(data), _sig);\n            require(signer == _from, \"signer != _from\");\n        }\n    }\n\n    function sendERC20Tokens(address _from, address _to, ERC20 _tokenContract, uint256 _amount, bytes calldata _data) external {\n        require(msg.sender == address(this), \"can only be called by own\");\n        _tokenContract.transferFrom(_from, _to, _amount);\n        bool success = true;\n        bytes memory returnData;\n        if(_to.isContract() || _data.length > 0){\n            (success, returnData) = _to.call(abi.encodeWithSignature(\"erc20_tokensReceived(address,address,uint256,bytes)\", _from, _tokenContract, _amount, _data));\n        } \n        require(success);\n    }\n\n    // function sendERC777Tokens(address _from, address _to, ERC777 _tokenContract, uint256 _amount, bytes calldata _data) external {\n    //     require(msg.sender == address(this), \"can only be called by own\");\n    //     _tokenContract.operatorSend(_from, _to, _amount, _data);\n    // }\n\n    // TODO safe /unsafe version\n    // function sendERC1155Tokens(address _from, address _to, ERC1155 _tokenContract, uint256 _tokenType, uint256 _amount, bytes calldata _data) external {\n    //     require(msg.sender == address(this), \"can only be called by own\");\n    //     _tokenContract.transfer...(_from, _to, _amount, _data);\n    // }\n\n    // TODO safe /unsafe version\n    // function sendERC721Tokens(address _from, address _to, ERC721 _tokenContract, uint256 _tokenType, bytes calldata _data) external {\n    //     require(msg.sender == address(this), \"can only be called by own\");\n    //     _tokenContract.transferFrom(_from, _to, _amount, _data); \n    // }\n\n    function executeERC20MetaTx(\n        address _from,\n        address _to,  \n        address _gasToken,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        address _tokenReceiver,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        require(msg.sender != address(this), \"can only be called externaly\");\n        uint256 initialGas = gasleft();\n        ensureParametersValidity(_from, _gasToken, params, _relayer);\n        ensureCorrectSigner(_from, _to, _gasToken, _data, params, _relayer, _sig, ERC20METATRANSACTION_TYPEHASH, signedOnBehalf);\n        return performERC20MetaTx(_from, _to, _gasToken, _data, params, initialGas, _tokenReceiver);\n    }\n\n    function performERC20MetaTx(\n        address _from,\n        address _to,\n        address _gasToken,\n        bytes memory _data,\n        uint256[4] memory params,\n        uint256 initialGas,\n        address _tokenReceiver\n    ) internal returns(bool, bytes memory) {\n        nonces[_from] = params[0];\n\n        bool success;\n        bytes memory returnData;\n        \n        if(_to == address(this)) {\n            require(BytesUtil.doFirstParamEqualsAddress(_data, _from), \"first param != _from\");\n            uint256 gasAvailable = gasleft() - WORST_CASE_EPSILON;\n            require(gasAvailable - gasAvailable/64 > params[2], \"not enough gas\");\n            (success, returnData) = _to.call.gas(params[2])(_data);\n        } else {\n            // can't accept any call since this contract willmost likely be approved by ERC20 or ERC777 contract and if those have function that\n            // have such signature for example differentTransfer(uint256 amount, address from, ...) they would be vulnerable\n            //so instead we define a meta_transaction hook\n            uint256 gasAvailable = gasleft() - WORST_CASE_EPSILON;\n            require(gasAvailable - gasAvailable/64 > params[2], \"not enough gas\");\n            (success, returnData) = _to.call.gas(params[2])(abi.encodeWithSignature(\"meta_transaction_received(address,bytes)\", _from, _data));\n        }\n        \n        emit MetaTx(success, returnData);\n        \n        if(params[3] > 0) {\n            uint256 gasConsumed = (initialGas + INIT_GAS) - gasleft();\n            if(gasConsumed > BASE_GAS + params[2]) {\n                gasConsumed = BASE_GAS + params[2]; \n                // idealy we would like to charge only max(BASE_GAS, gas consumed outside the inner call) + gas consumed as part of the inner call\n            }\n            ERC20(_gasToken).transferFrom(_from, _tokenReceiver, gasConsumed * params[3]);\n        }\n        \n        return (success, returnData);\n    }\n\n    function meta_nonce(address _from) external view returns (uint256 nonce) {\n        return nonces[_from];\n    }\n}\n"

    },

    "src/Interfaces/ERC1155.sol": {

      "content": "pragma solidity 0.5.2;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0xf23a6e61.\ninterface ERC1155TokenReceiver {\n    /**\n        @notice Handle the receipt of a single ERC1155 token type.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\n        This function MAY throw to revert and reject the transfer.\n        Return of other than the magic value MUST result in the transaction being reverted.\n        Note: The contract address is always the message sender.\n        @param _operator  The address which called `safeTransferFrom` function\n        @param _from      The address which previously owned the token\n        @param _id        An array containing the ids of the token being transferred\n        @param _value     An array containing the amount of tokens being transferred\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    */\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\n    \n    /**\n        @notice Handle the receipt of multiple ERC1155 token types.\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\n        This function MAY throw to revert and reject the transfer.\n        Return of other than the magic value WILL result in the transaction being reverted.\n        Note: The contract address is always the message sender.\n        @param _operator  The address which called `safeTransferFrom` function\n        @param _from      The address which previously owned the token\n        @param _ids       An array containing ids of each token being transferred\n        @param _values    An array containing amounts of each token being transferred\n        @param _data      Additional data with no specified format\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    */\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n}\n\n/// @dev Note: The ERC-165 identifier for this interface is 0xd9b67a26.\ninterface ERC1155 {\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n    event URI(string _value, uint256 indexed _id);\n    event Name(string _value, uint256 indexed _id);\n\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n    function setApprovalForAll(address _operator, bool _approved) external;\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}"

    },

    "src/Interfaces/ERC1271.sol": {

      "content": "pragma solidity 0.5.2;\n\ncontract ERC1271 {\n    /**\n    * @dev Should return whether the signature provided is valid for the provided data\n    * @param _data Arbitrary length data signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _data\n    *\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n    * MUST allow external calls\n    */ \n    function isValidSignature(\n        bytes memory _data, \n        bytes memory _signature)\n        public\n        view \n        returns (bytes4 magicValue);\n}"

    },

    "src/Interfaces/ERC1271Constants.sol": {

      "content": "pragma solidity 0.5.2;\n\ncontract ERC1271Constants {\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\n}\n"

    },

    "src/Interfaces/ERC165.sol": {

      "content": "pragma solidity 0.5.2;\n\n\n/**\n * @title ERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface ERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   */\n  function supportsInterface(bytes4 _interfaceId) external view returns (bool);\n}\n"

    },

    "src/Interfaces/ERC20.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./ERC20Basic.sol\";\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\n/* interface */ contract ERC20 is ERC20Basic {\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  function allowance(address owner, address spender) public view returns (uint256);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n"

    },

    "src/Interfaces/ERC20Basic.sol": {

      "content": "pragma solidity 0.5.2;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\n/* interface */ contract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"

    },

    "src/Interfaces/ERC20Events.sol": {

      "content": "pragma solidity 0.5.2;\n\n/* interface */ contract ERC20Events {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"

    },

    "src/Interfaces/ERC20WithMetadata.sol": {

      "content": "/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.5.2;\n\nimport \"./ERC20.sol\";\n\n/* interface */ contract ERC20WithMetadata is ERC20 {\n    function name() public view returns (string memory);\n    function symbol() public view returns (string memory);\n    function decimals() public view returns (uint8);\n}\n"

    },

    "src/Interfaces/ERC721.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./ERC165.sol\";\nimport \"./ERC721Events.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\n/*interface*/ contract ERC721 is ERC165, ERC721Events {\n\n  function balanceOf(address _owner) external view returns (uint256 _balance);\n  function ownerOf(uint256 _tokenId) external view returns (address _owner);\n//   function exists(uint256 _tokenId) external view returns (bool _exists);\n\n  function approve(address _to, uint256 _tokenId) external;\n  function getApproved(uint256 _tokenId)\n    external view returns (address _operator);\n\n  function setApprovalForAll(address _operator, bool _approved) external;\n  function isApprovedForAll(address _owner, address _operator)\n    external view returns (bool);\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external;\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n    external;\n\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external;\n}\n"

    },

    "src/Interfaces/ERC721Events.sol": {

      "content": "pragma solidity 0.5.2;\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ninterface ERC721Events {\n  event Transfer(\n    address indexed _from,\n    address indexed _to,\n    uint256 indexed _tokenId\n  );\n  event Approval(\n    address indexed _owner,\n    address indexed _approved,\n    uint256 indexed _tokenId\n  );\n  event ApprovalForAll(\n    address indexed _owner,\n    address indexed _operator,\n    bool _approved\n  );\n}\n"

    },

    "src/Interfaces/ERC721TokenReceiver.sol": {

      "content": "/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.5.2;\n\n\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns(bytes4);\n}\n"

    },

    "src/Interfaces/ERC777Token.sol": {

      "content": "/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.5.2;\n\n\n/* interface */ contract ERC777Token {\n    function name() public view returns (string memory);\n    function symbol() public view returns (string memory);\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address owner) public view returns (uint256);\n    function granularity() public view returns (uint256);\n\n    function defaultOperators() public view returns (address[] memory);\n    function isOperatorFor(address operator, address tokenHolder) public view returns (bool);\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n\n    function send(address to, uint256 amount, bytes memory data) public;\n    function operatorSend(address from, address to, uint256 amount, bytes memory data, bytes memory operatorData) public;\n\n    // function burn(uint256 amount, bytes data) public;\n    // function operatorBurn(address from, uint256 amount, bytes data, bytes operatorData) public;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    ); // solhint-disable-next-line separate-by-one-line-in-contract\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"

    },

    "src/Interfaces/ERC777TokenEvents.sol": {

      "content": "pragma solidity 0.5.2;\n\n/* interface */ contract ERC777TokenEvents {\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    ); // solhint-disable-next-line separate-by-one-line-in-contract\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"

    },

    "src/Interfaces/ERC777TokensRecipient.sol": {

      "content": "/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.5.2;\n\n\n/* interface */ contract ERC777TokensRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public;\n}\n"

    },

    "src/Interfaces/ERC777TokensSender.sol": {

      "content": "/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.5.2;\n\n\n/* interface */ contract ERC777TokensSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) public;\n}\n"

    },

    "src/Land/erc721/ERC721BaseToken.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport { ERC721Events } from \"../../Interfaces/ERC721Events.sol\";\n\nimport \"../../Sand.sol\";\n\ncontract ERC721BaseToken is ERC721Events /*ERC721*/ {\n    \n    mapping(address => uint256) numNFTPerAddress;\n    mapping(uint256 => address) owners;\n    mapping(address => mapping(address => bool)) operatorsForAll;\n    mapping(uint256 => address) operators;\n    mapping (uint256 => string) public metadataURIs;\n    Sand sandContract;\n\n    constructor(Sand sand) public {\n        initERC721BaseToken(sand);\n    }\n\n    function initERC721BaseToken(Sand sand) public {\n        sandContract = sand;\n    }\n     \n    function _transferFrom(address _from, address _to, uint256 _id) internal {\n        require(_to != address(0), \"Invalid to address\");\n        if(_from != msg.sender && msg.sender != address(sandContract)) {\n            require(operatorsForAll[_from][msg.sender] || operators[_id] == msg.sender, \"Operator not approved\");\n        }\n\n        numNFTPerAddress[_from] --;\n        numNFTPerAddress[_to] ++;\n        owners[_id] = _to;\n        operators[_id] = address(0);\n        emit Transfer(_from, _to, _id);\n    }\n\n    function balanceOf(address _owner) external view returns (uint256 _balance) {\n        return numNFTPerAddress[_owner];\n    }\n    function ownerOf(uint256 _id) external view returns (address _owner){\n        return owners[_id];\n    }\n    \n    function approveFor(address _sender, address _operator, uint256 _id) external {\n        require(msg.sender == _sender || msg.sender == address(sandContract), \"only msg.sender or sandContract can act on behalf of sender\");\n        require(owners[_id] == _sender, \"only owner can change operator\");\n        operators[_id] = _operator;\n        emit Approval(_sender, _operator, _id);\n    }\n    function approve(address _operator, uint256 _id) external {\n        require(owners[_id] == msg.sender, \"only owner can change operator\");\n        operators[_id] = _operator;\n        emit Approval(msg.sender, _operator, _id);\n    }\n    function getApproved(uint256 _id) external view returns (address _operator){\n        return operators[_id];\n    }\n    function transferFrom(address _from, address _to, uint256 _id) external{\n        require(owners[_id] != address(0), \"not an NFT\");\n        require(owners[_id] == _from, \"only owner can change operator\");\n        _transferFrom(_from, _to, _id);\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////////////\n    function name() external pure returns (string memory _name) {\n        return \"SANDBOX LAND\";\n    }\n    function symbol() external pure returns (string memory _symbol) {\n        return \"SLD\"; // TODO define symbol\n    }\n    function tokenURI(uint256 _id) public view returns (string memory) {\n        return string(metadataURIs[_id]);\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function supportsInterface(bytes4 ) // TODO _interfaceId)\n    external\n    view\n    returns (bool) {\n        return true; // TODO\n    }\n\n    \n    // Operators /////////////////////////////////////////////////////////////////////////////////////\n\n    function setApprovalForAllFor(address _sender, address _operator, bool _approved) external {\n        require(msg.sender == _sender || msg.sender == address(sandContract), \"only msg.sender or _sandContract can act on behalf of sender\");\n        _setApprovalForAll(_sender, _operator, _approved);\n    }\n    function setApprovalForAll(address _operator, bool _approved) external {\n        _setApprovalForAll(msg.sender, _operator, _approved);\n    }\n    function _setApprovalForAll(address _sender, address _operator, bool _approved) internal {\n        operatorsForAll[_sender][_operator] = _approved;\n        emit ApprovalForAll(_sender, _operator, _approved);\n    }\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator) {\n        return operatorsForAll[_owner][_operator];\n    }\n}\n"

    },

    "src/Land.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./Land/erc721/ERC721BaseToken.sol\";\nimport \"./Sand.sol\";\n\ncontract Land is ProxyImplementation, ERC721BaseToken{\n    uint256 lastId;\n\n    constructor(Sand _sandContract) public ERC721BaseToken(_sandContract) {\n        lastId = 1;\n    }\n\n    // TODO : \n    function mint(address _to) public {\n        numNFTPerAddress[_to] ++;\n        owners[++lastId] = _to;\n        emit Transfer(address(0), _to, lastId);\n    }\n}\n"

    },

    "src/Libraries/AddressUtils.sol": {

      "content": "pragma solidity 0.5.2;\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary AddressUtils {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param addr address to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address addr) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(addr) }\n    return size > 0;\n  }\n\n}\n"

    },

    "src/Libraries/BytesUtil.sol": {

      "content": "pragma solidity 0.5.2;\n\nlibrary BytesUtil {\n    function memcpy(uint dest, uint src, uint len) internal pure {\n        // Copy word-length chunks while possible\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function toBytes(uint256 src, uint256 len) internal pure returns (bytes memory) {\n        bytes memory ret = new bytes(len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, src, len);\n        return ret;\n    }\n\n    function toBytes(address a) internal pure returns (bytes memory b){\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n    }\n\n    function toBytes(uint256 a) internal pure returns (bytes memory b){\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 32), a)\n            mstore(0x40, add(m, 64))\n            b := m\n        }\n    }\n\n    function doFirstParamEqualsAddress(bytes memory data, address _address) internal pure returns (bool){\n        if(data.length < (36 + 32)) {\n            return false;\n        }\n        uint256 value;\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(_address);\n    }\n\n    function doParamEqualsUInt256(bytes memory data, uint256 i, uint256 value) internal pure returns (bool) {\n        if(data.length < (36 + (i+1)*32)) {\n            return false;\n        }\n        uint256 offset = 36 + i*32;\n        uint256 valuePresent;\n        assembly {\n            valuePresent := mload(add(data, offset))\n        }\n        return valuePresent == value;\n    }\n\n    function overrideFirst32BytesWithAddress(bytes memory data, address _address) internal pure returns (bytes memory){\n        uint dest;\n        assembly {dest := add(data, 48)} // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n\n        bytes memory addressBytes = BytesUtil.toBytes(_address);\n        uint src;\n        assembly { src := add(addressBytes, 32) }\n    \n        memcpy(dest, src, 20);\n        return data;\n    }\n\n    function overrideFirstTwo32BytesWithAddressAndInt(bytes memory data, address _address, uint256 _value) internal pure returns (bytes memory){\n        uint dest;\n        uint src;\n        \n        assembly {dest := add(data, 48)} // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n        bytes memory bbytes = BytesUtil.toBytes(_address);\n        assembly { src := add(bbytes, 32) }\n        memcpy(dest, src, 20);\n\n        assembly {dest := add(data, 68)} // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\n        bbytes = BytesUtil.toBytes(_value);\n        assembly { src := add(bbytes, 32) }\n        memcpy(dest, src, 32);\n\n        return data;\n    }\n}\n"

    },

    "src/Libraries/ERC820Implementer.sol": {

      "content": "pragma solidity 0.5.2;\n\ncontract ERC820Registry {\n    function getManager(address addr) public view returns(address);\n    function setManager(address addr, address newManager) public;\n    function getInterfaceImplementer(address addr, bytes32 iHash) public view returns (address);\n    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\n}\n\ncontract ERC820Implementer {\n    ERC820Registry constant erc820Registry = ERC820Registry(0x820b586C8C28125366C998641B09DCbE7d4cBF06);\n\n    function setInterfaceImplementation(string memory ifaceLabel, address impl) internal {\n        bytes32 ifaceHash = keccak256(bytes(ifaceLabel));\n        erc820Registry.setInterfaceImplementer(address(this), ifaceHash, impl);\n    }\n\n    function interfaceAddr(address addr, string memory ifaceLabel) internal view returns(address) {\n        bytes32 ifaceHash = keccak256(bytes(ifaceLabel));\n        return erc820Registry.getInterfaceImplementer(addr, ifaceHash);\n    }\n\n    function delegateManagement(address newManager) internal {\n        erc820Registry.setManager(address(this), newManager);\n    }\n}\n"

    },

    "src/Libraries/lifecycle/Pausable.sol": {

      "content": "pragma solidity 0.5.2;\n\n\nimport \"../ownership/Ownable.sol\";\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n\n    /**\n    * @dev Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /**\n    * @dev Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n    * @dev called by the owner to pause, triggers stopped state\n    */\n    function pause() onlyOwner whenNotPaused public {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n    * @dev called by the owner to unpause, returns to normal state\n    */\n    function unpause() onlyOwner whenPaused public {\n        paused = false;\n        emit Unpause();\n    }\n}\n"

    },

    "src/Libraries/ObjectLib.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./SafeMath.sol\";\n\n\nlibrary ObjectLib {\n\n  using SafeMath for uint256;\n  enum Operations { ADD, SUB, REPLACE }\n  // Constants regarding bin or chunk sizes for balance packing\n  uint256 constant TYPES_BITS_SIZE   = 16;                     // Max size of each object\n  uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n\n\n  //\n  // Objects and Tokens Functions\n  //\n\n  /**\n  * @dev Return the bin number and index within that bin where ID is\n  * @param _tokenId Object type\n  * @return (Bin number, ID's index within that bin)\n  */\n  function getTokenBinIndex(uint256 _tokenId) internal pure returns (uint256 bin, uint256 index) {\n     bin = _tokenId * TYPES_BITS_SIZE / 256;\n     index = _tokenId % TYPES_PER_UINT256;\n     return (bin, index);\n  }\n\n\n  /**\n  * @dev update the balance of a type provided in _binBalances\n  * @param _binBalances Uint256 containing the balances of objects\n  * @param _index Index of the object in the provided bin\n  * @param _amount Value to update the type balance\n  * @param _operation Which operation to conduct :\n  *     Operations.REPLACE : Replace type balance with _amount\n  *     Operations.ADD     : ADD _amount to type balance\n  *     Operations.SUB     : Substract _amount from type balance\n  */\n  function updateTokenBalance(\n    uint256 _binBalances,\n    uint256 _index,\n    uint256 _amount,\n    Operations _operation) internal pure returns (uint256 newBinBalance)\n  {\n    uint256 objectBalance = 0;\n    if (_operation == Operations.ADD) {\n        objectBalance = getValueInBin(_binBalances, _index);\n        newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.add(_amount));\n    } else if (_operation == Operations.SUB) {\n        objectBalance = getValueInBin(_binBalances, _index);\n        newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.sub(_amount));\n    } else if (_operation == Operations.REPLACE) {\n        newBinBalance = writeValueInBin(_binBalances, _index, _amount);\n    } else {\n      revert(\"Invalid operation\"); // Bad operation\n    }\n\n    return newBinBalance;\n  }\n  /*\n  * @dev return value in _binValue at position _index\n  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n  * @param _index index at which to retrieve value\n  * @return Value at given _index in _bin\n  */\n  function getValueInBin(uint256 _binValue, uint256 _index) internal pure returns (uint256) {\n\n    // Mask to retrieve data for a given binData\n    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n    // Shift amount\n    uint256 rightShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n    return (_binValue >> rightShift) & mask;\n  }\n\n  /**\n  * @dev return the updated _binValue after writing _amount at _index\n  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n  * @param _index Index at which to retrieve value\n  * @param _amount Value to store at _index in _bin\n  * @return Value at given _index in _bin\n  */\n  function writeValueInBin(uint256 _binValue, uint256 _index, uint256 _amount) internal pure returns (uint256) {\n    require(_amount < 2**TYPES_BITS_SIZE, \"Amount to write in bin is too large\");\n\n    // Mask to retrieve data for a given binData\n    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n    // Shift amount\n    uint256 leftShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n    return (_binValue & ~(mask << leftShift) ) | (_amount << leftShift);\n  }\n\n}\n"

    },

    "src/Libraries/ObjectLib32.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./SafeMath.sol\";\n\n\nlibrary ObjectLib32 {\n\n  using SafeMath for uint256;\n  enum Operations { ADD, SUB, REPLACE }\n  // Constants regarding bin or chunk sizes for balance packing\n  uint256 constant TYPES_BITS_SIZE   = 32;                     // Max size of each object\n  uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n\n\n  //\n  // Objects and Tokens Functions\n  //\n\n  /**\n  * @dev Return the bin number and index within that bin where ID is\n  * @param _tokenId Object type\n  * @return (Bin number, ID's index within that bin)\n  */\n  function getTokenBinIndex(uint256 _tokenId) internal pure returns (uint256 bin, uint256 index) {\n     bin = _tokenId * TYPES_BITS_SIZE / 256;\n     index = _tokenId % TYPES_PER_UINT256;\n     return (bin, index);\n  }\n\n\n  /**\n  * @dev update the balance of a type provided in _binBalances\n  * @param _binBalances Uint256 containing the balances of objects\n  * @param _index Index of the object in the provided bin\n  * @param _amount Value to update the type balance\n  * @param _operation Which operation to conduct :\n  *     Operations.REPLACE : Replace type balance with _amount\n  *     Operations.ADD     : ADD _amount to type balance\n  *     Operations.SUB     : Substract _amount from type balance\n  */\n  function updateTokenBalance(\n    uint256 _binBalances,\n    uint256 _index,\n    uint256 _amount,\n    Operations _operation) internal pure returns (uint256 newBinBalance)\n  {\n    uint256 objectBalance = 0;\n    if (_operation == Operations.ADD) {\n        objectBalance = getValueInBin(_binBalances, _index);\n        newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.add(_amount));\n    } else if (_operation == Operations.SUB) {\n        objectBalance = getValueInBin(_binBalances, _index);\n        newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.sub(_amount));\n    } else if (_operation == Operations.REPLACE) {\n        newBinBalance = writeValueInBin(_binBalances, _index, _amount);\n    } else {\n      revert(\"Invalid operation\"); // Bad operation\n    }\n\n    return newBinBalance;\n  }\n  /*\n  * @dev return value in _binValue at position _index\n  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n  * @param _index index at which to retrieve value\n  * @return Value at given _index in _bin\n  */\n  function getValueInBin(uint256 _binValue, uint256 _index) internal pure returns (uint256) {\n\n    // Mask to retrieve data for a given binData\n    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n    // Shift amount\n    uint256 rightShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n    return (_binValue >> rightShift) & mask;\n  }\n\n  /**\n  * @dev return the updated _binValue after writing _amount at _index\n  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n  * @param _index Index at which to retrieve value\n  * @param _amount Value to store at _index in _bin\n  * @return Value at given _index in _bin\n  */\n  function writeValueInBin(uint256 _binValue, uint256 _index, uint256 _amount) internal pure returns (uint256) {\n    require(_amount < 2**TYPES_BITS_SIZE, \"Amount to write in bin is too large\");\n\n    // Mask to retrieve data for a given binData\n    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n    // Shift amount\n    uint256 leftShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n    return (_binValue & ~(mask << leftShift) ) | (_amount << leftShift);\n  }\n\n}\n"

    },

    "src/Libraries/ownership/Ownable.sol": {

      "content": "pragma solidity 0.5.2;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address payable public owner;\n\n    event OwnershipTransferred(\n      address indexed previousOwner,\n      address indexed newOwner\n    );\n\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    // /**\n    // * @dev Allows the current owner to relinquish control of the contract.\n    // * @notice Renouncing to ownership will leave the contract without an owner.\n    // * It will not be possible to call the functions with the `onlyOwner`\n    // * modifier anymore.\n    // */\n    // function renounceOwnership() public onlyOwner {\n    //     emit OwnershipRenounced(owner);\n    //     owner = address(0);\n    // }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address payable _newOwner) public onlyOwner {\n        _transferOwnership(_newOwner);\n    }\n\n    /**\n    * @dev Transfers control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function _transferOwnership(address payable _newOwner) internal {\n        require(_newOwner != address(0));\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n"

    },

    "src/Libraries/PriceUtil.sol": {

      "content": "pragma solidity 0.5.2;\n\nlibrary PriceUtil {\n    \n    function calculateCurrentPrice(uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 secondsPassed) \n        internal \n        pure\n        returns (uint256)\n    {\n        if(secondsPassed > duration) {\n            return endingPrice;\n        }\n        int256 totalPriceChange = int256(endingPrice) - int256(startingPrice);\n        int256 currentPriceChange = totalPriceChange * int256(secondsPassed) / int256(duration);\n\n        return uint256(int256(startingPrice) + currentPriceChange);\n    }\n\n    function calculateTax(uint256 _price, uint256 _tax)\n        internal\n        pure\n        returns (uint256)\n    {\n        // _tax < 10000, so the result will be <= price\n        return _price * _tax / 10000;\n    }\n\n}"

    },

    "src/Libraries/ProxyImplementation.sol": {

      "content": "pragma solidity 0.5.2;\n\n// works when no arguments required\n// contract BaseImplementation {\n//     constructor() public {\n//         init();\n//     }\n\n//   function init() public {}\n// }\n\n// contract ProxyImplementation is BaseImplementation {\n\n//   // allow sub class to initialse their specific phase:\n//     mapping (string => bool) initialised;\n//     modifier phase(string memory _phase) {\n//         if(!initialised[_phase]) {\n//             super.init();\n//             initialised[_phase] = true;\n//             _;\n//         }\n//     }\n// }\n\ncontract ProxyImplementation {\n    mapping (string => bool) initialised;\n    \n    modifier phase(string memory _phase) {\n        if(!initialised[_phase]) {\n            initialised[_phase] = true;\n            _;\n        }\n    }\n}\n"

    },

    "src/Libraries/SafeMath.sol": {

      "content": "pragma solidity 0.5.2;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}"

    },

    "src/Libraries/SigUtil.sol": {

      "content": "pragma solidity 0.5.2;\n\nlibrary SigUtil{\n    function recover(bytes32 hash, bytes memory sig) internal pure returns (address recovered) {\n        require(sig.length == 65);\n        \n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        \n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n        require(v == 27 || v == 28);\n\n        recovered = ecrecover(hash, v, r, s);\n        require(recovered != address(0));\n    }\n\n    function recoverWithZeroOnFailure(bytes32 hash, bytes memory sig) internal pure returns (address) {\n        if (sig.length != 65) {\n            return (address(0));\n        }\n        \n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        \n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n        \n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes memory) {\n        return abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash);\n    }\n}"

    },

    "src/MetaProxy/MetaProxy.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Sand/Sand20.sol\";\nimport \"../Sand/Sand777.sol\";\n\ncontract MetaProxy {\n\n    address payable owner;\n    address payable executor;\n    address sandContract;\n    uint256 recharge; \n\n    uint256 alertThreshold;\n\n    event RechargeAlert(uint256 balance);\n\n    constructor(address payable _owner, address _sandContract, address payable _executor, uint256 _recharge, uint256 _alertThreshold) public {\n        owner = _owner;\n        sandContract = _sandContract;\n        executor = _executor;\n        recharge = _recharge;\n        alertThreshold = _alertThreshold;\n    }\n\n    function processRecharge(address payable _executor) internal {\n        require(_executor == executor, \"only executor is able to execute\");\n        if(_executor.balance < recharge) {\n            if(recharge - _executor.balance < address(this).balance) {\n                _executor.transfer(recharge - _executor.balance);\n            } else {\n                _executor.transfer(address(this).balance);\n            }\n            if(address(this).balance <= alertThreshold) {\n                emit RechargeAlert(address(this).balance);\n            }\n        }\n    }\n\n    function executeERC20MetaTx(\n        address _from,\n        address _to, \n        uint256 _amount,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _gasLimit, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        processRecharge(tx.origin);\n        return Sand20(sandContract).executeERC20MetaTx(_from, _to, _amount, _data, params, _relayer, _sig, address(this), signedOnBehalf);\n    }\n\n    function executeERC20MetaTxViaBasicSignature(\n        address _from,\n        address _to, \n        uint256 _amount,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _gasLimit, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        processRecharge(tx.origin);\n        return Sand20(sandContract).executeERC20MetaTxViaBasicSignature(_from, _to, _amount, _data, params, _relayer, _sig, address(this), signedOnBehalf);\n    }\n\n    function executeERC777MetaTx(\n        address _from,\n        address _to, \n        uint256 _amount,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _gasLimit, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        processRecharge(tx.origin);\n        return Sand777(sandContract).executeERC777MetaTx(_from, _to, _amount, _data, params, _relayer, _sig, address(this), signedOnBehalf);\n    }\n\n    function executeERC777MetaTxViaBasicSignature(\n        address _from,\n        address _to, \n        uint256 _amount,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _gasLimit, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        processRecharge(tx.origin);\n        return Sand777(sandContract).executeERC777MetaTxViaBasicSignature(_from, _to, _amount, _data, params, _relayer, _sig, address(this), signedOnBehalf);\n    }\n\n    function() external payable {}\n\n    function changeAlertThreshold(uint256 _newAlertThreshold) external {\n        require(msg.sender == owner, \"only owner able to change the alert threshold\");\n        alertThreshold = _newAlertThreshold;\n    }\n    function changeRecharge(uint256 _newRecharge) external {\n        require(msg.sender == owner, \"only owner able to change recharge\");\n        recharge = _newRecharge;\n    }\n    function changeOwner(address payable _newOwner) external {\n        require(msg.sender == owner, \"only owner able to change owner\");\n        owner = _newOwner;\n    }\n    function changeExecutor(address payable _newExecutor) external {\n        require(msg.sender == owner, \"only owner able to change executor\");\n        executor = _newExecutor;\n    }\n    function withdrawETH() external {\n        require(msg.sender == owner, \"only owner able to withdraw ETH\");\n        owner.transfer(address(this).balance);\n    }\n    function withdrawETH(uint256 keep) external {\n        require(msg.sender == owner, \"only owner able to withdraw ETH\");\n        if(keep < address(this).balance) {\n            owner.transfer(address(this).balance - keep);\n        }\n    }\n    function withdrawSand(uint256 keep) public {\n        require(msg.sender == owner, \"only owner able to withdrawn Sand\");\n        uint256 currentBalance = Sand20(sandContract).balanceOf(address(this));\n        if(keep < currentBalance) {\n            Sand20(sandContract).transfer(owner, currentBalance - keep);\n        }\n    }\n    function withdrawSand() external {\n        withdrawSand(1); // keep 1 Sand to keep the execute gas cost to not increase by having balance increase from zero\n    }\n}\n"

    },

    "src/Sand/erc20/ERC20ApproveExtension.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../../Libraries/BytesUtil.sol\";\nimport \"../../Libraries/SigUtil.sol\";\nimport \"../../Interfaces/ERC1271.sol\";\nimport \"../../Interfaces/ERC1271Constants.sol\";\n\ncontract ERC20ApproveExtension is ERC1271Constants{\n\n    mapping(address => mapping (uint256 => bool)) usedApprovalMessages;\n\n    function approveAndCall(address _target, uint256 _amount, bytes memory _data) public payable returns (bytes memory) {\n        _approveFor(msg.sender, _target, _amount);\n        \n        // ensure the first argument is equal to msg.sender\n        // allowing function being called checking the actual sender (that approved the allowance)\n        // this means target should not allow call from that contract if not expecting such behavior\n        // user should be carefull as usual to not approve any contract without knowing what they'll do\n        require(BytesUtil.doFirstParamEqualsAddress(_data, msg.sender), \"first param != sender\");\n        \n        (bool success, bytes memory returnData) = _target.call.value(msg.value)(_data);\n        require(success, \"the call failed\");\n        return returnData;\n    }\n\n    function approveUnlimitedAndCall(address _target, bytes calldata _data) external payable returns (bytes memory) {\n        return approveAndCall(_target, 2**256-1, _data); // assume https://github.com/ethereum/EIPs/issues/717\n    }\n\n    function approveViaBasicSignature(address _from, uint256 _messageId, address _target, uint256 _amount, bytes calldata _signature, bool signedOnBehalf) external returns (bool approved) {\n        require(!usedApprovalMessages[_from][_messageId], \"message already used or revoked\");\n        bytes memory data = SigUtil.prefixed(keccak256(abi.encodePacked(address(this), APPROVE_TYPEHASH, _from, _messageId, _target,_amount)));\n        if(signedOnBehalf) {\n            require(ERC1271(_from).isValidSignature(data, _signature) == ERC1271_MAGICVALUE, \"invalid signature\");\n        } else {\n            address signer = SigUtil.recover(keccak256(data), _signature);\n            require(signer == _from, \"signer != _from\");\n        }\n        usedApprovalMessages[_from][_messageId] = true;\n        _approveFor(_from, _target, _amount);\n        return true;\n    }\n\n    bytes32 constant APPROVE_TYPEHASH = keccak256(\"Approve(address from,uint256 messageId,address target,uint256 amount)\");\n    function approveViaSignature(address _from, uint256 _messageId, address _target, uint256 _amount, bytes calldata _signature, bool signedOnBehalf) external returns (bool approved) {\n        require(!usedApprovalMessages[_from][_messageId], \"message already used or revoked\");\n        bytes memory data = abi.encodePacked(\n            \"\\x19\\x01\",\n            domainSeparator(),\n            keccak256(abi.encode(\n                APPROVE_TYPEHASH,\n                _from,\n                _messageId,\n                _target,\n                _amount\n            ))\n        );\n        \n        if(signedOnBehalf) {\n            require(ERC1271(_from).isValidSignature(data, _signature) == ERC1271_MAGICVALUE, \"invalid signature\");\n        } else {\n            address signer = SigUtil.recover(keccak256(data), _signature);\n            require(signer == _from, \"signer != _from\");\n        }\n        usedApprovalMessages[_from][_messageId] = true;\n        _approveFor(_from, _target, _amount);\n        return true;\n    }\n\n    function revokeApprovalMessage(uint256 _messageId) external {\n        usedApprovalMessages[msg.sender][_messageId] = true;\n    }\n\n    function isApprovalMessageUsed(address account, uint256 _messageId) external view returns(bool revoked) {\n        return usedApprovalMessages[account][_messageId];\n    }\n\n    function _approveFor(address _owner, address _target, uint256 _amount) internal;\n    \n    function domainSeparator() internal view returns(bytes32);\n}"

    },

    "src/Sand/erc20/ERC20BaseToken.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport { ERC20 } from \"../../Interfaces/ERC20.sol\";\nimport { ERC20Events } from \"../../Interfaces/ERC20Events.sol\";\nimport \"../../Libraries/SafeMath.sol\";\n\ncontract ERC20BaseToken is ERC20Events /*is ERC20*/ {\n    using SafeMath for uint256;\n    \n    ////////////////// Super Operators ///////////////////////////////////////////////////////\n    // Allowing extension without redeploy\n    mapping(address => bool) internal mSuperOperators;\n    address public admin;\n    event AdminChanged(address oldAdmin, address newAdmin);\n    function changeAdmin(address _admin) external {\n        require(msg.sender == admin, \"only admin can change admin\");\n        emit AdminChanged(admin, _admin);\n        admin = _admin;\n    }\n    event SuperOperator(address superOperator, bool enabled);\n    function setSuperOperator(address _superOperator, bool _enabled) external {\n        require(msg.sender == admin, \"only admin is allowed to add super operators\");\n        mSuperOperators[_superOperator] = _enabled; \n        emit SuperOperator(_superOperator, _enabled);\n    }\n    function isSuperOperator(address who) public view returns(bool) {\n        return mSuperOperators[who];\n    }\n    /////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    uint256 internal mTotalSupply;\n    mapping(address => uint256) internal mBalances;\n    mapping(address => mapping(address => uint256)) internal mAllowed;\n\n    function totalSupply() public view returns (uint256) {\n        return mTotalSupply;\n    }\n\n    function balanceOf(address who) public view returns (uint256) {\n        return mBalances[who];\n    }\n\n    function decimals() public view returns (uint8) { return uint8(18); }\n\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        _transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        if(msg.sender != _from && !mSuperOperators[msg.sender]) {\n            uint256 allowance = mAllowed[_from][msg.sender];\n            if(allowance != (2**256)-1) { // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(allowance >= _amount, \"Not enough funds allowed\");\n                mAllowed[_from][msg.sender] = allowance.sub(_amount);\n            }\n        }\n        _transfer(_from, _to, _amount);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        _approveFor(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function approveFor(address from, address _spender, uint256 _amount) public returns (bool success) {\n        require(msg.sender == from || mSuperOperators[msg.sender], \"msg.sender != from || superOperator\");\n        _approveFor(from, _spender, _amount);\n        return true;\n    }\n\n    function _approveFor(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0) && _spender != address(0), \"Cannot approve with 0x0\");\n        mAllowed[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _approveForWithoutEvent(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0) && _spender != address(0), \"Cannot approve with 0x0\");\n        mAllowed[_owner][_spender] = _amount;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return mAllowed[_owner][_spender];\n    }\n\n    function _transfer(address _from, address _to, uint256 _amount) internal {\n        _transferBalance(_from, _to, _amount);\n        _emitTransferEvent(_from, _to, _amount);\n    }\n\n    function _transferBalance(address _from, address _to, uint256 _amount) internal {\n        require(_to != address(0), \"Cannot send to 0x0\");\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n    }\n\n    function _emitTransferEvent(address _from, address _to, uint256 _amount) internal {\n        emit Transfer(_from, _to, _amount);\n    }\n\n    // extra functionalities //////////////////////////////////////////////////////////////////////////////\n\n    function _mint(address _to, uint256 _amount) internal {\n        require(_to != address(0), \"Cannot mint to 0x0\");\n        mTotalSupply = mTotalSupply.add(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    function _burn(address _from, uint256 _amount) internal {\n        if(msg.sender != _from && !mSuperOperators[msg.sender]) {\n            require(mAllowed[_from][msg.sender] >= _amount, \"Not enough funds allowed\");\n            if(mAllowed[_from][msg.sender] != (2**256)-1) { // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                mAllowed[_from][msg.sender] = mAllowed[_from][msg.sender].sub(_amount);\n            }\n        }\n        \n        require(mBalances[_from] >= _amount, \"Not enough funds\");\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n        emit Transfer(_from, address(0), _amount);\n    }\n}\n"

    },

    "src/Sand/erc20/ERC20EscrowLessSellingExtension.sol": {

      "content": "pragma solidity 0.5.2;\n\ncontract ERC20EscrowLessSellingExtension {\n\n    mapping(address => mapping (uint256 => uint256)) sandClaimed;\n\n    function claimSellerOffer(\n        address _buyer,\n        uint256 _offerId,\n        address payable _seller, \n        address _tokenContract, \n        uint256 _buyAmount, \n        bytes calldata _signature\n    ) external payable {\n        require(msg.sender == _buyer || msg.sender == address(_tokenContract), \"invalid buyer\"); //this assume tokenContract is safe\n\n        require(sandClaimed[_seller][_offerId] >= _buyAmount, \"not enough sand left\");\n        // require(seller == recover(token, auctionData, ids, amounts, signature), \"Signature mismatches\");\n        // TODO ...\n    }\n}"

    },

    "src/Sand/erc20/ERC20MerkleDropExtension.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport { ProxyImplementation } from \"../../Libraries/ProxyImplementation.sol\";\n\n// from https://github.com/ricmoo/ethers-airdrop/blob/master/AirDropToken.sol\n// https://blog.ricmoo.com/merkle-air-drops-e6406945584d\ncontract ERC20MerkleDropExtension is ProxyImplementation {\n\n    bytes32 rootHash;\n    mapping (uint256 => uint256) redeemed;\n\n    function initMerkleDrop(bytes32 _rootHash)  public phase(\"merkleDrop\") {\n        rootHash = _rootHash;\n    }\n\n    function isRedeemed(uint256 _index) public view returns (bool _redeemed) {\n        uint256 redeemedBlock = redeemed[_index / 256];\n        uint256 redeemedMask = (uint256(1) << uint256(_index % 256));\n        return ((redeemedBlock & redeemedMask) != 0);\n    }\n\n    function redeemPackage(uint256 _index, address _recipient, uint256 _amount, bytes32[] calldata _merkleProof) external {\n\n        // Make sure this package has not already been claimed (and claim it)\n        uint256 redeemedBlock = redeemed[_index / 256];\n        uint256 redeemedMask = (uint256(1) << uint256(_index % 256));\n        require((redeemedBlock & redeemedMask) == 0);\n        redeemed[_index / 256] = redeemedBlock | redeemedMask;\n\n        // Compute the merkle root\n        bytes32 node = keccak256(abi.encodePacked(_index, _recipient, _amount));\n        uint256 path = _index;\n        for (uint16 i = 0; i < _merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(abi.encodePacked(_merkleProof[i], node));\n            } else {\n                node = keccak256(abi.encodePacked(node, _merkleProof[i]));\n            }\n            path /= 2;\n        }\n\n        // Check the merkle proof\n        require(node == rootHash);\n\n        // Redeem!\n       _mint(_recipient, _amount); // this increase the totalSupply \n    }\n\n    function _mint(address _to, uint256 _amount) internal;\n}\n"

    },

    "src/Sand/erc20/ERC20MetaTxExtension.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../../Libraries/BytesUtil.sol\";\nimport \"../../Libraries/SigUtil.sol\";\nimport \"../../Libraries/SafeMath.sol\";\nimport \"../../Interfaces/ERC1271.sol\";\nimport \"../../Interfaces/ERC1271Constants.sol\";\n\ncontract ERC20MetaTxExtension is ERC1271Constants{\n    using SafeMath for uint256;\n\n    bytes32 constant ERC20METATRANSACTION_TYPEHASH = keccak256(\"ERC20MetaTransaction(address from,address to,uint256 amount,bytes data,uint256 nonce,uint256 gasPrice,uint256 txGas,uint256 gasLimit,uint256 tokenGasPrice,address relayer)\");\n    mapping(address => uint256) nonces;\n\n    uint256 constant GAS_LIMIT_OFFSET = 112000;\n    uint256 constant MIN_GAS = 23000 + 17500; // ~ 13000 (transfer with non-zero receiver balance) + ~ 4500 (Sent event)\n\n    event MetaTx(address indexed from, uint256 indexed nonce, bool success, bytes returnData);\n\n    function ensureParametersValidity(\n        address _from,\n        uint256 _amount,\n        uint256[4] memory params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer,\n        uint256 initialGas\n    ) internal view {\n        require(_relayer == address(0) || _relayer == msg.sender, \"wrong relayer\");\n        require(nonces[_from]+1 == params[0], \"nonce out of order\");\n        require(balanceOf(_from) >= _amount.add((params[2].add(GAS_LIMIT_OFFSET)).mul(params[3])), \"_from not enough balance\");\n        require(tx.gasprice >= params[1], \"gasPrice < signer gasPrice\"); // need to provide at least as much gasPrice as requested by signer\n    }\n\n    function ensureCorrectSigner(\n        address _from,\n        address _to,  \n        uint256 _amount,\n        bytes memory _data,\n        uint256[4] memory params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer,\n        bytes memory _sig,\n        bytes32 typeHash,\n        bool signedOnBehalf\n    ) internal view {\n        bytes memory data = abi.encodePacked(\n            \"\\x19\\x01\",\n            domainSeparator(),\n            keccak256(abi.encode(\n                typeHash,\n                _from,\n                _to,\n                _amount,\n                keccak256(_data),\n                params[0],\n                params[1],\n                params[2],\n                GAS_LIMIT_OFFSET.add(params[2]), // expect signing gasLimit = txGas + GAS_LIMIT_OFFSET\n                params[3],\n                _relayer\n            ))\n        );\n        if(signedOnBehalf) {\n            require(ERC1271(_from).isValidSignature(data, _sig) == ERC1271_MAGICVALUE, \"invalid signature\");\n        } else {\n            address signer = SigUtil.recover(keccak256(data), _sig);\n            require(signer == _from, \"signer != _from\");\n        }\n    }\n\n    function encodeBasicSignatureData(\n        bytes32 typeHash,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256[4] memory params,\n        address _relayer\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            address(this),\n            typeHash, \n             _from,\n            _to,\n            _amount,\n            keccak256(_data),\n            params[0],\n            params[1],\n            params[2],\n            GAS_LIMIT_OFFSET.add(params[2]), // expect signing gasLimit = txGas + GAS_LIMIT_OFFSET\n            params[3],\n            _relayer\n        ));\n    }\n\n    function ensureCorrectSignerViaBasicSignature(\n        address _from,\n        address _to,  \n        uint256 _amount,\n        bytes memory _data,\n        uint256[4] memory params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer,\n        bytes memory _sig,\n        bytes32 typeHash,\n        bool signedOnBehalf\n    ) internal view {\n        bytes memory data = SigUtil.prefixed(encodeBasicSignatureData(typeHash, _from, _to, _amount, _data, params, _relayer));\n        if(signedOnBehalf) {\n            require(ERC1271(_from).isValidSignature(data, _sig) == ERC1271_MAGICVALUE, \"invalid signature\");\n        } else {\n            address signer = SigUtil.recover(keccak256(data), _sig);\n            require(signer == _from, \"signer != _from\");\n        }\n    }\n\n    function executeERC20MetaTx(\n        address _from,\n        address _to,  \n        uint256 _amount,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        address _tokenReceiver,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        uint256 initialGas = gasleft();\n        ensureParametersValidity(_from, _amount, params, _relayer, initialGas);\n        ensureCorrectSigner(_from, _to, _amount, _data, params, _relayer, _sig, ERC20METATRANSACTION_TYPEHASH, signedOnBehalf);\n        return performERC20MetaTx(_from, _to, _amount, _data, params, initialGas, _tokenReceiver);\n    }\n\n    function executeERC20MetaTxViaBasicSignature(\n        address _from,\n        address _to,  \n        uint256 _amount,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        address _tokenReceiver,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        uint256 initialGas = gasleft();\n        ensureParametersValidity(_from, _amount, params, _relayer, initialGas);\n        ensureCorrectSignerViaBasicSignature(_from, _to, _amount, _data, params, _relayer, _sig, ERC20METATRANSACTION_TYPEHASH, signedOnBehalf);\n        return performERC20MetaTx(_from, _to, _amount, _data, params, initialGas, _tokenReceiver);\n    }\n\n    function performERC20MetaTx(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256[4] memory params,\n        uint256 initialGas,\n        address _tokenReceiver\n    ) internal returns(bool, bytes memory) {\n        nonces[_from] = params[0];\n\n        bool success;\n        bytes memory returnData;\n        if(_data.length == 0){\n            _transfer(_from, _to, _amount);\n            success = true;\n        } else {\n            require(BytesUtil.doFirstParamEqualsAddress(_data, _from), \"first param != _from\");\n            bool allowanceChanged = false;\n            uint256 before = 0;\n            if(_amount > 0 && !isSuperOperator(_to)){\n                before = allowance(_from, _to);\n                if(before != 2**256-1) {\n                    allowanceChanged = true;\n                    _approveForWithoutEvent(_from, _to, _amount);\n                }   \n            }\n            (success, returnData) = _to.call.gas(params[2])(_data);\n            require(gasleft() >= params[2].div(63), \"not enough gas left\");\n            \n            if(allowanceChanged) {\n                _approveForWithoutEvent(_from, _to, before);\n            }\n        }\n\n        emit MetaTx(_from, params[0], success, returnData);\n        \n        if(params[3] > 0) {\n            uint256 gasConsumed = (initialGas.add(MIN_GAS)).sub(gasleft());\n            uint256 maxGasCharge = GAS_LIMIT_OFFSET.add(params[2]);\n            if(gasConsumed > maxGasCharge) {\n                gasConsumed = maxGasCharge; \n                // idealy we would like to charge only max(GAS_LIMIT_OFFSET, gas consumed outside the inner call) + gas consumed as part of the inner call\n            }\n            _transfer(_from, _tokenReceiver, gasConsumed.mul(params[3]));\n        }\n        \n        return (success, returnData);\n    }\n\n    function meta_nonce(address _from) external view returns (uint256 nonce) {\n        return nonces[_from];\n    }\n\n    function isSuperOperator(address who) public view returns(bool);\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n    function domainSeparator() internal view returns(bytes32);\n    function balanceOf(address who) public view returns (uint256);\n    function _approveForWithoutEvent(address _owner, address _target, uint256 _amount) internal;\n    function _transfer(address _from, address _to, uint256 _amount) internal;\n}\n"

    },

    "src/Sand/erc777/ERC20BaseTokenWithERC777Events.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport { ERC777TokenEvents } from \"../../Interfaces/ERC777TokenEvents.sol\";\nimport { ERC20BaseToken } from \"../erc20/ERC20BaseToken.sol\";\n\n/*\nAllow ERC20 to be later upgraded to an ERC777\n\nSince to be a valid ERC777 token, events of that standard need to be emitted for every balance transfer that ever happened \nwe need to trigger them as part of ERC20\n*/\ncontract ERC20BaseTokenWithERC777Events is ERC20BaseToken, ERC777TokenEvents {\n\n    function _transfer(address _from, address _to, uint256 _amount) internal {\n        super._transfer(_from, _to, _amount);\n        emit Sent(msg.sender, _from, _to, _amount, '', '');\n    }\n\n    function _mint(address _to, uint256 _amount) internal {\n        super._mint(_to, _amount);\n        emit Minted(msg.sender, _to, _amount, '');\n    }\n\n    function _burn(address _from, uint256 _amount) internal {\n        super._burn(_from, _amount);\n        emit Burned(msg.sender, _from, _amount, '', '');\n    }\n}\n"

    },

    "src/Sand/erc777/ERC777BaseToken.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport { ERC820Implementer } from \"../../Libraries/ERC820Implementer.sol\";\nimport { ERC777Token } from \"../../Interfaces/ERC777Token.sol\";\nimport { ERC777TokenEvents } from \"../../Interfaces/ERC777TokenEvents.sol\";\nimport { ERC777TokensSender } from \"../../Interfaces/ERC777TokensSender.sol\";\nimport { ERC777TokensRecipient } from \"../../Interfaces/ERC777TokensRecipient.sol\";\nimport { ProxyImplementation } from \"../../Libraries/ProxyImplementation.sol\";\nimport { ERC20BaseToken } from \"../erc20/ERC20BaseToken.sol\";\n\ncontract ERC777BaseToken is ProxyImplementation, ERC20BaseToken, /*ERC777Token,*/ ERC777TokenEvents, ERC820Implementer {\n\n    mapping(address => mapping(address => bool)) internal mAuthorizedOperators;\n\n    constructor() public {\n        init777();\n    }\n    function init777() public phase('777') {\n        setInterfaceImplementation(\"ERC777Token\", address(this));\n        setInterfaceImplementation(\"ERC20Token\", address(this));\n    }\n\n    /// @return the granularity of the token\n    function granularity() public pure returns (uint256) { return 1; }\n\n    /// @notice Return the list of default operators\n    /// @return the list of all the default operators\n    function defaultOperators() public pure returns (address[] memory) {}\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_data` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint256 _amount, bytes memory _data) public {\n        _send(msg.sender, msg.sender, _to, _amount, _data, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) public {\n        require(_operator != msg.sender, \"Cannot authorize yourself as an operator\");\n        mAuthorizedOperators[_operator][msg.sender] = true;\n        emit AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) public {\n        require(_operator != msg.sender, \"Cannot revoke yourself as an operator\");\n        mAuthorizedOperators[_operator][msg.sender] = false;\n        emit RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {\n        return (_operator == _tokenHolder // solium-disable-line operator-whitespace\n            || mAuthorizedOperators[_operator][_tokenHolder]);\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _data Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _data, bytes memory _operatorData) public {\n        require(isOperatorFor(msg.sender, _from), \"Not an operator\");\n        _send(msg.sender, _from, _to, _amount, _data, _operatorData, true);\n    }\n\n    \n\n    /* -- Helper Functions -- */\n    \n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    function isRegularAddress(address _addr) internal view returns(bool) {\n        if (_addr == address(0)) { return false; }\n        uint size;\n        assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\n        return size == 0;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _data Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777tokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function _send(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        callSender(_operator, _from, _to, _amount, _data, _operatorData);\n\n        super._transfer(_from, _to, _amount); // TODO test it does not call this._transfer (which would emit 2 Sent event)\n\n        callRecipient(_operator, _from, _to, _amount, _data, _operatorData, _preventLocking);\n\n        emit Sent(_operator, _from, _to, _amount, _data, _operatorData);\n    }\n\n    function _transfer(address _from, address _to, uint256 _amount) internal {\n        _send(msg.sender, _from, _to, _amount, \"\", \"\", false);\n    }\n    \n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _data Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ERC777TokensRecipient\");\n        if (recipientImplementation != address(0)) {\n            ERC777TokensRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _data, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to), \"Cannot send to contract without ERC777TokensRecipient\");\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _data Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData\n    )\n        internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ERC777TokensSender\");\n        if (senderImplementation == address(0)) { return; }\n        ERC777TokensSender(senderImplementation).tokensToSend(\n            _operator, _from, _to, _amount, _data, _operatorData);\n    }\n\n\n    // extra functionalities //////////////////////////////////////////////////////////////////////////////\n\n    function _mint(address _to, uint256 _amount) internal {\n        super._mint(_to, _amount);\n        emit Minted(msg.sender, _to, _amount, '');\n    }\n\n    function _burn(address _from, uint256 _amount) internal {\n        super._burn(_from, _amount);\n        emit Burned(msg.sender, _from, _amount, '', '');\n    }\n\n}\n"

    },

    "src/Sand/erc777/ERC777MetaTxExtension.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../../Libraries/BytesUtil.sol\";\nimport \"../../Libraries/SigUtil.sol\";\nimport \"../../Libraries/SafeMath.sol\";\nimport \"../erc20/ERC20MetaTxExtension.sol\";\n\n// TODO WORK IN PROGRESS\ncontract ERC777MetaTxExtension is ERC20MetaTxExtension {\n\n\n    bytes32 constant ERC777METATRANSACTION_TYPEHASH = keccak256(\"ERC777MetaTransaction(address from,address to,uint256 amount,bytes data,uint256 nonce,uint256 gasPrice,uint256 gasLimit,uint256 tokenGasPrice,address relayer)\");\n\n    // TODO could potentialy get ir fo this and use operatorSend instead (the token contract itself could be an defaultOperator)\n    function sendFrom(address _from, address _to, uint256 _amount, bytes calldata _data) external {\n        require(msg.sender == address(this), \"only to be used by contract to support meta-tx\"); // allow _from to allow gas estimatiom\n        _send(_from, _from, _to, _amount, _data, \"\", true);\n    }\n\n    function executeERC777MetaTx(\n        address _from,\n        address _to, \n        uint256 _amount,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        address _tokenReceiver,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        uint256 initialGas = gasleft();\n        ensureParametersValidity(_from, _amount, params, _relayer, initialGas);\n        ensureCorrectSigner(_from, _to, _amount, _data, params, _relayer, _sig, ERC777METATRANSACTION_TYPEHASH, signedOnBehalf);\n        return performERC777MetaTx(_from, _to, _amount, _data, params, initialGas, _tokenReceiver);\n    }\n\n    function executeERC777MetaTxViaBasicSignature(\n        address _from,\n        address _to,  \n        uint256 _amount,\n        bytes calldata _data,\n        uint256[4] calldata params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        address _relayer,\n        bytes calldata _sig,\n        address _tokenReceiver,\n        bool signedOnBehalf\n    ) external returns (bool, bytes memory) {\n        uint256 initialGas = gasleft();\n        ensureParametersValidity(_from, _amount, params, _relayer, initialGas);\n        ensureCorrectSignerViaBasicSignature(_from, _to, _amount, _data, params, _relayer, _sig, ERC777METATRANSACTION_TYPEHASH, signedOnBehalf);\n        return performERC777MetaTx(_from, _to, _amount, _data, params, initialGas, _tokenReceiver);\n    }\n\n    function performERC777MetaTx(\n        address _from,\n        address _to,\n        uint256 _amount, \n        bytes memory _data,\n        uint256[4] memory params, // _nonce, _gasPrice, _txGas, _tokenGasPrice\n        uint256 initialGas,\n        address _tokenReceiver\n    ) internal returns (bool, bytes memory) {\n        nonces[_from] = params[0]; // TODO  extract to not dupplicate ERC20MetaTxExtension code\n\n        bool success;\n        bytes memory returnData;\n        if(_data.length == 0){\n            _transfer(_from, _to, _amount);\n            success = true;\n        } else {\n            // should we support non-erc777 execution ?\n            (success, returnData) = address(this).call.gas(params[2])(abi.encodeWithSignature(\"sendFrom(address,address,uint256,bytes)\", _from, _to, _amount, _data));\n            require(gasleft() >= params[2].div(63), \"not enough gas left\");\n        }\n\n        // TODO  extract to not dupplicate ERC20MetaTxExtension code\n        emit MetaTx(_from, params[0], success, returnData);\n        \n        if(params[3] > 0) {\n            uint256 gasConsumed = (initialGas + MIN_GAS) - gasleft();\n            if(gasConsumed > GAS_LIMIT_OFFSET + params[2]) {\n                gasConsumed = GAS_LIMIT_OFFSET + params[2]; \n                // idealy we would like to charge only max(BASE_GAS, gas consumed outside the inner call) + gas consumed as part of the inner call\n            }\n            _transfer(_from, _tokenReceiver, gasConsumed * params[3]);\n        }\n        \n        return (success, returnData);\n    }\n\n    function _send(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData,\n        bool _preventLocking\n    )internal;\n}\n"

    },

    "src/Sand/erc777/extra/ERC777WithOptionalERC20.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport { ERC777BaseToken } from \"../ERC777BaseToken.sol\";\n\nimport { Ownable } from \"../../../Libraries/ownership/Ownable.sol\";\n\ncontract ERC777WithOptionalERC20 is ERC777BaseToken, Ownable {\n\n    bool internal mErc20compatible;\n    \n    event ERC20Disabled();\n\n    constructor() public {\n        initOptionalERC20();\n    }\n    function initOptionalERC20() public phase('OptionalERC20') {\n        init777();\n        mErc20compatible = true;\n    }\n\n    /// @notice This modifier is applied to erc20 obsolete methods that are\n    ///  implemented only to maintain backwards compatibility. When the erc20\n    ///  compatibility is disabled, this methods will fail.\n    modifier erc20 () {\n        require(mErc20compatible, \"ERC20 is disabled\");\n        _;\n    }\n\n     /// @notice Disables the ERC20 interface. This function can only be called\n    ///  by the owner.\n    function disableERC20() public onlyOwner {\n        mErc20compatible = false;\n        setInterfaceImplementation(\"ERC20Token\", address(0));\n        emit ERC20Disabled();\n    }\n\n    function decimals() public erc20 view returns (uint8) { return super.decimals(); }\n    function transfer(address _to, uint256 _amount) public erc20 returns (bool success) { return super.transfer(_to, _amount); }\n    function transferFrom(address _from, address _to, uint256 _amount) public erc20 returns (bool success) { return super.transferFrom(_from, _to, _amount); }\n    function approve(address _spender, uint256 _amount) public erc20 returns (bool success) { return super.approve(_spender, _amount); }\n    function allowance(address _owner, address _spender) public erc20 view returns (uint256 remaining) { return super.allowance(_owner, _spender); }\n\n    //override to block from emitting Transfer when not mErc20compatible\n    function _send(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        callSender(_operator, _from, _to, _amount, _data, _operatorData);\n\n        // _transfer ///////////////////////////////////////////////////////////////\n        require(_to != address(0), \"Cannot send to 0x0\");\n        require(mBalances[_from] >= _amount, \"Not enough funds\");\n\n        mBalances[_from] = mBalances[_from] -= _amount;\n        mBalances[_to] = mBalances[_to] += _amount;\n\n        if (mErc20compatible) { emit Transfer(_from, _to, _amount); }\n        // ////////////////////////////////////////////////////////////////////////\n\n        callRecipient(_operator, _from, _to, _amount, _data, _operatorData, _preventLocking);\n\n        emit Sent(_operator, _from, _to, _amount, _data, _operatorData);\n    }\n}\n"

    },

    "src/Sand/erc777/extra/ERC777WithoutERC20.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport { ERC777BaseToken } from \"../ERC777BaseToken.sol\";\n\nimport { Ownable } from \"../../../Libraries/ownership/Ownable.sol\";\n\ncontract ERC777WitoutERC20 is ERC777BaseToken, Ownable {\n\n    constructor() public {\n        init777WithoutERC20();\n    }\n    function init777WithoutERC20() public phase('777WithoutERC20') {\n        setInterfaceImplementation(\"ERC20Token\", address(0));\n    }\n\n    /// overrite ERC20BaseToken ERC20 methods to revert\n    function decimals() public view returns (uint8) { revert(); }\n    function transfer(address, uint256) public returns (bool) { revert(); }\n    function transferFrom(address, address, uint256) public returns (bool) { revert(); }\n    function approve(address, uint256) public returns (bool) { revert(); }\n    function allowance(address, address) public view returns (uint256) { revert(); }\n\n    //override to block from emitting Transfer when not mErc20compatible\n    function _send(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData,\n        bool _preventLocking\n    )\n        internal\n    {\n        callSender(_operator, _from, _to, _amount, _data, _operatorData);\n\n        require(_to != address(0), \"Cannot send to 0x0\");\n        require(mBalances[_from] >= _amount, \"Not enough funds\");\n\n        mBalances[_from] = mBalances[_from] -= _amount;\n        mBalances[_to] = mBalances[_to] += _amount;\n\n        callRecipient(_operator, _from, _to, _amount, _data, _operatorData, _preventLocking);\n\n        emit Sent(_operator, _from, _to, _amount, _data, _operatorData);\n    }\n}\n"

    },

    "src/Sand/Sand20.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./erc20/ERC20ApproveExtension.sol\";\nimport \"./erc20/ERC20MetaTxExtension.sol\";\nimport \"./erc777/ERC20BaseTokenWithERC777Events.sol\";\nimport \"../TheSandbox712.sol\";\nimport { ProxyImplementation } from \"../Libraries/ProxyImplementation.sol\";\n\ncontract Sand20 is ProxyImplementation, ERC20MetaTxExtension, ERC20ApproveExtension, TheSandbox712, ERC20BaseTokenWithERC777Events {\n\n    constructor(address _admin, address _beneficiary) public {\n        initSand(_admin, _beneficiary);\n    }\n    function initSand(address _admin, address _beneficiary) public phase('SAND_20') {\n        init712();\n        admin = _admin;\n        if(mTotalSupply == 0 ) { _mint(_beneficiary, 3000000000000000000000000000); }\n    }\n\n    function name() public view returns (string memory) { return \"SAND\"; }\n    function symbol() public view returns (string memory) { return \"SAND\"; }\n\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n}\n"

    },

    "src/Sand/Sand20Basic.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./erc777/ERC20BaseTokenWithERC777Events.sol\";\nimport { ProxyImplementation } from \"../Libraries/ProxyImplementation.sol\";\n\ncontract Sand20Basic is ProxyImplementation, ERC20BaseTokenWithERC777Events {\n\n    constructor(address _admin, address _beneficiary) public {\n        initSand(_admin, _beneficiary);\n    }\n    function initSand(address _admin, address _beneficiary) public phase('SAND_20') {\n        admin = _admin;\n        if(mTotalSupply == 0 ) { _mint(_beneficiary, 3000000000000000000000000000); }\n    }\n\n    function name() public pure returns (string memory) { return \"SAND\"; }\n    function symbol() public pure returns (string memory) { return \"SND\"; }\n\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n}\n"

    },

    "src/Sand/Sand777.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./erc20/ERC20ApproveExtension.sol\";\nimport \"./erc777/ERC777BaseToken.sol\";\nimport \"../TheSandbox712.sol\";\nimport { ProxyImplementation } from \"../Libraries/ProxyImplementation.sol\";\nimport \"./erc20/ERC20MetaTxExtension.sol\";\nimport \"./erc777/ERC777MetaTxExtension.sol\";\n\ncontract Sand777 is ERC777MetaTxExtension, ProxyImplementation, ERC20ApproveExtension, TheSandbox712, ERC777BaseToken {\n\n    // TODO add _owners\n    constructor(address _beneficiary) public {\n        initSand(_beneficiary);\n    }\n    // TODO need to be updated if updating inheritance  // better pattern ?\n    function initSand(address _beneficiary) public phase('SAND_777') {\n        init712();\n        init777(); \n        if(mTotalSupply == 0 ) { _mint(_beneficiary, 3000000000000000000000000000); }\n    }\n\n    function name() public pure returns (string memory) { return \"SAND\"; }\n    function symbol() public pure returns (string memory) { return \"SND\"; }\n\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n}\n"

    },

    "src/Sand.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./Sand/Sand20.sol\";\n\ncontract Sand is Sand20 {\n    constructor(address _admin, address _beneficiary) public Sand20(_admin, _beneficiary) {}\n}\n"

    },

    "src/SimpleMultiSig.sol": {

      "content": "pragma solidity 0.5.2;\n\n// from : https://github.com/christianlundkvist/simple-multisig/blob/f63ef72e448ecef85dd61ad5a3727c7dba4e4377/contracts/SimpleMultiSig.sol\n// + specify 0.5.2\n// + fixed indentation + add storage location\ncontract SimpleMultiSig {\n\n    // kekkac256(\"MultiSigTransaction(address destination,uint256 value,bytes data,uint256 nonce,address executor,uint256 gasLimit)\")\n    bytes32 constant TXTYPE_HASH = 0x3ee892349ae4bbe61dce18f95115b5dc02daf49204cc602458cd4c1f540d56d7;\n\n    bytes32 constant SALT = 0x251543af6a222378665a76fe38dbceae4871a070b7fdaf5c6c30cf758dc33cc0;\n\n    uint public nonce;                 // (only) mutable state\n    uint public threshold;             // immutable state\n    mapping (address => bool) isOwner; // immutable state\n    address[] public ownersArr;        // immutable state\n\n     \n    // Note that owners_ must be strictly increasing, in order to prevent duplicates\n    constructor(uint threshold_, address[] memory owners_) public {\n        require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ > 0);\n\n        address lastAdd = address(0);\n        for (uint i = 0; i < owners_.length; i++) {\n            require(owners_[i] > lastAdd);\n            isOwner[owners_[i]] = true;\n            lastAdd = owners_[i];\n        }\n        ownersArr = owners_;\n        threshold = threshold_;\n    }\n\n\n    // Note that address recovered from signatures must be strictly increasing, in order to prevent duplicates\n    function execute(uint8[] memory sigV, bytes32[] memory sigR, bytes32[] memory sigS, address destination, uint value, bytes memory data, address executor, uint gasLimit) public {\n        require(sigR.length == threshold);\n        require(sigR.length == sigS.length && sigR.length == sigV.length);\n        require(executor == msg.sender || executor == address(0));\n\n        bytes32 txInputHash = keccak256(abi.encodePacked(\n            address(this),\n            TXTYPE_HASH,\n            SALT,\n            destination,\n            value,\n            keccak256(data),\n            nonce,\n            executor,\n            gasLimit\n        ));\n        bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", txInputHash));\n\n        address lastAdd = address(0); // cannot have address(0) as an owner\n        for (uint i = 0; i < threshold; i++) {\n            address recovered = ecrecover(totalHash, sigV[i], sigR[i], sigS[i]);\n            require(recovered > lastAdd && isOwner[recovered]);\n            lastAdd = recovered;\n        }\n\n        // If we make it here all signatures are accounted for.\n        // The address.call() syntax is no longer recommended, see:\n        // https://github.com/ethereum/solidity/issues/2884\n        nonce = nonce + 1;\n        bool success = false;\n        assembly { success := call(gasLimit, destination, value, add(data, 0x20), mload(data), 0, 0) }\n        require(success);\n    }\n\n    function () payable external {}\n}"

    },

    "src/SimpleMultiSigDeployer.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./SimpleMultiSig.sol\";\n\ncontract SimpleMultiSigDeployer {\n\n    event MultiSigDeployed(string indexed name, address indexed multiSigAddress, uint256 threshold, address[] owners);\n    event MultiSigOwner(string indexed name, address indexed owner);\n    \n    mapping(string => SimpleMultiSig) deployed;\n    address owner;\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n\n    // TODO ?\n    // function deploySimpleMultiSig(uint256 threshold_, address[] calldata owners_, uint256 chainId, string calldata name) external {\n    //     require(msg.sender == owner, \"only owner can deploy\");\n    //     require(address(deployed[name]) == address(0), \"same name already deployed\");\n    //     SimpleMultiSig simpleMultiSig = new SimpleMultiSig(threshold_, owners_, chainId);\n    //     deployed[name] = simpleMultiSig;\n    //     for(uint256 i = 0; i < owners_.length; i++) {\n    //         emit MultiSigOwner(name, owners_[i]);\n    //     }\n    //     emit MultiSigDeployed(name, address(simpleMultiSig), threshold_, owners_);\n    // }\n\n    function isDeployed(string calldata name) external view returns(bool) {\n        return address(deployed[name]) != address(0);\n    }\n\n    function transferOwnership(address _newOwner) external {\n        require(msg.sender == owner, \"only owner can change owner\");\n        owner = _newOwner;\n    }\n}\n"

    },

    "src/Test/ERC1271Wallet.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Interfaces/ERC1271.sol\";\nimport \"../Interfaces/ERC1271Constants.sol\";\nimport \"../Libraries/SigUtil.sol\";\n\ncontract ERC1271Wallet is ERC1271, ERC1271Constants{\n\n    address owner;\n    mapping(address => bool) authorizedSigners;\n\n    constructor(address _signer) public {\n        owner = msg.sender;\n        authorizedSigners[_signer] = true;\n    }\n\n    function isValidSignature(\n        bytes memory _data, \n        bytes memory _signature\n    ) public view returns (bytes4 magicValue){\n        address signer = SigUtil.recoverWithZeroOnFailure(keccak256(_data), _signature);\n        if(authorizedSigners[signer]) {\n            return ERC1271_MAGICVALUE;\n        }\n    }\n}"

    },

    "src/Test/ERC20Fund.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Interfaces/ERC20.sol\";\n\ncontract ERC20Fund {\n\n    ERC20 token;\n    address owner;\n\n    constructor(ERC20 _token) public {\n        token = _token;\n        owner = msg.sender;\n    }\n\n    function take(address _from, uint256 _amount) public returns(bool) {\n        return token.transferFrom(_from, address(this), _amount);\n    }\n\n    function give(address _to, uint256 _amount) public returns(bool) {\n        require(msg.sender == owner, \"only onwer can give\");\n        return token.transfer(_to, _amount);\n    }\n\n    function fail() external pure {\n        require(false, \"fail\");\n    }\n}"

    },

    "src/Test/ERC20MetaTxReceiver.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Interfaces/ERC20.sol\";\n\ncontract ERC20MetaTxReceiver {\n\n    ERC20 token;\n    address owner;\n    uint256 price;\n    uint256 balance;\n\n    event Received(address sender, uint256 value, string name, uint256 test);\n\n    constructor(ERC20 _token, uint256 _price) public {\n        token = _token;\n        price = _price;\n        owner = msg.sender;\n    }\n\n    function receiveMeta(address sender, uint256 value, string calldata name, uint256 test) external {\n        require(msg.sender == sender || msg.sender == address(token), \"sender != msg.sender || token\");\n        require(value == price, \"not enough value\");\n        token.transferFrom(sender, address(this), value);\n        \n        balance += value;\n        emit Received(sender, value, name, test);\n    }\n\n    function withdrawnAll() external {\n        require(owner == msg.sender, \"only owner can withdraw\");\n        uint256 tmpBalance = balance;\n        balance = 0;\n        token.transfer(msg.sender, tmpBalance);\n    }\n}"

    },

    "src/Test/GasDrain.sol": {

      "content": "pragma solidity 0.5.2;\n\ncontract GasDrain  {\n\n    mapping(uint256 => uint256) store;\n\n    function receiveAnyToken(address sender, address token, uint256 id, uint256 value, uint256 amoutOfGas) external {\n        uint256 start = gasleft() + 500; // TODO\n        uint256 i = 1;\n        while(start - gasleft() < amoutOfGas) {\n            i++;\n        }\n    }\n\n    function receiveSpecificERC20(address, uint256, uint256 amoutOfGas) external {\n        uint256 start = gasleft() + 303; // 301 for amoutOfGas == 3000000 // 321 for amountOfGas == 2000000 // 303 for amountOfGas == 5000000\n        while(start - gasleft() < amoutOfGas) {}\n    }\n\n    function receiveSpecificERC20IfEnoughGas(address, uint256, uint256 amoutOfGas) external {\n        assert(gasleft() > amoutOfGas - 231); // 231 for amoutOfGas == 5000000\n    }\n\n    function receive(uint256 amoutOfGas) external view {\n        uint256 start = gasleft() + 301;\n        while(start - gasleft() < amoutOfGas) {}\n    }\n    \n    function receiveWithData(uint256 amoutOfGas, bytes calldata) external view {\n        uint256 start = gasleft() + 427;\n        while(start - gasleft() < amoutOfGas) {}\n    }\n}\n"

    },

    "src/Test/GasTest.sol": {

      "content": "pragma solidity 0.5.2;\n\ncontract GasTest{\n    \n    uint256 constant WORST_CASE_EPSILON = 1000;\n\n    event Tx(bool success, bytes returnData, uint256 gasUsed);\n    \n    function test(uint256 epsilon, uint256 txGas, address _to, bytes calldata _data) external returns (bool success, bytes memory returnData) {\n        uint256 gasAvailable = gasleft() - epsilon;\n        require(gasAvailable - gasAvailable/64 > txGas, \"not enough gas\");\n        (success, returnData) = _to.call.gas(txGas)(_data);\n        emit Tx(success, returnData, gasAvailable - gasleft());\n    }\n\n    function test(uint256 txGas, address _to, bytes calldata _data) external returns (bool success, bytes memory returnData) {\n        uint256 gasAvailable = gasleft() - WORST_CASE_EPSILON;\n        require(gasAvailable - gasAvailable/64 > txGas, \"not enough gas\");\n        (success, returnData) = _to.call.gas(txGas)(_data);\n        emit Tx(success, returnData, gasAvailable - gasleft());\n    }\n    \n    function raw(uint256 txGas, address _to, bytes calldata _data) external returns (bool success, bytes memory returnData) {\n        uint256 gasAvailable = gasleft();\n        (success, returnData) = _to.call.gas(txGas)(_data);\n        emit Tx(success, returnData, gasAvailable - gasleft());\n    }\n}\n"

    },

    "src/Test/GenericERC20MetaTxReceiver.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Interfaces/ERC20.sol\";\n\ncontract GenericERC20MetaTxReceiver {\n\n    address metaTxContract;\n    ERC20 token;\n    address owner;\n    uint256 price;\n    uint256 balance;\n\n    event Received(address sender, uint256 value);\n\n    constructor(address _metaTxContract, ERC20 _token, uint256 _price) public {\n        token = _token;\n        owner = msg.sender;\n        price = _price;\n        metaTxContract = _metaTxContract;\n    }\n\n    function erc20_tokensReceived(address from, address tokenContract, uint256 amount, bytes calldata data) external {\n        // TODO check token being given\n        require(msg.sender == address(metaTxContract) || msg.sender == tokenContract , \"sender != metaTxContract && != tokenContract\");\n        require(amount == price, \"not enough value\");\n        balance += amount;\n        emit Received(from, amount);\n    }\n\n    function meta_transaction_received(address sender, bytes calldata data) external {\n        (address addr, uint256 value) = abi.decode(data, (address, uint256));\n        require(sender == msg.sender || msg.sender == address(metaTxContract), \"sender != sender && != metaTxContract\");        \n        emit Received(addr, value);\n    }\n\n    function withdrawnAll() external {\n        require(owner == msg.sender, \"only owner can withdraw\");\n        uint256 tmpBalance = balance;\n        balance = 0;\n        token.transfer(msg.sender, tmpBalance);\n    }\n}"

    },

    "src/Test/Sand777Receiver.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Interfaces/ERC777TokensRecipient.sol\";\nimport \"../Interfaces/ERC777Token.sol\";\nimport \"../Interfaces/ERC20.sol\";\nimport { ERC820Implementer } from \"../Libraries/ERC820Implementer.sol\";\n\ncontract Sand777Receiver is ERC777TokensRecipient, ERC820Implementer {\n\n  bool private allowTokensReceived;\n\n  address private owner;\n  ERC777Token private tokenContract;\n  uint256 private tokenBalance;\n\n  constructor(ERC777Token _tokenContract, bool _allowTokensReceived) public {\n    tokenContract = _tokenContract;\n    allowTokensReceived = _allowTokensReceived;\n    owner = msg.sender;\n\n    setInterfaceImplementation(\"ERC777TokensRecipient\", address(this));\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function send(address _to, uint256 _amount) public {\n    tokenContract.send(_to, _amount, \"\");\n  }\n\n  function transfer(address _to, uint256 _amount) public {\n    ERC20(address(tokenContract)).transfer(_to, _amount);\n  }\n\n  function tokensReceived(\n        address,// operator,\n        address,// from,\n        address,// to,\n        uint256 amount,\n        bytes memory,// data,\n        bytes memory // operatorData\n    ) public {\n      require(address(tokenContract) == msg.sender, \"only accept tokenContract as sender\");\n      require(allowTokensReceived, \"Receive not allowed\");\n      tokenBalance += amount;\n    }\n\n  function acceptTokens() public onlyOwner { allowTokensReceived = true; }\n  function rejectTokens() public onlyOwner { allowTokensReceived = false; }\n  \n  \n  function receiveMeta(address sender, string calldata name, uint256 value, uint256 test) external {\n    // for test matching erc20Receiver \n  }\n}"

    },

    "src/Test/Sand777Sender.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Interfaces/ERC777TokensRecipient.sol\";\nimport \"../Interfaces/ERC777Token.sol\";\nimport \"../Interfaces/ERC20.sol\";\nimport { ERC820Implementer } from \"../Libraries/ERC820Implementer.sol\";\n\ncontract Sand777Sender is ERC777TokensRecipient, ERC820Implementer {\n\n  bool private allowTokensSent;\n\n  address private owner;\n  ERC777Token private tokenContract;\n  uint256 private tokenBalance;\n\n  constructor(ERC777Token _tokenContract, bool _allowTokensSent) public {\n    tokenContract = _tokenContract;\n    allowTokensSent = _allowTokensSent;\n    owner = msg.sender;\n\n    setInterfaceImplementation(\"ERC777TokensSender\", address(this));\n    setInterfaceImplementation(\"ERC777TokensRecipient\", address(this));\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function send(address _to, uint256 _amount) public {\n    tokenContract.send(_to, _amount, \"\");\n  }\n\n  function transfer(address _to, uint256 _amount) public {\n    ERC20(address(tokenContract)).transfer(_to, _amount);\n  }\n\n  function tokensReceived(\n        address,// operator,\n        address,// from,\n        address,// to,\n        uint256 amount,\n        bytes memory,// data,\n        bytes memory // operatorData\n    ) public {\n      require(address(tokenContract) == msg.sender, \"only accept tokenContract as sender\");\n      tokenBalance += amount;\n    }\n\n  function tokensToSend(\n        address,// operator,\n        address,// from,\n        address,// to,\n        uint256 amount,\n        bytes memory,// data,\n        bytes memory // operatorData\n    ) public {\n      require(address(tokenContract) == msg.sender, \"only accept tokenContract as sender\");\n      require(allowTokensSent, \"Sending not allowed\");\n      tokenBalance -= amount;\n    }\n\n  function acceptTokens() public onlyOwner { allowTokensSent = true; }\n  function rejectTokens() public onlyOwner { allowTokensSent = false; }\n  \n}"

    },

    "src/Test/TestERC1155ERC721TokenReceiver.sol": {

      "content": "pragma solidity 0.5.2;\n\ncontract TestERC1155ERC721TokenReceiver {\n\n    bool private allowTokensReceived;\n    bool private returnCorrectBytes;\n    bool private allowBatchTokensReceived;\n    bool private returnCorrectBytesOnBatch;\n    bool private doNotThrow;\n\n    address private owner;\n    address private tokenContract;\n    mapping(uint256 => bool) private tokens;\n\n    bytes4 constant private ERC1155_REJECTED = 0xafed434d;\n    bytes4 constant private ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 constant private ERC1155_BATCH_RECEIVED = 0xbc197c81;\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    constructor(\n        address _tokenContract,\n        bool _allowTokensReceived,\n        bool _returnCorrectBytes,\n        bool _allowBatchTokensReceived,\n        bool _returnCorrectBytesOnBatch,\n        bool _doNotThrow\n    ) public {\n        tokenContract = _tokenContract;\n        allowTokensReceived = _allowTokensReceived;\n        returnCorrectBytes = _returnCorrectBytes;\n        allowBatchTokensReceived = _allowBatchTokensReceived;\n        returnCorrectBytesOnBatch = _returnCorrectBytesOnBatch;\n        doNotThrow = _doNotThrow;\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner allowed\");\n        _;\n    }\n\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns(bytes4){\n        require(address(tokenContract) == msg.sender, \"only accept tokenContract as sender\");\n        require(doNotThrow, \"throw requested\");\n        if(!allowTokensReceived) {\n            if(returnCorrectBytes) {\n                return ERC1155_REJECTED;\n            } else {\n                return 0x150b7a03;\n            }\n        }\n        \n        if(returnCorrectBytes) {\n            (bool success, bytes memory returnData) = tokenContract.call(abi.encodeWithSignature(\"ownerOf(uint256)\", _id));\n            uint256 value;\n            assembly {\n                value := mload(add(returnData, 32))\n            }\n            if(success && value == uint256(address(this))) {\n                onERC721Received(_operator, _from, _id, _data);\n            }\n            return ERC1155_RECEIVED;\n        } else {\n            return 0x150b7a03;\n        }\n    }\n    \n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external returns(bytes4){\n        require(address(tokenContract) == msg.sender, \"only accept tokenContract as sender\");\n        require(allowBatchTokensReceived, \"Receive not allowed\");\n        if(returnCorrectBytesOnBatch) {\n            return ERC1155_BATCH_RECEIVED;\n        } else {\n            return 0x150b7a03;\n        }\n    }\n\n    function onERC721Received(\n        address,// operator,\n        address,// from,\n        uint256 _tokenId,\n        bytes memory // data\n      ) public returns (bytes4) {\n        require(address(tokenContract) == msg.sender, \"only accept tokenContract as sender\");\n        require(allowTokensReceived, \"Receive not allowed\");\n        if(returnCorrectBytes) {\n            return _ERC721_RECEIVED;\n        } else {\n            return 0x150b7a03;\n        }\n    }\n\n    function acceptTokens() public onlyOwner { allowTokensReceived = true; }\n    function rejectTokens() public onlyOwner { allowTokensReceived = false; }\n\n    function acceptBatchTokens() public onlyOwner { allowBatchTokensReceived = true; }\n    function rejectBatchTokens() public onlyOwner { allowBatchTokensReceived = false; }\n}"

    },

    "src/Test/TestERC1155Receiver.sol": {

      "content": "pragma solidity 0.5.2;\n\ncontract TestERC1155Receiver {\n\n    bool private allowTokensReceived;\n    bool private returnCorrectBytes;\n    bool private allowBatchTokensReceived;\n    bool private returnCorrectBytesOnBatch;\n\n    address private owner;\n    address private tokenContract;\n    mapping(uint256 => bool) private tokens;\n\n    bytes4 constant private ERC1155_REJECTED = 0xafed434d; // TODO use it\n    bytes4 constant private ERC1155_RECEIVED = 0xf23a6e61;\n    bytes4 constant private ERC1155_BATCH_RECEIVED = 0xbc197c81;\n\n    constructor(\n        address _tokenContract,\n        bool _allowTokensReceived,\n        bool _returnCorrectBytes,\n        bool _allowBatchTokensReceived,\n        bool _returnCorrectBytesOnBatch\n    ) public {\n        tokenContract = _tokenContract;\n        allowTokensReceived = _allowTokensReceived;\n        returnCorrectBytes = _returnCorrectBytes;\n        allowBatchTokensReceived = _allowBatchTokensReceived;\n        returnCorrectBytesOnBatch = _returnCorrectBytesOnBatch;\n\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner allowed\");\n        _;\n    }\n\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns(bytes4){\n        require(address(tokenContract) == msg.sender, \"only accept tokenContract as sender\");\n        require(allowTokensReceived, \"Receive not allowed\");\n        if(returnCorrectBytes) {\n            return ERC1155_RECEIVED;\n        } else {\n            return 0x150b7a03;\n        }\n    }\n    \n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external returns(bytes4){\n        require(address(tokenContract) == msg.sender, \"only accept tokenContract as sender\");\n        require(allowBatchTokensReceived, \"Receive not allowed\");\n        if(returnCorrectBytesOnBatch) {\n            return ERC1155_BATCH_RECEIVED;\n        } else {\n            return 0x150b7a03;\n        }\n    }\n\n    function acceptTokens() public onlyOwner { allowTokensReceived = true; }\n    function rejectTokens() public onlyOwner { allowTokensReceived = false; }\n\n    function acceptBatchTokens() public onlyOwner { allowBatchTokensReceived = true; }\n    function rejectBatchTokens() public onlyOwner { allowBatchTokensReceived = false; }\n}"

    },

    "src/Test/TestERC721TokenReceiver.sol": {

      "content": "pragma solidity 0.5.2;\n\ncontract TestERC721TokenReceiver {\n\n    bool private allowTokensReceived;\n    bool private returnCorrectBytes;\n\n    address private owner;\n    address private tokenContract;\n    mapping(uint256 => bool) private tokens;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    constructor(address _tokenContract, bool _allowTokensReceived, bool _returnCorrectBytes) public {\n        tokenContract = _tokenContract;\n        allowTokensReceived = _allowTokensReceived;\n        returnCorrectBytes = _returnCorrectBytes;\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner allowed\");\n        _;\n    }\n\n    function onERC721Received(\n        address,// operator,\n        address,// from,\n        uint256 _tokenId,\n        bytes memory // data\n      ) public returns (bytes4) {\n        require(address(tokenContract) == msg.sender, \"only accept tokenContract as sender\");\n        require(allowTokensReceived, \"Receive not allowed\");\n        if(returnCorrectBytes) {\n            return _ERC721_RECEIVED;\n        } else {\n            return 0x150b7a03;\n        }\n    }\n\n    function acceptTokens() public onlyOwner { allowTokensReceived = true; }\n    function rejectTokens() public onlyOwner { allowTokensReceived = false; }\n}"

    },

    "src/Test/TestMintingFeeCollector.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"../Asset/Interfaces/MintingFeeCollector.sol\";\n\nimport \"../Asset.sol\";\n\ncontract TestMintingFeeCollector is MintingFeeCollector {\n    \n    mapping(uint256 => uint256) stakes;\n\n    Asset from;\n    address owner;\n    constructor(address _owner, Asset _from) public {\n        from = _from;\n        owner = _owner;\n    }\n\n    function multiple_minted(uint256[] calldata tokenIds, uint256 feePerToken) external {\n        require(msg.sender == address(from), \"only accepting from\");\n        for(uint256 i = 0; i < tokenIds.length; i ++) {\n            stakes[tokenIds[i]] = feePerToken;\n        }\n    }\n\n    function single_minted(uint256 tokenId, uint256 fee) external {\n        require(msg.sender == address(from), \"only accepting from\");\n        stakes[tokenId] = fee;\n    }\n\n    function setFeeCollection(address newCollector, uint256 newFee) external {\n        require(msg.sender == owner);\n        from.setFeeCollection(newCollector, newFee);\n    }\n\n}\n"

    },

    "src/TheSandbox712.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport { ProxyImplementation } from \"./Libraries/ProxyImplementation.sol\";\n\ncontract TheSandbox712 is ProxyImplementation {\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\");\n    bytes32 DOMAIN_SEPARATOR;\n\n    function init712() public phase(\"712\") {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAIN_TYPEHASH, keccak256(\"The Sandbox 3D\"), keccak256(\"1\"), address(this)));\n    }\n    \n    function domainSeparator() internal view returns(bytes32){\n        return DOMAIN_SEPARATOR;\n    }\n}"

    },

    "src/UpgradableProxy/AdminUpgradeabilityProxy.sol": {

      "content": "// from https://github.com/zeppelinos/zos/blob/1cea266a672a1efc31915420af5eb5185173837c/packages/lib/contracts/upgradeability/AdminUpgradeabilityProxy.sol\npragma solidity 0.5.2;\n\nimport \"./UpgradeabilityProxy.sol\";\nimport \"./ProxyAdmin.sol\";\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\n   * validated in the constructor.\n   */\n  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * Contract constructor.\n   * It sets the `msg.sender` as the proxy administrator.\n   * @param _implementation address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address payable _owner, address _implementation, bytes memory _data) UpgradeabilityProxy(_implementation, _data) public payable {\n    assert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\n\n    ProxyAdmin proxyAdmin = new ProxyAdmin(this, _owner); // TODO cheaper creation : https://eips.ethereum.org/EIPS/eip-1167\n    emit AdminChanged(address(0), address(proxyAdmin));\n    _setAdmin(address(proxyAdmin));\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success, bytes memory _) = newImplementation.delegatecall(data);\n    require(success, \"failed to call newImplementation\");\n  }\n\n  /**\n   * @return The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}"

    },

    "src/UpgradableProxy/ProxyAdmin.sol": {

      "content": "pragma solidity 0.5.2;\n\nimport \"./AdminUpgradeabilityProxy.sol\";\nimport \"../Libraries/ownership/Ownable.sol\";\n\ncontract ProxyAdmin is Ownable {\n  \n  AdminUpgradeabilityProxy proxy;\n  constructor(AdminUpgradeabilityProxy _proxy, address payable _owner) public {\n    proxy = _proxy;\n    owner = _owner;\n  }\n\n  function proxyAddress() public view returns (address) {\n    return address(proxy);\n  }\n\n  function admin() public returns (address) {\n    return proxy.admin();\n  }\n\n  function changeAdmin(address newAdmin) public onlyOwner {\n    proxy.changeAdmin(newAdmin);\n  }\n\n  function upgradeTo(address implementation) public onlyOwner {\n    proxy.upgradeTo(implementation);\n  }\n\n  function upgradeToAndCall(address implementation, bytes memory data) payable public onlyOwner {\n    proxy.upgradeToAndCall.value(msg.value)(implementation, data);\n  }\n\n}"

    },

    "src/UpgradableProxy/ProxyBase.sol": {

      "content": "// from https://github.com/zeppelinos/zos/blob/1cea266a672a1efc31915420af5eb5185173837c/packages/lib/contracts/upgradeability/Proxy.sol\npragma solidity 0.5.2;\n\n/**\n * @title ProxyBase\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\ncontract ProxyBase {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  function () payable external {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize)\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize)\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}"

    },

    "src/UpgradableProxy/UpgradeabilityProxy.sol": {

      "content": "// from https://github.com/zeppelinos/zos/blob/1cea266a672a1efc31915420af5eb5185173837c/packages/lib/contracts/upgradeability/UpgradeabilityProxy.sol\npragma solidity 0.5.2;\n\nimport \"./ProxyBase.sol\";\nimport \"../Libraries/AddressUtils.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract UpgradeabilityProxy is ProxyBase {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.implementation\", and is\n   * validated in the constructor.\n   */\n  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\n\n  /**\n   * @dev Contract constructor.\n   * @param _implementation Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _implementation, bytes memory _data) public payable {\n    assert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\"));\n    _setImplementation(_implementation);\n    if(_data.length > 0) {\n      (bool success, bytes memory _) = _implementation.delegatecall(_data);\n      require(success, \"could not call the contract\");\n    }\n  }\n\n  /**\n   * @dev Returns the current implementation.\n   * @return Address of the current implementation\n   */\n  function _implementation() internal view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(AddressUtils.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 2000

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "abi"

        ]

      }

    }

  }

}}