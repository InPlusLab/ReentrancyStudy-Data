/**

 *Submitted for verification at Etherscan.io on 2018-11-17

*/



pragma solidity ^0.4.24;



/**

 * Welcome to new era of smart-contracts. First smart-contract which really earns money! First blochchain fund with real cryptoactivity. 

 * §¥§à§Ò§â§à §á§à§Ø§Ñ§Ý§à§Ó§Ñ§ä§î §Ó §ß§à§Ó§å§ð §ï§â§å §ã§Þ§Ñ§â§ä-§Ü§à§ß§ä§â§Ñ§Ü§ä§à§Ó. §±§â§Ö§Õ§ã§ä§Ñ§Ó§Ý§ñ§Ö§Þ §£§Ñ§ê§Ö§Þ§å §Ó§ß§Ú§Þ§Ñ§ß§Ú§ð §±§¦§²§£§½§« §ã§Þ§Ñ§â§ä-§Ü§à§ß§ä§â§Ñ§Ü§ä, §Ü§à§ä§à§â§í§Û §â§Ö§Ñ§Ý§î§ß§à §©§¡§²§¡§¢§¡§´§½§£§¡§¦§´. §±§¦§²§£§½§« §ã§Þ§Ñ§â§ä-§Ü§à§ß§ä§â§Ñ§Ü§ä §ã §â§Ö§Ñ§Ý§î§ß§à§Û §Ü§â§Ú§á§ä§à§Õ§Ö§ñ§ä§Ö§Ý§î§ß§à§ã§ä§î§ð!

 * 

 * §°§ä 1,5 §Õ§à 3% §Ö§Ø§Ö§Õ§ß§Ö§Ó§ß§à. §£§Ü§Ý§Ñ§Õ§í §à§ä 0.1 ETH §Õ§à §Ò§Ö§ã§Ü§à§ß§Ö§é§ß§à§ã§ä§Ú. §±§â§à§è§Ö§ß§ä§ß§Ñ§ñ §ã§ä§Ñ§Ó§Ü§Ñ §ã§é§Ú§ä§Ñ§Ö§ä§ã§ñ §Ó §Ù§Ñ§Ó§Ú§ã§Ú§Þ§à§ã§ä§Ú §à§ä §â§Ñ§Ù§Þ§Ö§â§Ñ §Ó§Ü§Ý§Ñ§Õ§Ñ. §¹§Ö§Þ §Þ§Ö§ß§î§ê§Ö §Ó§Ü§Ý§Ñ§Õ, §ä§Ö§Þ §Ò§à§Ý§î§ê§Ö §ã§ä§Ñ§Ó§Ü§Ñ.

 * §£§à§Ù§Ó§â§Ñ§ä §ä§Ö§Ý§Ñ §Õ§Ö§á§à§Ù§Ú§ä§Ñ §Ó §á§Ö§â§Ó§í§Ö 5 §Õ§ß§Ö§Û §â§Ñ§Ò§à§ä§í §á§â§Ú §å§ã§Ý§à§Ó§Ú§Ú §ç§à§Ý§Õ§Ñ.

 * §¥§Ú§ß§Ñ§Þ§Ú§é§ß§Ñ§ñ §á§â§à§è§Ö§ß§ä§Ñ§ñ §ã§ä§Ñ§Ó§Ü§Ñ, §Ù§Ñ§Ó§Ú§ã§ñ§ë§Ñ§ñ §à§ä §Õ§ß§Ö§Û §ç§à§Ý§Õ§Ñ (0.01% §Ü§Ñ§Ø§Õ§í§Û §Õ§Ö§ß§î) §Ú §à§Ò§ë§Ö§Û §Ü§Ñ§ã§ã§í §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ (§Ù§Ñ §Ü§Ñ§Ø§Õ§í§Ö 100 ETH 0.1% §Ó §Õ§Ö§ß§î).

 * 70% §Õ§Ö§á§à§Ù§Ú§ä§Ñ §Ó§à§Ù§Ó§â§Ñ§ë§Ñ§Ö§ä§ã§ñ §ß§Ñ §Ü§à§ß§ä§â§Ñ§Ü§ä, 5% §å§ç§à§Õ§Ú§ä §Ó §Ü§Ñ§ã§ã§å §Õ§Ý§ñ §Ö§Ø§Ö§Õ§ß§Ö§Ó§ß§à§Ô§à §â§à§Ù§í§Ô§â§í§ê§Ñ §Õ§Ø§Ö§Ü§á§à§ä§Ñ, §Ñ §ß§Ñ 25% §Ú§ß§Ó§Ö§ã§ä§Ú§è§Ú§Û §á§à§Ü§å§á§Ñ§ð§ä§ã§ñ §ä§à§Ü§Ö§ß§í §ã §Ó§í§ã§à§Ü§à§ï§æ§æ§Ö§Ü§ä§Ú§Ó§ß§í§Þ§Ú §Þ§Ñ§ã§ä§Ö§â§ß§à§Õ§Ñ§Þ§Ú, ROI §à§ä 300% §Ö§Ø§Ö§Þ§Ö§ã§ñ§é§ß§à.

 * §©§Ñ§â§Ñ§Ò§à§ä§Ñ§ß§ß§í§Ö §Õ§Ö§ß§î§Ô§Ú §ã §Þ§Ñ§ã§ä§Ö§â§ß§à§Õ §Ó§à§Ù§Ó§â§Ñ§ë§Ñ§ð§ä§ã§ñ §ß§Ñ §Ü§à§ê§Ö§Ý§Ö§Ü, §à§ä§Ü§å§Õ§Ñ §Ú§Õ§å§ä §à§Ò§â§Ñ§ä§ß§à §ß§Ñ §ã§Þ§Ñ§â§ä-§Ü§à§ß§ä§â§Ñ§Ü§ä. §°§Ò§â§Ñ§ä§ß§í§Ö §Ó§Ü§Ý§Ñ§Õ§í §ã §ï§ä§à§Ô§à §Ü§à§ê§Ö§Ý§î§Ü§Ñ §ß§Ö §ã§é§Ú§ä§Ñ§ð§ä§ã§ñ §Ú§ß§Ó§Ö§ã§ä§à§â§ã§Ü§Ú§Þ§Ú, §ä.§Ö. §ß§Ñ §ß§Ú§ç §ß§Ö §Ú§Õ§å§ä §á§â§à§è§Ö§ß§ä§í §à§Ò§â§Ñ§ä§ß§à §ß§Ñ §Ü§à§ê§Ö§Ý§Ö§Ü §Õ§Ý§ñ §Þ§Ñ§ã§ä§Ö§â§ß§à§Õ.

 * §²§Ö§Ñ§Ý§î§ß§í§Û §Ù§Ñ§â§Ñ§Ò§à§ä§à§Ü - §Ò§Ö§ã§Ü§à§ß§Ö§é§ß§Ñ§ñ §Ü§Ñ§ã§ã§Ñ. §£§ã§ä§å§á§Ñ§Û§ä§Ö §á§Ö§â§Ó§í§Þ§Ú, §á§à§ã§Ý§Ö§Õ§ß§Ú§Þ§Ú §Ú§Ý§Ú §Þ§Ö§Ø§Õ§å - §Ó§í §Ó§ã§× §â§Ñ§Ó§ß§à §Ò§å§Õ§Ö§ä§Ö §Ó §á§â§à§æ§Ú§ä§Ö.

 * §®§Ñ§Ü§ã§Ú§Þ§Ñ§Ý§î§ß§í§Û §Ù§Ñ§â§Ñ§Ò§à§ä§à§Ü - 200%, §á§à§ã§Ý§Ö §Ü§à§ß§ä§â§Ñ§Ü§ä §Ó§í§Ü§Ú§Õ§í§Ó§Ñ§Ö§ä §£§Ñ§ã §ã §Ó§à§Ù§Þ§à§Ø§ß§à§ã§ä§î§ð §á§Ö§â§Ö§Ù§Ñ§Û§ä§Ú §ã§ß§à§Ó§Ñ

 * 

 * §¤§Õ§Ö §á§â§à§è§Ö§ß§ä §ß§Ñ §Þ§Ñ§â§Ü§Ö§ä§Ú§ß§Ô? §¡§Õ§Þ§Ú§ß§í §Ü§å§ê§Ñ§ð§ä §ç§Ý§Ö§Ò §ã §Ó§à§Õ§à§Û? 

 * §¯§Ö§ä. §¡§Õ§Þ§Ú§ß§ã§Ü§Ú§Û §Ú §Þ§Ñ§â§Ü§Ö§ä§Ú§ß§Ô§à§Ó§í§Û §á§â§à§è§Ö§ß§ä - §ï§ä§à §Ú§Ù§Ý§Ú§ê§Ü§Ú §Ù§Ñ§â§Ñ§Ò§à§ä§Ü§Ñ §Þ§Ñ§ã§ä§Ö§â§ß§à§Õ. §£§Ñ§ê§Ú §Õ§Ö§ß§î§Ô§Ú §â§Ñ§Ò§à§ä§Ñ§ð§ä §Ü§Ñ§Ü §ß§Ñ §£§Ñ§ã, §ä§Ñ§Ü §Ú §ß§Ñ §ß§Ñ§ã. §¯§à §ß§Ñ§á§â§ñ§Þ§å§ð §á§â§à§è§Ö§ß§ä§í §ã §Ó§Ü§Ý§Ñ§Õ§é§Ú§Ü§à§Ó §Ñ§Õ§Þ§Ú§ß§Ú§ã§ä§â§Ñ§è§Ú§ñ §ß§Ö §Ò§Ö§â§Ö§ä.

 * 

 * Website: https://dbubble.org

 * Telegram news: t.me/DoubleYourBubble

 * Telegram chat: https://t.me/joinchat/BGZn8Uo2ApSEKvuTH40l8g

 *

 * RECOMMENDED GAS LIMIT: 200000

 * RECOMMENDED GAS PRICE: https://ethgasstation.info/

 */



contract Bubble {

    using SafeMath for uint256;



    mapping (address => uint256) public uInvested;

    mapping (address => uint256) public uWithdrawn;

    mapping (address => uint256) public uOperationTime;

    mapping (address => uint256) public uWithdrawTime;



    uint256 constant public MIN_INVEST = 100 finney;

    uint256 constant public LIGHT_PERCENT = 300;

    uint256 constant public MIDDLE_PERCENT = 200;

    uint256 constant public HIGH_PERCENT = 150;

    

    uint256 constant public MIDDLE_RATE = 10000 finney;

    uint256 constant public HIGH_RATE = 50000 finney;

    

    uint256 constant public NODE_PERCENT = 2500;

    uint256 constant public REF_PERCENT = 500;

    uint256 constant public MAX_MUL = 2;

    uint256 constant public FINE_PERCENT = 9000;

    uint256 constant public PERCENTS = 10000;

    

    uint256 constant public TIME_STEP = 1 days;

    uint256 constant public BUBBLE_STEP = 100 ether;

    uint256 constant public BUBBLE_BONUS = 10;



    uint256 public bubbleInvested = 0;

    uint256 public bubbleWithdrawn = 0;

    uint256 public bubbleBalance = 0;

    



    address public nodeAddress = 0x162487Db1Af651cd0d4457CD9c1DB1801EC98182;

    address public lotteryAddress = 0x3bFd5e3a0FC6733Cc847D544aa354771576797C9;



    event addedInvest(address indexed user, uint256 amount);

    event payedDividends(address indexed user, uint256 dividend);

    event payedFees(address indexed user, uint256 amount);

    event payedReferrals(address indexed user, address indexed referrer, uint256 amount, uint256 refAmount);



    function Invest() private {



        if (uInvested[msg.sender] == 0) {

            uOperationTime[msg.sender] = now;

            uWithdrawTime[msg.sender] = now;

        } else {

            Dividends();

        }



        uInvested[msg.sender] += msg.value;

        emit addedInvest(msg.sender, msg.value);

        bubbleInvested = bubbleInvested.add(msg.value);



        uint256 nodeFee = msg.value.mul(NODE_PERCENT).div(PERCENTS);

        uint256 refFee = msg.value.mul(REF_PERCENT).div(PERCENTS);

        

        nodeAddress.transfer(nodeFee);

        emit payedFees(msg.sender, nodeFee);

        

        address refAddress = bytesToAddress(msg.data);

        if (refAddress > 0x0 && refAddress != msg.sender && (uInvested[refAddress]>0)) {

            refAddress.transfer(refFee);

            emit payedReferrals(msg.sender, refAddress, msg.value, refFee);

        }

        else

        {

            lotteryAddress.transfer(refFee);

            emit payedReferrals(msg.sender, lotteryAddress, msg.value, refFee);

        }

    }

   

   function getUserAmount(address userAddress) public view returns (uint256) {

        

        uint256 currentPercent;

        

        if ((uInvested[userAddress]>=MIN_INVEST) && (uInvested[userAddress]<MIDDLE_RATE))

        {

            currentPercent = LIGHT_PERCENT;

        }

        

        if ((uInvested[userAddress]>=MIDDLE_RATE) && (uInvested[userAddress]<HIGH_RATE))

        {

            currentPercent = MIDDLE_PERCENT;

        }

        

        if (uInvested[userAddress]>=HIGH_RATE)

        {

            currentPercent = HIGH_PERCENT;

        }

        

        uint256 tBalance = address(this).balance;

        

        uint256 userBonus = now.sub(uWithdrawTime[userAddress]).div(TIME_STEP); 

        

        uint256 toBbonus = tBalance.div(BUBBLE_STEP);

        uint256 bubbleBonus = toBbonus.mul(BUBBLE_BONUS);

        

        currentPercent+=userBonus;

        currentPercent+=bubbleBonus;

        

        uint256 userPercents = uInvested[userAddress].mul(currentPercent).div(PERCENTS);

        

        uint256 timeInterval = now.sub(uWithdrawTime[userAddress]);

        uint256 userAmount = userPercents.mul(timeInterval).div(TIME_STEP);

        

        return userAmount;

    }



    function Dividends() private {

        require(uInvested[msg.sender] != 0);



        uint256 thisBalance = address(this).balance;

        uint256 userAmount = getUserAmount(msg.sender);

        

        uint256 transAmount;

        uint256 dropUser = 0;

        

        if (uWithdrawn[msg.sender] != 0)

        {

            userAmount = userAmount.mul(FINE_PERCENT).div(PERCENTS);

        }

        

        if ((uWithdrawn[msg.sender].add(userAmount))>=(uInvested[msg.sender].mul(MAX_MUL)))

        {

            userAmount = (uInvested[msg.sender].mul(MAX_MUL)).sub(uWithdrawn[msg.sender]);

            dropUser=1;

        }

        

        if (thisBalance >= userAmount) {

            transAmount = userAmount;

        }

        else

        {

            transAmount = thisBalance;

            if ((dropUser == 1) && ((uWithdrawn[msg.sender].add(transAmount))<(uInvested[msg.sender].mul(MAX_MUL))))

            {

                dropUser = 0;

            }

        }

        

        msg.sender.transfer(transAmount);

        uWithdrawn[msg.sender] += transAmount;

        emit payedDividends(msg.sender, transAmount);

        bubbleWithdrawn = bubbleWithdrawn.add(transAmount);

        uWithdrawTime[msg.sender] = now;

        

        if (dropUser==1)

        {

            uInvested[msg.sender]=0;

            uWithdrawn[msg.sender]=0;

        }

    }

    

    function returnDeposit() private {

        require (uInvested[msg.sender] > 0);

        require (uWithdrawn[msg.sender] == 0);

        uint256 returnTime = now;

        require (((returnTime.sub(uOperationTime[msg.sender])).div(1 days)) < 5);

        

        uint256 returnPercent = (PERCENTS.sub(NODE_PERCENT)).sub(REF_PERCENT);

        uint256 returnAmount = uInvested[msg.sender].mul(returnPercent).div(PERCENTS);

        uint256 thisBalance = address(this).balance;

        

        if (thisBalance < returnAmount) {

            returnAmount=thisBalance;

        }

        

        msg.sender.transfer(returnAmount);

        

        uInvested[msg.sender] = 0;

        uWithdrawTime[msg.sender] = now;

    }



address public owner;



    function() external payable {

        



        if (msg.sender != nodeAddress)

        {

            if (msg.value == 0.00000112 ether)

            {

                returnDeposit();

            }

            else 

            { 

                if (msg.value >= MIN_INVEST) {

                    Invest();

                } else {

                    Dividends();

                    uWithdrawTime[msg.sender] = now;

                }

            }

        }

        

        bubbleBalance = address(this).balance;

    }



    function renounceOwnership() external {

        require(msg.sender == owner);

        owner = 0x0;

    }

    

    function bytesToAddress(bytes data) private pure returns (address addr) {

        assembly {

            addr := mload(add(data, 20))

        }

    }

}



/**

* @title SafeMath

* @dev Math operations with safety checks that revert on error

*/

library SafeMath {



    /**

    * @dev Multiplies two numbers, reverts on overflow.

    */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {

            return 0;

        }



        uint256 c = a * b;

        require(c / a == b);



        return c;

    }



    /**

    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.

    */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0); // Solidity only automatically asserts when dividing by 0

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold



        return c;

    }



    /**

    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).

    */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a);

        uint256 c = a - b;



        return c;

    }



    /**

    * @dev Adds two numbers, reverts on overflow.

    */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a);



        return c;

    }

}



/**

*End of code. Have fun and Double Your Bubble!

*/